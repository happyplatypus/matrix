<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="To generate summary stats of indicors on stock for a
day, for example, what was the average bps returns on target stock in the past 5 days - what does that mean for tomorrow's trading? Contains some strategy ideas based on entry and exit. The key concept is to generate a 3-D cube of
assets on y axis, agents(strategies) on x and dates on z. Note that when z is collapsed with summaries, we get a asset agent matrix, which can be used to decide what pairs to run tomorrow.
Needs a subscription to active tick
http://www.activetick.com/activetick/contents/
" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{border-right:none;color:transparent;background-color:transparent;noshade:noshade;border-left:none;border-top:none;margin-bottom:-6px;height:0;border-bottom:dotted #bbb 1px;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;background-color:#F5F5FF;}h1{font-size:20px;margin-top:0;}h2{font-size:18px;}h3{font-size:16px;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{vertical-align:top;font-size:10pt;overflow:hidden;background-color:#F5F5FF;width:55%;border-left:solid #E5E5EE 1px;padding-left:20px;border:none;margin:0px;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*! jQuery v1.7.1 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)ca(a+"["+e+"]",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=b$(a,c,d,e,"*",g));return l}function bZ(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bC(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bx:by,g=0,h=e.length;if(d>0){if(c!=="border")for(;g<h;g++)c||(d-=parseFloat(f.css(a,"padding"+e[g]))||0),c==="margin"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,"border"+e[g]+"Width"))||0;return d+"px"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,"padding"+e[g]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+e[g]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+"px"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?".":"")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.1",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?m(g):h==="function"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement("div"),r=c.documentElement;q.setAttribute("className","t"),q.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=q.getElementsByTagName("*"),e=q.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=q.getElementsByTagName("input")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName("tbody").length,htmlSerialize:!!q.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:q.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent("onclick",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML="",a.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",q.style.width="2px",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n="on"+o,p=n in q,p||(q.setAttribute(n,"return;"),p=typeof q[n]=="function"),b[o+"Bubbles"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName("body")[0];!r||(j=1,k="position:absolute;top:0;left:0;width:1px;height:1px;margin:0;",m="visibility:hidden;border:0;",n="style='"+k+"border:5px solid #000;padding:0;'",o="<div "+n+"><div></div></div>"+"<table "+n+" cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",a=c.createElement("div"),a.style.cssText=m+"width:0;height:0;position:static;top:0;margin-top:"+j+"px",r.insertBefore(a,r.firstChild),q=c.createElement("div"),a.appendChild(q),q.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",l=q.getElementsByTagName("td"),p=l[0].offsetHeight===0,l[0].style.display="",l[1].style.display="none",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML="",q.style.width=q.style.paddingLeft="1px",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!="undefined"&&(q.style.display="inline",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display="",q.innerHTML="<div style='width:4px;'></div>",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position="fixed",e.style.top="20px",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a=="undefined"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],"parsedAttrs")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],"parsedAttrs",!0)}}return h}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split("."),d[1]=d[1]?"."+d[1]:"";if(c===b){h=this.triggerHandler("getData"+d[1]+"!",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler("setData"+d[1]+"!",e),f.data(this,a,c),b.triggerHandler("changeData"+d[1]+"!",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,""),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/\bhover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};
f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!=="click")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+"."+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()
{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test("<"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement("div");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\([^)]*\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\d+(?:px)?$/i,bu=/^-?\d/,bv=/^([\-+])=([\-+.\de]+)/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Left","Right"],by=["Top","Bottom"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bz(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f||0,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\[\]$/,bF=/\r?\n/g,bG=/#.*$/,bH=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\/\//,bM=/\?/,bN=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=["*/"]+["*"];try{bV=e.href}catch(bY){bV=c.createElement("a"),bV.href="",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bN,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,"\r\n")}}):{name:b.name,value:c.replace(bF,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cc(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bG,"").replace(bL,bW[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]==="http:"?80:443))==(bW[3]||(bW[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,"$1_="+x);d.url=y+(y===d.url?(bM.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bX+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join("&").replace(bD,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cd++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cp,cq=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cu("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),o?(f._data(this,"toggle"+i,o==="show"?"hide":"show"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?"":"px"),n!=="px"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]==="-="?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu("show",1),slideUp:cu("hide",1),slideToggle:cu("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,"fxshow"+e.prop)===b&&f._data(e.elem,"fxshow"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(["width","height"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,"padding")):this[d]():null},f.fn["outer"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?"margin":"border")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>matrix2 -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name"><a href="http://example.com/FIXME">matrix2</a></h1><h2 class="project-version">0.1.0-SNAPSHOT</h2><br /><p>To generate summary stats of indicors on stock for a
day, for example, what was the average bps returns on target stock in the past 5 days - what does that mean for tomorrow's trading? Contains some strategy ideas based on entry and exit. The key concept is to generate a 3-D cube of
assets on y axis, agents(strategies) on x and dates on z. Note that when z is collapsed with summaries, we get a asset agent matrix, which can be used to decide what pairs to run tomorrow.
Needs a subscription to active tick
http://www.activetick.com/activetick/contents/</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">clj-http</td><td class="dotted"><hr /></td><td class="dep-version">3.3.0</td></tr><tr><td class="dep-name">enlive</td><td class="dotted"><hr /></td><td class="dep-version">1.1.1</td></tr><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.8.0</td></tr><tr><td class="dep-name">com.ib/jtsclient</td><td class="dotted"><hr /></td><td class="dep-version">9.68</td></tr><tr><td class="dep-name">incanter</td><td class="dotted"><hr /></td><td class="dep-version">1.5.6</td></tr><tr><td class="dep-name">org.clojure/core.async</td><td class="dotted"><hr /></td><td class="dep-version">0.1.346.0-17112a-alpha</td></tr><tr><td class="dep-name">clj-logging-config</td><td class="dotted"><hr /></td><td class="dep-version">1.9.10</td></tr><tr><td class="dep-name">me.raynes/conch</td><td class="dotted"><hr /></td><td class="dep-version">0.8.0</td></tr><tr><td class="dep-name">clojure-watch</td><td class="dotted"><hr /></td><td class="dep-version">LATEST</td></tr><tr><td class="dep-name">com.draines/postal</td><td class="dotted"><hr /></td><td class="dep-version">1.11.3</td></tr><tr><td class="dep-name">me.raynes/fs</td><td class="dotted"><hr /></td><td class="dep-version">1.4.6</td></tr><tr><td class="dep-name">http.async.client</td><td class="dotted"><hr /></td><td class="dep-version">0.5.2</td></tr><tr><td class="dep-name">org.slf4j/slf4j-simple</td><td class="dotted"><hr /></td><td class="dep-version">1.7.2</td></tr><tr><td class="dep-name">clojure-csv/clojure-csv</td><td class="dotted"><hr /></td><td class="dep-version">2.0.1</td></tr><tr><td class="dep-name">http-kit</td><td class="dotted"><hr /></td><td class="dep-version">2.1.18</td></tr><tr><td class="dep-name">org.slf4j/slf4j-simple</td><td class="dotted"><hr /></td><td class="dep-version">1.7.2</td></tr><tr><td class="dep-name">prismofeverything/ring-buffer</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.clojure/data.json</td><td class="dotted"><hr /></td><td class="dep-version">0.2.6</td></tr><tr><td class="dep-name">semantic-csv</td><td class="dotted"><hr /></td><td class="dep-version">0.2.1-alpha1</td></tr><tr><td class="dep-name">tide</td><td class="dotted"><hr /></td><td class="dep-version">0.2.0-20170806.131424-3</td></tr><tr><td class="dep-name">hswick/jutsu</td><td class="dotted"><hr /></td><td class="dep-version">0.1.2</td></tr><tr><td class="dep-name">org.clojure/tools.logging</td><td class="dotted"><hr /></td><td class="dep-version">0.2.3</td></tr><tr><td class="dep-name">clj-logging-config</td><td class="dotted"><hr /></td><td class="dep-version">1.9.10</td></tr><tr><td class="dep-name">clojure-watch</td><td class="dotted"><hr /></td><td class="dep-version">LATEST</td></tr><tr><td class="dep-name">net.mikera/vectorz-clj</td><td class="dotted"><hr /></td><td class="dep-version">0.43.0</td></tr><tr><td class="dep-name">me.raynes/conch</td><td class="dotted"><hr /></td><td class="dep-version">0.8.0</td></tr><tr><td class="dep-name">clj-highcharts</td><td class="dotted"><hr /></td><td class="dep-version">0.1</td></tr><tr><td class="dep-name">org.clojure/tools.cli</td><td class="dotted"><hr /></td><td class="dep-version">0.3.5</td></tr><tr><td class="dep-name">thinktopic/cortex</td><td class="dotted"><hr /></td><td class="dep-version">0.9.22</td></tr><tr><td class="dep-name">org.clojure/math.combinatorics</td><td class="dotted"><hr /></td><td class="dep-version">0.1.4</td></tr><tr><td class="dep-name">clojure-csv</td><td class="dotted"><hr /></td><td class="dep-version">2.0.2</td></tr><tr><td class="dep-name">clj-time</td><td class="dotted"><hr /></td><td class="dep-version">0.14.0</td></tr><tr><td class="dep-name">com.taoensso/timbre</td><td class="dotted"><hr /></td><td class="dep-version">4.10.0</td></tr><tr><td class="dep-name">clojure-term-colors</td><td class="dotted"><hr /></td><td class="dep-version">0.1.0-SNAPSHOT</td></tr><tr><td class="dep-name">org.clojure/tools.nrepl</td><td class="dotted"><hr /></td><td class="dep-version">0.2.12</td></tr><tr><td class="dep-name">bigml/histogram</td><td class="dotted"><hr /></td><td class="dep-version">4.1.3</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#matrix.summary">matrix.summary</a></li><li><a href="#matrix.pnl">matrix.pnl</a></li><li><a href="#matrix.failures">matrix.failures</a></li><li><a href="#matrix.jutsudata">matrix.jutsudata</a></li><li><a href="#matrix.utils">matrix.utils</a></li><li><a href="#matrix.tickers">matrix.tickers</a></li><li><a href="#matrix.data">matrix.data</a></li><li><a href="#matrix.indicators">matrix.indicators</a></li><li><a href="#matrix.neuralnet">matrix.neuralnet</a></li><li><a href="#matrix.train">matrix.train</a></li><li><a href="#matrix.core">matrix.core</a></li><li><a href="#matrix.agents">matrix.agents</a></li><li><a href="#matrix.processdata">matrix.processdata</a></li><li><a href="#matrix.tradinglogic">matrix.tradinglogic</a></li><li><a href="#matrix.trackorders">matrix.trackorders</a></li><li><a href="#matrix.tickers_big">matrix.tickers_big</a></li><li><a href="#matrix.portfolio">matrix.portfolio</a></li><li><a href="#matrix.timekeeper">matrix.timekeeper</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.summary" name="matrix.summary"><h1 class="project-name">matrix.summary</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.summary
  (:use [bigml.histogram.core])
  (:require (bigml.histogram.test [examples :as ex])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def hist (reduce insert! (create) ex/normal-data))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def hist (reduce insert! (create) (identity 1)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def histo (create))
(insert! histo 1.0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(insert! histo 2.0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(insert! histo 3.0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(percentiles hist 0.5 0.95 0.99)</pre></td></tr><tr><td class="docs"><p>(ex/sum-density-chart histo)</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.pnl" name="matrix.pnl"><h1 class="project-name">matrix.pnl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.pnl
  (:require [repltrader.gateway :as g]
            [clojure.term.colors :refer :all])
  ;(:require [matrix.trackorders :as t])
; white, cyan, magenta, blue, yellow, green, red, grey, on-white,
;on-cyan, on-magenta, on-blue, on-yellow, on-green, on-red, on-grey,
;concealed, reverse-color, blink, underline, dark, bold)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce pnl (atom 0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn handle-pnl-update [{:keys [type contract] :as msg}]
  (when  (and (= type :commission-report) (&gt; 1000000 (:realized-profit-loss (:report msg))))
    ;(println msg)
    (println
     (on-blue (green (str &quot;*** IB Pnl Report ****    &quot; (:realized-profit-loss (:report msg))))))
    (swap! pnl + (:realized-profit-loss (:report msg)))
    (println (on-blue (red (str &quot;Running PNL : &quot; @pnl))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (g/subscribe handle-pnl-update))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.failures" name="matrix.failures"><h1 class="project-name">matrix.failures</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.failures)</pre></td></tr><tr><td class="docs"><p>some callback issue doesnt work</p>
</td><td class="codes"><pre class="brush: clojure">(defn sim-strategy-agents [agent-coll ticker-coll date-coll]
  (let [agent-states (map #(create-agent-state % ticker-coll date-coll) agent-coll)
        i-state (create-indicator-state ticker-coll date-coll)]
    (doall (map #(for [this-ticker ticker-coll this-date date-coll]
                   (let [tic (keyword  this-ticker)
                         date (keyword (str this-date))
                         agent-listening-to-this-node  @((% tic) date)]
                     (add-callback-agent false i-state agent-listening-to-this-node tic date))) agent-states)) (doall (for [this-ticker ticker-coll this-date date-coll] (update-data-quotes i-state this-ticker this-date)))
    (map #(zipmap (map keyword ticker-coll) (map (partial retrieve-pnls-tmp % date-coll)  ticker-coll)) agent-states)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pprint (sim-strategy-agents a-list [&quot;TEVA&quot; &quot;MDRX&quot;] [20171117]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.jutsudata" name="matrix.jutsudata"><h1 class="project-name">matrix.jutsudata</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.jutsudata
  (:require [matrix.tickers :as tickers]))</pre></td></tr><tr><td class="docs"><p>jutsu needs a trace id map, to send updates to which trace?? Unf cant
do this by name of trace for now</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def trace-id-map (zipmap (map keyword (map first tickers/portfolio-name-tickers)) (repeatedly (count tickers/portfolio-name-tickers) #(atom {}))))</pre></td></tr><tr><td class="docs"><p>(println trace-id-map)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(swap! trace-id-map assoc-in [:AAPL] 1)
(@trace-id-map :AAPL)</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.utils" name="matrix.utils"><h1 class="project-name">matrix.utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.utils
  (:require
   [clojure.java.io :as io]
   [clojure.string :as str]
   [incanter.zoo :as zoo]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [clj-time.local :as l]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]]
   [matrix.utils :as utils])
  (:gen-class))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn abs [x] (if (&gt; x 0) (identity x) (- x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn formatlocal [n offset]
  (let [nlocal (tt/to-time-zone n (tt/time-zone-for-offset offset))]
    (tf/unparse (tf/formatter-local &quot;yyyy-MM-dd hh:mm:ss aa&quot;)
                nlocal)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn currentTime []
  (formatlocal (tt/now) -4))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn csum [s]
  (take (count s) (reductions + s)))</pre></td></tr><tr><td class="docs"><p>Round a double to the given precision (number of significant digits)</p>
</td><td class="codes"><pre class="brush: clojure">(defn round2
  [precision d]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/round (* d factor)) factor)))</pre></td></tr><tr><td class="docs"><p>Round a double to the given precision (number of significant digits)</p>
</td><td class="codes"><pre class="brush: clojure">(defn round
  [d]
  (round2 2 d))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sign [x]
  (cond (&lt; x 0)   (- 1)
        (&gt; x 0)   (identity 1)
        :else     (identity 0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- read-one
  [r]
  (try
    (read r)
    (catch java.lang.RuntimeException e
      (if (= &quot;EOF while reading&quot; (.getMessage e))
        ::EOF
        (throw e)))))</pre></td></tr><tr><td class="docs"><p>Reads a sequence of top-level objects in file at path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn read-seq-from-file
  [path]
  (with-open [r (java.io.PushbackReader. (clojure.java.io/reader path))]
    (binding [*read-eval* false]
      (doall (take-while #(not= ::EOF %) (repeatedly #(read-one r)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn log-diff [x]
  (let [p (map incanter/log x) out (map - (rest p) (drop-last p))] (identity out)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn diff_ [x] (map - (rest x) (drop-last x)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sign_ [x]
  (if (zero? x) (identity 0) (/ x (stats/scalar-abs x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn correlation_ [x y]
  (let [L (min
           (count x)
           (count y))]
    (stats/correlation (take L x) (take L y))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn signalize [x]
  (cond (&lt;  (stats/scalar-abs x) 0.95)  (identity 0)
        (&gt; x 0.95) (identity 1)
        (&lt; x (- 0.95)) (- 1)))</pre></td></tr><tr><td class="docs"><p>(defn sharpe[x] (/ (stats/mean x) (stats/sd x) ))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sharpe [x]
  (let [m  (stats/mean x)
        s (stats/sd x)]
    (if (zero? s) (identity 0) (round (/ m s)))))</pre></td></tr><tr><td class="docs"><p>sharpe pnl-avg N min max</p>
</td><td class="codes"><pre class="brush: clojure">(defn pnl-sharpe
  [x]
  (let [m  (stats/mean x)
        s (stats/sd x)]
    (if (zero? s) (identity [0 0 0 0 0])
        [(round (/ m s))  m (count x) (apply min x) (apply max x)])))</pre></td></tr><tr><td class="docs"><p>(pnl-sharpe [1 2 3 4 5])</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ema [HL values]
  (cond  (&lt; (count (remove nil? values))  (+ 1 HL)) nil
         :else
         (last (map float (reductions (fn [running v]
                                        (let [f (/ 2 (+ 1 HL))
                                              one-minus-F (- 1 f)] ;naming intermediate results can help with the readability of non-associative operators.
                                          (+ (* f v)
                                             (* one-minus-F running))))
                                      values)))))</pre></td></tr><tr><td class="docs"><p>returns entire seq</p>
</td><td class="codes"><pre class="brush: clojure">(defn ema-all
  [HL values]
  (cond  (&lt; (count (remove nil? values))  (+ 1 HL)) nil
         :else
         (map float (reductions (fn [running v]
                                  (let [f (/ 2 (+ 1 HL))
                                        one-minus-F (- 1 f)] ;naming intermediate results can help with the readability of non-associative operators.
                                    (+ (* f v)
                                       (* one-minus-F running))))
                                values))))</pre></td></tr><tr><td class="docs"><p>(reverse (ema-all 10 (reverse '(1 2 3 4 5 6 7 8 9 10 11 ))))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lPlot2 [one two]
;(incanter/view (charts/line-chart (range 0 (count x)) x))
  (doto (charts/scatter-plot (range (count one)) one)
    (charts/add-lines (range 0 (count two)) two)
    incanter/view))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lPlot3 [one two three]
;(incanter/view (charts/line-chart (range 0 (count x)) x))
  (doto (charts/scatter-plot (range (count one)) one)
    (charts/add-lines (range 0 (count two)) two)
    (charts/add-lines (range 0 (count three)) three)
    incanter/view))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lPlot [x]
  (incanter/view (charts/line-chart (range 0 (count x)) x)))</pre></td></tr><tr><td class="docs"><p>msecs since 9:30</p>
</td><td class="codes"><pre class="brush: clojure">(defn msec
  [tstamp]
  (let [hours
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 8)
            (nth (str/split tstamp #&quot;&quot;) 9)))
        minutes
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 10)
            (nth (str/split tstamp #&quot;&quot;) 11)))
        seconds
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 12)
            (nth (str/split tstamp #&quot;&quot;) 13)))
        mseconds
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 14)
            (nth (str/split tstamp #&quot;&quot;) 15)
            (nth (str/split tstamp #&quot;&quot;) 16)))]
  ;(identity mseconds)
    (int (+ mseconds (int (* 1000 (reduce + [(* 3600 (- hours 9)) (* 60 minutes) seconds])))))))</pre></td></tr><tr><td class="docs"><p>actual time of the time stamp in AT</p>
</td><td class="codes"><pre class="brush: clojure">(defn tradingTime
  [tstamp]
  (let [hours
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 8)
            (nth (str/split tstamp #&quot;&quot;) 9)))
        minutes
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 10)
            (nth (str/split tstamp #&quot;&quot;) 11)))
        seconds
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 12)
            (nth (str/split tstamp #&quot;&quot;) 13)))
        mseconds
        (. Integer parseInt
           (str
            (nth (str/split tstamp #&quot;&quot;) 14)
            (nth (str/split tstamp #&quot;&quot;) 15)
            (nth (str/split tstamp #&quot;&quot;) 16)))]
    (str/join &quot; &quot; [hours minutes seconds])
  ;(int (+ mseconds (int (* 1000 (reduce + [(* 3600 (- hours 9)) (* 60 minutes) seconds]) ))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn zscore [coll]
  &quot;divide series by its own sd&quot;
  (if (nil? coll) (identity nil) (let  [m (stats/mean coll)
                                        s (stats/sd coll)
                                        s-clean (cond (zero? s) (identity nil) :else (identity s))
                                        normalized (map #(/ (- % m) s-clean) coll)] (map (partial round2 2) normalized))))</pre></td></tr><tr><td class="docs"><p>(conj [1 2] '())</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(println (filter #(&lt; % (- 3)) (zscore rets)))</p>
</td><td class="codes"><pre class="brush: clojure">(use 'clojure.data)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn winsorize [K coll]
  &quot;winsorize at K sigma&quot;
  (if (nil? coll) (identity nil)
      (if (nil? (zscore coll))  (identity nil)
          (let [z (zscore coll)
                s (stats/sd coll)
                m (stats/mean coll)
                original  (map vector (range (count z)) z)
                bigs (filter #(&gt; (abs (second %)) K) original)
                result (cond (empty? bigs) (identity coll)
                             :else (let [bigs-complement (filter #(not (&gt; (abs (second %)) K)) original)
          ;;replace second element with 3 sigma
                                         bigs-mod (if (not (empty? bigs))  (map #(assoc % 1 (* 3 (sign (second %)))) bigs))
                                         new-zscore (sort-by first (remove nil? (concat bigs-mod bigs-complement)))
                                         reconstructed (map (partial round2 2)  (map #(+ (* (second %)  s) m) new-zscore))] (identity reconstructed)))] (identity result)))))</pre></td></tr><tr><td class="docs"><p>test for winsorize</p>
</td><td class="codes"><pre class="brush: clojure">(comment (def rets (let [aticker &quot;BBBY&quot;
                         tech (ohlcv aticker)
                         p (:c tech)
                         rets (cond (&gt; (count p) 1) (map return_bps (rest p)  (drop-last p))
                                    :else (vector Double/NaN))]
                     (if (Double/isNaN (first rets)) (identity 0) (let [adj-price (u/csum rets)]
                                                                    (identity rets)))))
         (println (winsorize 2 rets))
         (u/lPlot2 (u/csum rets)  (u/csum (winsorize 2 rets)))) (defn normalize [coll]</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">         (u/lPlot2 (u/csum rets)  (u/csum (winsorize 2 rets)))) (defn normalize [coll]
                                                                  &quot;divide series by its own sd&quot;
                                                                  (if (nil? coll) (identity nil) (let  [s (stats/sd coll)
                                                                                                        s-clean (cond (zero? s) (identity Double/NaN) :else (identity s))
                                                                                                        normalized (map #(/ % s) coll)] (identity normalized))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn return_bps [x y]
  (if (or (nil? x) (nil? y) (zero? y)) (identity 0)
      (round2 2 (* 10000 (/ (- x y) y)))))</pre></td></tr><tr><td class="docs"><p>y is reference</p>
</td><td class="codes"><pre class="brush: clojure">(defn return-bps
  [x y]
  (if (or (nil? x) (nil? y) (zero? y)) (identity 0)
      (round2 2 (* 10000 (/ (- x y) y)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn return-bps-col [col]
  (cond (not= (count col) 2)  nil :else
        (let [x (second col)
              y (first col)]
          (if (or (nil? x) (nil? y) (zero? y)) (identity 0)
              (round2 2 (* 10000 (/ (- x y) y)))))))</pre></td></tr><tr><td class="docs"><p>more forgiving sd</p>
</td><td class="codes"><pre class="brush: clojure">(defn sd
  [coll]
  (round2 2 (stats/sd coll)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sanitize [word] (apply str (filter (fn [x] (Character/isLetter x)) word)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn random-word [] (sanitize (rand-nth (str/split (slurp &quot;/usr/share/dict/words&quot;) #&quot;\n&quot;))))</pre></td></tr><tr><td class="docs"><p>(repeatedly 100 #(random-word ))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>write coll to string with new line</p>
</td><td class="codes"><pre class="brush: clojure">(defn coll-&gt;string
  [coll] (str (str/join &quot;,&quot; coll) &quot;\n&quot;))</pre></td></tr><tr><td class="docs"><p>if x in bps cutoff at 10000 bps, 100% return</p>
</td><td class="codes"><pre class="brush: clojure">(defn winsorize-returns
  [x]
  (cond  (&gt; (incanter/abs x) 10000)
         (* (sign x) 10000) :else x))</pre></td></tr><tr><td class="docs"><p>if x [ 1 2 3] inc in time, lag 1 x is [NaN 1 2]</p>
</td><td class="codes"><pre class="brush: clojure">(defn lag
  [n x]
  (let [N (apply min [n (count x)])
        pad (repeat N Double/NaN)]
    (concat pad (drop-last n x))))</pre></td></tr><tr><td class="docs"><p>(lag 1 [1 2 3])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>if x [ 1 2 3] inc in time, lookahead 1 x is [2 3 NaN]</p>
</td><td class="codes"><pre class="brush: clojure">(defn lookahead
  [n x]
  (let [N (apply min [n (count x)])
        pad (repeat N Double/NaN)]
    (concat (drop n x) pad)))</pre></td></tr><tr><td class="docs"><p>(lookahead 10 [1 2 3 4 5 6])</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn yyyymmdd-&gt;epoch [date] (.getMillis (tt/date-time (. Integer parseInt (subs (str date) 0 4))
                                                       (. Integer parseInt (subs (str date) 4 6))
                                                       (. Integer parseInt (subs (str date) 6 8)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn view-indicator [indicator-map]
  (let [dates (map yyyymmdd-&gt;epoch (:dates indicator-map))
        data (:data indicator-map)]
    (incanter/view (charts/time-series-plot dates data
                                            :x-label &quot;Year&quot;))))</pre></td></tr><tr><td class="docs"><p>write coll to string with new line</p>
</td><td class="codes"><pre class="brush: clojure">(defn coll-&gt;string
  [coll] (str (str/join &quot;,&quot; coll) &quot;\n&quot;))</pre></td></tr><tr><td class="docs"><p>write coll to string with new line</p>
</td><td class="codes"><pre class="brush: clojure">(defn coll-&gt;string2
  [coll] (str (str/join &quot; &quot; coll) &quot;\n&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def HOME (. System getProperty &quot;user.home&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn notnan? [x]
  (cond (string? x) true :else
        (not
         (Double/isNaN x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn zscore2 [x coll]
  ;; if anything in x coll is nan then nan
  ;; if coll sd is 0 then nan
  ;; limit at +3 and -3
  (let [m (stats/mean coll)
        s (stats/sd coll)
        out (cond (zero? s) 0.0 :else (round2 2 (/ (- x m) s)))]
    out))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn drawdown-at-pnl [pnl]
  (cond
    (&lt;= pnl 40.0) Double/NaN  ;; dont take profit here yet
    ;;changed my mind, need to cut loss aggreessively
 ;(&lt;= pnl 50) 50  ;; cut your losers at 50 bucks
    (or (nil? pnl) (Double/isNaN pnl)) Double/NaN
    ;(and (&gt; pnl 10.0) (&lt;= pnl 20.0) )  5.0
    ;(and (&gt; pnl 20.0) (&lt;= pnl 40.0) )  10.0
    (and (&gt; pnl 40.0) (&lt;= pnl 50.0))  15.0
    (and (&gt; pnl 50.0) (&lt;= pnl 100.0))  25.0
    (and (&gt; pnl 100.0) (&lt;= pnl 150.0))  25.0
    (and (&gt; pnl 150.0) (&lt;= pnl 200.0))  25.0
    (and (&gt; pnl 250.0) (&lt;= pnl 300.0))  35.0
    (and (&gt; pnl 350.0) (&lt;= pnl 400.0))  35.0
    (and (&gt; pnl 450.0) (&lt;= pnl 500.0))  45.0
    :else 15.0))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.tickers" name="matrix.tickers"><h1 class="project-name">matrix.tickers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.tickers
  (:require
   [matrix.utils :as u]
   [net.cgrand.enlive-html :as enlive]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.data.json :as json]
   [incanter.zoo :as zoo]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [clj-time.predicates :as pr]
   [clj-time.local :as l]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clj-http.client :as client]
                                        ;  [structure.ring-buffer :as rb]
                                        ;  [postal.core :as postal]
   [clojure.core.async
    :as a
    :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
            alts! alts!! timeout]]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]]
   [me.raynes.conch :refer [programs with-programs let-programs] :as sh] [matrix.utils :as utils]) (:use clojure.pprint)
  ;(:use [clj-highcharts.core])
  (:gen-class))</pre></td></tr><tr><td class="docs"><p> use the above urls to retrieve ticker list for nyse and nasdaq, cutoff at certain points</p>

<p>initialize nasdaq and nyse ticker, our trading universe</p>
</td><td class="codes"><pre class="brush: clojure">(do (def HOME u/HOME)
    (def mc-cutoff 1E7)
    (def price-cutoff 20)
    (def adv-cutoff-millions 10)
    (def urls [&quot;https://www.nasdaq.com/screening/companies-by-industry.aspx?exchange=NASDAQ&amp;render=download&quot; &quot;https://www.nasdaq.com/screening/companies-by-industry.aspx?exchange=NYSE&amp;render=download&quot;])
    (defn retrieve-symbols
      [mc-cutoff price-cutoff adv-cutoff-millions url] (let [data (io2/read-dataset url :header true)
                                                             nasdaq (incanter/to-dataset data)
                                                             symbols (incanter$/$ :Symbol nasdaq)
                                                             name_ (incanter$/$ :Name nasdaq)
                                                             lastsale (incanter$/$ :LastSale nasdaq)
                                                             market-cap (incanter$/$ :MarketCap nasdaq)
                                                             sector (incanter$/$ :Sector nasdaq)
                                                             industry (incanter$/$ :Industry nasdaq)
                                                             filter-data0 (map vector symbols name_ lastsale market-cap sector industry)
                                                             filter-data1 (filter #(number? (nth % 2)) filter-data0)
                                                             filter-data2-nasdaq (filter #(and (&gt;= (nth % 2) price-cutoff) (&gt;= (nth % 3) mc-cutoff)) filter-data1)]
                                                         filter-data2-nasdaq))
    (def nasdaq-data (retrieve-symbols mc-cutoff price-cutoff adv-cutoff-millions (first urls)))
    (def nyse-data (retrieve-symbols mc-cutoff price-cutoff adv-cutoff-millions (second urls)))
    (def tickers (set (concat (map first nyse-data)  (map first nasdaq-data))))
    (count tickers)
    (def huge-tickers (concat [&quot;SPY&quot;]  tickers))
    (def stock-names-nyse (zipmap (map first nyse-data)  (map second nyse-data)))
    (def stock-names-nasdaq (zipmap (map first nasdaq-data)  (map second nasdaq-data)))
    (def stock-names (merge stock-names-nyse stock-names-nasdaq))
    (count stock-names))</pre></td></tr><tr><td class="docs"><p>(contains? (set huge-tickers) "SPY")
(pprint (take 10 huge-tickers))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>functions around date decision</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do (defn formatlocal [n offset]
      (let [nlocal (tt/to-time-zone n (tt/time-zone-for-offset offset))]
        (tf/unparse (tf/formatter-local &quot;yyyy-MM-dd hh:mm:ss aa&quot;)
                    nlocal)))
    (defn currentTime []
      (formatlocal (tt/now) -5))
    (defn pad_ [x] (if (= 2 (count (str x))) (identity x) (str &quot;0&quot; x)))
    (defn convert_ [date]
      (str
       (tt/year date)
       (pad_ (tt/month date))
       (pad_ (tt/day date))))
    (defn convert-javatime-to-yyyymmdd [datetime]
      (tt/date-time (read-string (subs datetime
                                       0 4)) (. Integer parseInt (subs datetime 5 7)) (. Integer parseInt (subs datetime 8 10))))
    (def tt_date_  (tt/date-time (read-string (subs (currentTime) 0 4)) (. Integer parseInt (subs (currentTime) 5 7)) (. Integer parseInt (subs (currentTime) 8 10))))
;;asofdata logic
                                        ;(def tt_date_ (tt/date-time 2017 6 4 )  )
    (currentTime)
    (println &quot;today is..&quot;)
    (println tt_date_)
    (identity tt_date_)
    (def tt_date_1 (tt/minus tt_date_ (tt/days 1)))
    (def tt_date_2 (tt/minus tt_date_ (tt/days 2)))
    (def tt_date_3 (tt/minus tt_date_ (tt/days 3)))
    (def tt_date_4 (tt/minus tt_date_ (tt/days 4)))
    (def tt_date_5 (tt/minus tt_date_ (tt/days 5)))
    (def tt_date_14 (tt/minus tt_date_ (tt/days 14)))
    (def tt_date_5 (tt/minus tt_date_ (tt/days 5)))
    (def tt_date_30 (tt/minus tt_date_ (tt/days 30)))
    (def tt_date_96 (tt/minus tt_date_ (tt/days 96)))
    (def tt_date_360 (tt/minus tt_date_ (tt/days 360)))
    (def startDate (convert_ tt_date_14))
    (identity startDate)
;; does all logic of weekend adjusting
    (def today_
      (cond (pr/saturday? tt_date_) (identity  (str
                                                (tt/year tt_date_1)
                                                (pad_ (tt/month tt_date_1))
                                                (pad_ (tt/day tt_date_1))))
            (pr/sunday? tt_date_) (identity  (str
                                              (tt/year tt_date_2)
                                              (pad_ (tt/month tt_date_2))
                                              (pad_ (tt/day tt_date_2))))
            :else (convert_ tt_date_)))
    (identity today_)
    (def today_int (atom (read-string today_)))
;(def today_int 20170928)
                                        ;(identity yesterday_)
    (def yesterday_
  ;; if saturday this is t-2
  ;; if sunday this t-3
  ;; else t-1
      (cond (pr/saturday? tt_date_) (identity  (str
                                                (tt/year tt_date_2)
                                                (pad_ (tt/month tt_date_2))
                                                (pad_ (tt/day tt_date_2))))
            (pr/sunday? tt_date_) (identity  (str
                                              (tt/year tt_date_3)
                                              (pad_ (tt/month tt_date_3))
                                              (pad_ (tt/day tt_date_3))))
            (pr/monday? tt_date_) (identity  (str
                                              (tt/year tt_date_3)
                                              (pad_ (tt/month tt_date_3))
                                              (pad_ (tt/day tt_date_3))))
            :else (convert_ tt_date_1)))
;;;;;;; functions around date decision
;; find advs
    (defn dailyBars
      [date1 date2 tic]
      (let [tail (str &quot;&amp;historyType=1&amp;beginTime=&quot; date1 &quot;093000&quot; &quot;&amp;endTime=&quot; date2 &quot;160000&quot;)]
        (:body (client/get (str &quot;http://localhost:5000/barData?symbol=&quot; tic tail)))))
    (defn getBars2
      [tic date minutes]
      (let [tail (str &quot;&amp;historyType=0&amp;intradayMinutes=&quot; minutes &quot;&amp;beginTime=&quot; date &quot;093000&quot; &quot;&amp;endTime=&quot; date &quot;160000&quot;)]
        (:body (client/get (str &quot;http://localhost:5000/barData?symbol=&quot; tic tail)))))
    (defn getReturns2
      [date minutes tic]
      (let
       [data1 (getBars2 tic date minutes)
        data2 (map #(str/split % #&quot;,&quot;) (str/split data1  #&quot;\r\n&quot;))
        price (map read-string (map #(nth % 4) data2))
        logprice (map incanter/log price)
        returns  (map int (map #(* % 10000) (map - (rest logprice) (drop-last logprice))))] (identity returns)))
                                        ;(def startDate (convert_ tt_date_30 ))
                                        ;(identity startDate)
    (defn getPrices2
      [tic date minutes]
      (let
       [data1 (getBars2 tic date minutes)
        data2 (map #(str/split % #&quot;,&quot;) (str/split data1  #&quot;\r\n&quot;))
        price (map read-string (map #(nth % 4) data2))
        logprice (map incanter/log price)
        returns  (map int (map #(* % 10000) (map - (rest logprice) (drop-last logprice))))] (identity price)))
    (def apple-data (clojure.string/split (dailyBars startDate today_ &quot;AAPL&quot;) #&quot;\r\n&quot;))
    (def N (count apple-data))
;(identity N)
;;;find advs
    (defn ohlcv-dumb [tic]
      (let [apple-data (clojure.string/split (dailyBars startDate today_ tic) #&quot;\r\n&quot;)
            N-local (count apple-data)
            data (map #(clojure.string/split % #&quot;,&quot;) apple-data)
            close-price (map read-string (map  #(nth % 4) data))
            open-price  (map read-string (map #(nth % 1) data))
            high-price  (map read-string (map  #(nth % 2) data))
            low-price  (map read-string (map  #(nth % 3) data))
            volumes  (map read-string (map  #(nth % 5) data))
            avg-price (stats/mean close-price)
            stock-type (cond (&lt;= avg-price 15) &quot;small&quot;
                             (&gt;= avg-price 90) &quot;large&quot;
                             :else &quot;mid&quot;)
            adv-in-millions (u/round2 2 (/ (stats/mean (map * volumes close-price)) 1E6))
            d [0]  ;; dummy data
            good-data {:aprice avg-price :type stock-type :aticker tic :status &quot;Active&quot; :o open-price :c close-price :h high-price :l low-price :v volumes :adv adv-in-millions}
            bad-data {:aprice 100 :type stock-type :aticker tic :status &quot;Inactive&quot; :o d :c d :h d :l d :v d :adv 0}] (if (&lt; N-local N) (identity bad-data) (identity good-data))))
    (defn ohlcv-dumb2 [tic]
      (let [apple-data (clojure.string/split (dailyBars startDate today_ tic) #&quot;\r\n&quot;)
            N-local (count apple-data)
            data (map #(clojure.string/split % #&quot;,&quot;) apple-data)
            close-price (map read-string (map  #(nth % 4) data))
            dates-long (map read-string (map  #(nth % 0) data))
            dates (map #(/ % 1000000) dates-long)
            open-price  (map read-string (map #(nth % 1) data))
            high-price  (map read-string (map  #(nth % 2) data))
            low-price  (map read-string (map  #(nth % 3) data))
            volumes  (map read-string (map  #(nth % 5) data))
            avg-price (stats/mean close-price)
            stock-type (cond (&lt;= avg-price 15) &quot;small&quot;
                             (&gt;= avg-price 90) &quot;large&quot;
                             :else &quot;mid&quot;)
            adv-in-millions (u/round2 2 (/ (stats/mean (map * volumes close-price)) 1E6))
            d [0]  ;; dummy data
            good-data {:aprice avg-price :type stock-type :aticker tic :status &quot;Active&quot; :o open-price :c close-price :h high-price :l low-price :v volumes :adv adv-in-millions :dates dates}] (if (&lt; N-local N) (identity nil) (identity good-data))))
                                        ;(map #(take 10 (second %)) (ohlcv-dumb2 &quot;TSLA&quot;))
                                        ;(map class (map second (ohlcv-dumb2 &quot;TSLA&quot;)))
    (def ohlcv (clojure.core/memoize ohlcv-dumb2))
    (defn recent-dates []
      (:dates (ohlcv &quot;AAPL&quot;)))
    (defn ohlcv-date [date tic]
      (let [data  (ohlcv tic)
            out-data (cond (nil? data) (identity nil)
                           :else
                           (let [close-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:c data))))
                                 open-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:o data))))
                                 high-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:h data))))
                                 low-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:l data))))
                                 volumes (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:v data))))
                                 adv-in-millions (u/round2 2 (/ (stats/mean (map * volumes close-price)) 1E6))
                                 dates (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:dates data))))
                                 avg-price (stats/mean close-price)]
                             {:aprice avg-price :type (:stock-type data) :aticker tic :status &quot;Active&quot; :o open-price :c close-price :h high-price :l low-price :v volumes :adv adv-in-millions :dates dates}))]
        (identity out-data))));;end do</pre></td></tr><tr><td class="docs"><p>end do</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>finished tracking all eligible tickers for trading, now see earnings page.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ema [HL values]
  (reductions (fn [running v]
                (let [f (/ 2 (+ 1 HL))
                      one-minus-F (- 1 f)] ;naming intermediate results can help with the readability of non-associative operators.
                  (+ (* f v)
                     (* one-minus-F running))))
              values))</pre></td></tr><tr><td class="docs"><p>(def ohlcv-data (map ohlcv (take 10 (concat (map first filter-data2-nyse)  (map first filter-data2-nasdaq)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>being rank indicators</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>simple trend using return series
indicators are maps with header and dates
data is always adapted, ie data with 20160729 is avl start of 20170729</p>
</td><td class="codes"><pre class="brush: clojure">(defn trend
  [fast slow aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [p (:c tech)
                                        dates (rest (:dates tech))
                                        rets  (map u/return_bps (rest p)  (drop-last p))
                                        adj-price (u/csum (u/winsorize 2 rets))
                                        trend (map - (ema fast adj-price) (ema slow adj-price))]
                ;(count dates)
                                    {:data (utils/lag 1  (map (partial u/round2 2)  trend))
                                     :dates dates
                                     :header &quot;trend&quot;}))))</pre></td></tr><tr><td class="docs"><p>simple trend using return series
indicators are maps with header and dates
live indicators are to be used for intraday ranking
ie what is the top price-open stock now?</p>
</td><td class="codes"><pre class="brush: clojure">(defn simple-trend-live
  [slow aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [p (:c tech)
                                        dates (rest (:dates tech))
                                        ema-p (ema slow p)
                                        rets  (map u/return_bps p  ema-p)]
                ;(count dates)
                                    {;:data (map (partial u/round2 2)  trend)
                                     :data ema-p
                                     :dates dates
                                     :header &quot;trend&quot;}))))</pre></td></tr><tr><td class="docs"><p>now minus yesterdays close
indicators are maps with header and dates
live indicators are to be used for intraday ranking
ie what is the top price-open stock now?</p>
</td><td class="codes"><pre class="brush: clojure">(defn movement-live
  [aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [p (:c tech)
                                        dates (:dates tech)
                                        lag-p (u/lag 1 p)
                                        rets  (map u/return_bps p  lag-p)]
                ;(count dates)
                                    {;:data (map (partial u/round2 2)  trend)
                                     :data rets
                                     :dates dates
                                     :header &quot;trend&quot;}))))</pre></td></tr><tr><td class="docs"><p>now minus yesterdays close
indicators are maps with header and dates
live indicators are to be used for intraday ranking
ie what is the top price-open stock now?</p>
</td><td class="codes"><pre class="brush: clojure">(defn intraday-movement-live
  [aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [c (:c tech)
                                        o (:o tech)
                                        dates (:dates tech) rets  (map u/return_bps c o)]
                ;(count dates)
                                    {;:data (map (partial u/round2 2)  trend)
                                     :data rets
                                     :dates dates
                                     :header &quot;intraday-movement-live&quot;}))))</pre></td></tr><tr><td class="docs"><p>(u/view-indicator (movement-live "MTW"))
(ohlcv "MTW")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>intraday trend - ignore moves across days</p>
</td><td class="codes"><pre class="brush: clojure">(defn trend2
  [fast slow aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [c (:c tech)
                                        o (:o tech)
                                        rets  (map u/return_bps c o)
                                        adj-price (u/csum (u/winsorize 2 rets))
                                        trend (map - (ema fast adj-price) (ema slow adj-price))] (map (partial u/round2 2)  trend)))))</pre></td></tr><tr><td class="docs"><p>(identity (trend 1 3 "EGBN"))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn getBars2
  [tic date minutes]
  (let [tail (str &quot;&amp;historyType=0&amp;intradayMinutes=&quot; minutes &quot;&amp;beginTime=&quot; date &quot;093000&quot; &quot;&amp;endTime=&quot; date &quot;160000&quot;)
        data (:body (client/get (str &quot;http://localhost:5000/barData?symbol=&quot; tic tail)))
        test (first (first (map #(str/split % #&quot;,&quot;) (str/split data  #&quot;\r\n&quot;))))
        answer (cond (= &quot;00000000000000&quot; test) (identity nil) :else (identity data))]
    (identity answer)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-close [aticker]
  &quot;which ones broke today?&quot;
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [c (:c tech)]
                ;(last (drop-last c))
                                    (last c)))))</pre></td></tr><tr><td class="docs"><p>(last-close "AAPL")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn returns-from-yesterday [date yesterday_ minutes tic]
  (let
   [data1 (getBars2 tic date minutes)
    lc    (last-close tic)
    return-from-yesterday (cond (or (zero? lc) (nil? lc) (nil? data1)) (identity nil)
                                :else
                                (let [data2 (map #(str/split % #&quot;,&quot;) (str/split data1  #&quot;\r\n&quot;))
                                      price (map read-string (map #(nth % 4) data2))
                                      logprice (map incanter/log price)
   ;;; now see if last days close to now is actually significant
                                      return (- (last logprice) (incanter/log lc))] (u/round2 4 return)
;(identity data1)))]
    (identity return-from-yesterday)))</pre></td></tr><tr><td class="docs"><p>(returns-from-yesterday today_ yesterday_ 1 "DBD")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(last-close "AAPL")
(getBars2 "AAPL" today_ 1)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(trend 8 16 "JNJ")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(conj [1 2] '())</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(println (filter #(&lt; % (- 3)) (zscore rets)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>test for winsorize</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ATR-bps [aticker]
  &quot;coll of ATR numbers&quot;
  (let  [tech (ohlcv aticker)
         h (cond (nil? tech) nil :else
                 (:h tech))
         l (cond (nil? tech) nil :else
                 (:l tech))
         c (cond (nil? tech) nil :else
                 (:c tech))]
    (if (nil? h)
      (identity nil)
      (let [hl (rest (map incanter/abs (map u/return_bps h l)))
            first-day-atr (first (map incanter/abs (map u/return_bps h l)))
            hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
            lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))]
        (map u/winsorize-returns (conj (map #(apply max %) (map vector hl hc lc))  first-day-atr))
;(identity tech)))))</pre></td></tr><tr><td class="docs"><p>(conj (ATR-bps "AAPL") -99 )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn close-open-bps [aticker]
  &quot;coll of close minus open in bps&quot;
  (let  [tech (ohlcv aticker)
         o (cond (nil? tech) nil :else
                 (:o tech))
         c (cond (nil? tech) nil :else
                 (:c tech))]
    (if (nil? o)
      nil (map u/winsorize-returns (map incanter/abs (map u/return_bps c o))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn volume-change-bps [aticker]
  &quot;coll of&quot;
  (let  [tech (ohlcv aticker)
         v (cond (nil? tech) nil :else
                 (:v tech))
         lag-v (utils/lag 1 v)]
    (if (nil? v)
      nil (map u/winsorize-returns (map incanter/abs (map u/return_bps v lag-v))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ATR-bps-show [date aticker]
  &quot;coll of ATR numbers&quot;
  (let  [tech (ohlcv-date date aticker)
         h (cond (nil? tech) nil :else
                 (:h tech))
         l (cond (nil? tech) nil :else
                 (:l tech))
         c (cond (nil? tech) nil :else
                 (:c tech))]
    (if (nil? h)
      (identity nil)
      (let [hl (rest (map incanter/abs (map u/return_bps h l)))
            hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
            lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))]
        (map vector hl hc lc)
;(identity tech)))))</pre></td></tr><tr><td class="docs"><p>which atr dropped the most yesterday, lets assume that goes back up</p>
</td><td class="codes"><pre class="brush: clojure">(defn ATR-bps-T1
  ([date aticker]
   (let  [tech (ohlcv-date date  aticker)
          h (cond (nil? tech) nil :else
                  (:h tech))
          l (cond (nil? tech) nil :else
                  (:l tech))
          c (cond (nil? tech) nil :else
                  (:c tech))]
     (if (nil? h)
       (identity nil)
       (let [hl (rest (map incanter/abs (map u/return_bps h l)))
             hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
             lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))
             ATR (map #(apply max %) (map vector hl hc lc))]
         (u/round2 0 (- (last ATR) (last (drop-last ATR))))))))
  ([aticker]
   (let  [tech (ohlcv aticker)
          h (cond (nil? tech) nil :else
                  (:h tech))
          l (cond (nil? tech) nil :else
                  (:l tech))
          c (cond (nil? tech) nil :else
                  (:c tech))]
     (if (nil? h)
       (identity nil)
       (let [hl (rest (map incanter/abs (map u/return_bps h l)))
             hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
             lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))
             ATR (map #(apply max %) (map vector hl hc lc))]
         (u/round2 0 (- (last ATR) (last (drop-last ATR))))
        ;; this should be negative for turbulent stocks that have stabilized)))))</pre></td></tr><tr><td class="docs"><p>(ATR-bps-oc 1 "ZGNX")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(u/lPlot2 (ATR-bps "IBTX")  (ATR-bps "IBTX")  )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stdev-adj-trend [fast slow aticker]
  (let  [tech (ohlcv aticker)
         s (cond (nil? tech) nil :else
                 (stats/sd (:c (ohlcv aticker))))] (if (or (nil? s) (zero? s)) (identity nil) (map #(/ % s) (trend fast slow aticker)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stdev-adj-trend2 [fast slow aticker]
  (let  [tech (ohlcv aticker)
         s (cond (nil? tech) nil :else
                 (stats/sd (:c (ohlcv aticker))))] (if (or (nil? s) (zero? s)) (identity nil) (map #(/ % s) (trend2 fast slow aticker)))))</pre></td></tr><tr><td class="docs"><p>(ATR-bps-oc "EDIT")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(normalize (stdev-adj-trend 8 24 "SYT"))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(reverse nil)</p>
</td><td class="codes"><pre class="brush: clojure">(defn consolidated-trend [aticker]
  (let [sum-of-trends (map + (reverse (u/normalize (stdev-adj-trend 8 24 aticker)))
                           (reverse (u/normalize (stdev-adj-trend 16 48 aticker)))
                           (reverse (u/normalize (stdev-adj-trend 32 96 aticker))))]
    (if (empty? sum-of-trends) (identity nil) (map (partial u/round2 0)  (reverse sum-of-trends)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn consolidated-trend2 [aticker]
  &quot;intraday&quot;
  (let [sum-of-trends (map + (reverse (u/normalize (stdev-adj-trend2 8 24 aticker)))
                           (reverse (u/normalize (stdev-adj-trend2 16 48 aticker)))
                           (reverse (u/normalize (stdev-adj-trend2 32 96 aticker))))]
    (if (empty? sum-of-trends) (identity nil) (map (partial u/round2 0)  (reverse sum-of-trends)))))</pre></td></tr><tr><td class="docs"><p>(consolidated-trend "BAOA")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prices-ema [days aticker]
  (let [tech (ohlcv aticker)]
    (ema days (:c tech))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prices [aticker]
  (let [tech (ohlcv aticker)]
    (:c tech)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ema-slope [days aticker]
  (let [tech (ohlcv aticker)
        EMA     (ema days (:c tech))]
    (u/sign (stats/median (map - (rest EMA) (drop-last EMA))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn view-prices [aticker]
  (u/lPlot3 (prices-ema 14 aticker)  (prices-ema 7 aticker)  (prices aticker)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn current-price [aticker]
  &quot;tell me close price tom based on recent n day slope&quot;
  (let [tech (ohlcv aticker)]
    (last (:c tech))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn forecast-slope [days aticker]
  &quot;tell me close price tom based on recent n day slope&quot;
  (let [tech (ohlcv aticker)
        EMA     (ema days (:c tech))]
    (+ (last EMA) (last (map - (rest EMA) (drop-last EMA))))))</pre></td></tr><tr><td class="docs"><p>(trend 14 "RH")
(ema-slope 14 "RH")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(view-prices "TSLA")
(forecast-slope 14 "TSLA")
(current-price "TSLA")</p>
</td><td class="codes"><pre class="brush: clojure">(defn intraday [aticker] (let [data (ohlcv aticker)
                               returns (u/round2 2 (/ (last (map - (:c data) (:o data))) (:aprice data)))]
                           (identity returns)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ten-day-stdev [aticker] (let [data (ohlcv aticker)
                                    stdev (u/round2 2 (stats/sd (take-last 10 (:c data))))]
                                (identity stdev)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn intraday-movement [aticker] (let [data (ohlcv aticker)
                                        avg-move (u/round2 2 (stats/mean (map u/abs (map - (:c data) (:o data)))))]
                                    (identity avg-move)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-tails [k col]
  (clojure.pprint/pprint (take k col))
  (clojure.pprint/pprint (take-last k col)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn take-tails [k col]
  (concat (take k col)  (take-last k col)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def adv-map (map vector tickers (map :adv (map ohlcv tickers))))</pre></td></tr><tr><td class="docs"><p>(print-tails (sort-by second adv-map))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (def ticlist (map first (filter #(&gt; (second %) adv-cutoff-millions) adv-map)))
  (spit  (str  HOME &quot;/data/ticlist.pickle&quot;) (pr-str ticlist)))</pre></td></tr><tr><td class="docs"><p>(def ticlist (read-string (slurp  (str  HOME "/data/ticlist.pickle" ) )))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def intraday-returns (map vector ticlist        (map intraday ticlist       )))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(ohlcv "VWR")
(print-tails (sort-by second intraday-returns))
(def old-one (sort-by second intraday-returns))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(print-tails (sort-by second adv-map))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(filter #(contains? (set liquid-tickers) (first %) )   )</p>
</td><td class="codes"><pre class="brush: clojure">(def mid-tickers (map :aticker (filter #(= &quot;mid&quot; (:type %)) (map ohlcv tickers))))</pre></td></tr><tr><td class="docs"><p>(def small-tickers (map :aticker (filter #(= "small" (:type %)) (map ohlcv tickers))))</p>
</td><td class="codes"><pre class="brush: clojure">(def large-tickers (map :aticker (filter #(= &quot;large&quot; (:type %)) (map ohlcv tickers))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def small-tickers (map :aticker (filter #(= &quot;small&quot; (:type %)) (map ohlcv tickers))))</pre></td></tr><tr><td class="docs"><p>(take 10 large-tickers)
(def ten-day-stdev-map (map vector mid-tickers (map ten-day-stdev mid-tickers)))
(print-tails 20 (sort-by second ten-day-stdev-map))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>good ticker logic</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def mc-cutoff 1000E6)
(def price-cutoff 10.0)
(def price-cutoff-hi 120.0)
(def adv-cutoff-millions 20.0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn good-ticker? [aticker]
  (let [this-data (ohlcv aticker)
        result (cond (nil? this-data) (identity false)
                     :else
                     (let [this-status (:status this-data)
                           this-adv (:adv this-data)
                           this-name (stock-names aticker)
                           this-close (last (:c this-data))]
                       (if (or  (zero? this-close)
                                ;(nil? this-name)
                                (not= &quot;Active&quot; this-status) (or (zero? this-adv) (nil? this-adv))
                                (&lt; this-adv adv-cutoff-millions)
                                (&lt; this-close price-cutoff)
                                (&gt;= this-close price-cutoff-hi))
                         (identity false) (identity true))))]
    (identity result)))</pre></td></tr><tr><td class="docs"><p>(/ (stats/mean (:v (ohlcv )) ) 390000)
(stock-names "AZPN")
(good-ticker? "BR")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames-mid (filter good-ticker? mid-tickers))</pre></td></tr><tr><td class="docs"><p>(count clean-ticnames-mid)</p>
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames-large (filter good-ticker? large-tickers))</pre></td></tr><tr><td class="docs"><p>(count clean-ticnames-large)</p>
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames-small (filter good-ticker? small-tickers))</pre></td></tr><tr><td class="docs"><p>(count clean-ticnames-small)
(println small-tickers)</p>
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames (concat clean-ticnames-small  clean-ticnames-mid  clean-ticnames-large))</pre></td></tr><tr><td class="docs"><p>(def trend-map (map vector mid-tickers (map consolidated-trend2 clean-ticnames ) ))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>portfoflio setup</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def sector (map #(nth % 4)     nasdaq-data))
(def industry (map #(nth % 5)     nasdaq-data))
(def company-buckets (distinct (map #(str %1 &quot;-&quot; %2) sector industry)))
(def company-buckets-split (map #(str/split % #&quot;-&quot;) company-buckets))</pre></td></tr><tr><td class="docs"><p>how many tickers in a cbs bucket</p>

<p>(def cbs (rand-nth company-buckets-split))</p>
</td><td class="codes"><pre class="brush: clojure">(defn cbs-&gt;count
  [cbs]
  (let [tickers1 (filter good-ticker? (map first (filter #(and (= (second cbs)  (nth % 5))     (= (first cbs) (nth % 4))) nasdaq-data)))
        tickers2 (filter good-ticker? (map first (filter #(and (= (second cbs)  (nth % 5))     (= (first cbs) (nth % 4))) nyse-data)))
        tickers (concat tickers1 tickers2)
        out (count tickers)]
    out))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def cbs-counter (map vector company-buckets-split (map cbs-&gt;count company-buckets-split)))</pre></td></tr><tr><td class="docs"><p>(pprint (first cbs-counter))
(def cbs-counter (reverse (sort-by second cbs-counter)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(spit (str utils/HOME "/Dropbox/data/sectors.data")  (pr-str cbs-counter)  )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>to be refreshed now and then</p>
</td><td class="codes"><pre class="brush: clojure">(def cbs-counter (read-string (slurp (str utils/HOME &quot;/Dropbox/data/sectors.data&quot;))))</pre></td></tr><tr><td class="docs"><p>(def cbs (first (nth cbs-counter 2))) ;; 7 is a good one, steady returns
(pprint cbs-counter)</p>
</td><td class="codes"><pre class="brush: clojure">(defn sector-&gt;portfolio [N] (let [cbs (first (nth cbs-counter N)) ;; 7 is a good one, steady returns
                                  tickers1 (filter good-ticker? (map first (filter #(and (= (second cbs)  (nth % 5))     (= (first cbs) (nth % 4))) nasdaq-data)))
                                  tickers2 (filter good-ticker? (map first (filter #(and (= (second cbs)  (nth % 5))     (= (first cbs) (nth % 4))) nyse-data)))
                                  tickers (concat tickers1 tickers2)]
                              (vec tickers)))</pre></td></tr><tr><td class="docs"><p>build portfolios separately for now</p>
</td><td class="codes"><pre class="brush: clojure">(def portfolio-names (map #(str/join &quot;-&quot; %)  (map first cbs-counter))) ;; first is REITs second healthcare</pre></td></tr><tr><td class="docs"><p>first is REITs second healthcare</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def portfolio-name-tickers (zipmap portfolio-names (map sector-&gt;portfolio (take 1 (range (count cbs-counter))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def  portfolio-name-tickers (assoc-in portfolio-name-tickers [&quot;Index&quot;] [&quot;SPY&quot;]))</pre></td></tr><tr><td class="docs"><p>reverse lookup</p>
</td><td class="codes"><pre class="brush: clojure">(defn ticker-&gt;sector [ticker] (let [row (first (filter #(= ticker (first %)) (concat nyse-data nasdaq-data)))
                                    out (cond (nil? row) &quot;Index&quot; :else (str (nth row 4) &quot;-&quot; (nth row 5)))]
                                out
                  ;              row))</pre></td></tr><tr><td class="docs"><p>(ticker->sector "FOLD")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>setup
(println portfolio-name-tickers)
(ticker->sector "SPY")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sixty-day-high? [aticker]
  (let [this-data (ohlcv aticker)
        result (cond (nil? this-data) (identity false)
                     :else
                     (let [this-close (last (:c this-data))
                           best-high (apply max (drop-last (:h this-data)))]
                       (if (&gt;= this-close best-high)
                         (identity true) (identity false))))]
    (identity result)))</pre></td></tr><tr><td class="docs"><p>0 means only now it has hit, 0 1 means yesterday also it was at hi</p>
</td><td class="codes"><pre class="brush: clojure">(defn sixty-day-high2
  [aticker]
  (let [this-data (ohlcv aticker)
        result (cond (nil? this-data) nil
                     :else
                     (let [current-close (last (:c this-data))
                           yest-high (last (drop-last (:h this-data)))
                           best-high (apply max (drop-last (:h this-data)))]
                       (if (and (&lt; yest-high best-high) (&gt;= current-close best-high))
                         (identity true) (identity false))))]
    (identity result)))</pre></td></tr><tr><td class="docs"><p>0 means only now it has hit, 0 1 means yesterday also it was at hi</p>
</td><td class="codes"><pre class="brush: clojure">(defn sixty-day-low2
  [aticker]
  (let [this-data (ohlcv aticker)
        result (cond (nil? this-data) nil
                     :else
                     (let [current-close (last (:c this-data))
                           yest-high (last (drop-last (:l this-data)))
                           best-high (apply min (drop-last (:l this-data)))]
                       (if (and (&gt; yest-high best-high) (&lt;= current-close best-high))
                         (identity true) (identity false))))]
    (identity result)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sixty-day-low? [aticker]
  (let [this-data (ohlcv aticker)
        result (cond (nil? this-data) (identity false)
                     :else
                     (let [this-close (last (:c this-data))
                           best-low (apply min (drop-last (:l this-data)))]
                       (if (&lt;= this-close best-low)
                         (identity true) (identity false))))]
    (identity result)))</pre></td></tr><tr><td class="docs"><p>(filter sixty-day-high? (flatten (map second portfolio-name-tickers)))
(filter sixty-day-low? (flatten (map second portfolio-name-tickers)))</p>
</td><td class="codes"><pre class="brush: clojure">(defn high-or-low? [aticker] (or (sixty-day-high? aticker) (sixty-day-low? aticker)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def portfolio-tickers-relevant (remove #(-&gt; % second empty?) (map vector (map first portfolio-name-tickers)
                                                                   (map #(filter high-or-low? %) (map second portfolio-name-tickers)))))</pre></td></tr><tr><td class="docs"><p>(flatten (map second portfolio-tickers-relevant))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def portfolio-tickers-relevant  (take 10 portfolio-name-tickers))
(def ticker-coll (flatten (map second portfolio-tickers-relevant)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def portfolio [&quot;MDXG&quot;])</pre></td></tr><tr><td class="docs"><p>(map str portfolio)
(filter good-ticker? [  "NOK" "AAPL" "S" "RGC" "AMD" "DB" "OPGN" "BABA" "GE" "MU" "OSIS" "IIVI"  ] )</p>
</td><td class="codes"><pre class="brush: clojure">(def check-this (filter sixty-day-high2 clean-ticnames))</pre></td></tr><tr><td class="docs"><p>(pprint check-this)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def check-this2 (filter sixty-day-low2 clean-ticnames))</pre></td></tr><tr><td class="docs"><p>(pprint check-this2)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(apply max (drop-last (:h (ohlcv &quot;ETSY&quot;))))
(apply min (drop-last (:l (ohlcv &quot;TECD&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(:h (ohlcv &quot;T&quot;))
(:c (ohlcv &quot;MU&quot;))</pre></td></tr><tr><td class="docs"><p>subset to good tickers that have not had yest(hi) >= sixty-day-hi
check if last traded price has breached sixty-day-hi -> long and exit draw</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>backtest delete later</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>backtest delete later</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>first on a day which tics are eligible for long
show me 60 day hi
with bar data, if price breaches above, enter, exit on draw</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def date 20180308)
(def tic &quot;NTLA&quot;)
(defn sixty-day-high-price [date tic]
  (apply max (take-last 60 (:h (ohlcv-date date tic)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sixty-day-high-sd [date tic]
  (stats/sd (take-last 60 (:h (ohlcv-date date tic)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(sixty-day-high-sd 20180226 &quot;BPMC&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sixty-day-low-price [date tic]
  (apply min (take-last 60 (:l (ohlcv-date date tic)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn eligible? [buffer date tic]
  (let [data (ohlcv-date date tic)
        done? (cond (nil? data) false
                    :else
                    (let [highs (:h data)
        ;dates (:dates data)
                          N (count highs)
                          diff (- N (first (apply max-key second (map-indexed vector highs))))]
                      (&gt; diff buffer)))
        ;dummy (pprint (str &quot;doing &quot; tic))
        ;highs (:h data )
        ;dates (:dates data)
        ;N (count highs)
        ;diff (- N (first (apply max-key second (map-indexed vector highs ))))
]
    done?
    ;(&gt; diff buffer)
    ;diff
    ;(map vector highs dates)
    ;dates))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(eligible? 5 20180222 &quot;TRP&quot;)
(eligible? 5 20180224 &quot;BIVV&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn eligible-bear? [buffer date tic]
  (let [highs (:l (ohlcv-date date tic))
        N (count highs)
        diff (- N (first (apply min-key second (map-indexed vector highs))))]
    (&gt; diff buffer)
    ;diff))</pre></td></tr><tr><td class="docs"><p>(def highs (:h (ohlcv-date date tic )))
(count highs)
(first (apply max-key second (map-indexed vector highs )))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(eligible? 1 date "JNCE")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def high (sixty-day-high-price date tic))
(def price-breaches (cond (empty? (filter #(&gt; % high) (getPrices2 tic date 1)))
                          nil
                          :else (filter #(&gt; % high) (getPrices2 tic date 1))))</pre></td></tr><tr><td class="docs"><p>(utils/lPlot price-breaches)
(first price-breaches)
(count price-breaches)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bull-entry [n date tic] (let [high (sixty-day-high-price date tic)
                                    s (sixty-day-high-sd date tic)
                                    high-t (+ high (* n s))
                                    prices (getPrices2 tic date 1)
                                    m-prices (getPrices2 &quot;SPY&quot; date 1)
                                    mp (map vector prices m-prices)
                                    size (/ 10000 (first prices))
                                    m-size (/ 10000 (first m-prices))
                                    price-breach (cond (empty? (filter #(&gt; % high-t) prices))
                                                       nil
                                                       :else (first (filter #(&gt; % high-t) prices)))
                                    m-price-breach (cond (empty? (filter #(&gt; % high-t) prices))
                                                         nil
                                                         :else
                                                         (second (first (filter #(&gt; (first %) high-t) mp))))
                                    out (cond (nil? price-breach) nil :else (utils/round (* size (- (last prices) price-breach))))
                                    m-out (cond (nil? price-breach) nil :else (utils/round (* (- 1) m-size (- (last m-prices) m-price-breach))))]
                                (cond (nil? out) nil :else (utils/round (reduce + [out m-out])))
                              ;(utils/lPlot m-prices)
                                        ;high
                              ;[out m-out]
                              ;[ price-breach (last m-prices) ]))</pre></td></tr><tr><td class="docs"><p>(utils/csum (map #(bull-entry 20180221 % )   tmp  ))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(bull-entry 1 20180226 "BPMC" )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(getPrices2 "AKAM" 20180223 1 )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bear-entry [date tic] (let [;date 20180308
                          ;tic &quot;FTD&quot;
                                  low (sixty-day-low-price date tic)
                                  prices (getPrices2 tic date 1)
                                  price-breaches (cond (empty? (filter #(&lt; % low) prices))
                                                       nil
                                                       :else (filter #(&lt; % low) prices))
                                        ;(utils/lPlot price-breaches)
                                        ;(first price-breaches)
                                        ;(count price-breaches)
                                  out (cond (nil? price-breaches) nil :else (utils/round (* (- 1) 100 (- (last prices) (first price-breaches)))))]
                              out))</pre></td></tr><tr><td class="docs"><p>(filter #(eligible? 1 20180228 %) clean-ticnames )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bull-trading [date1]
  (let [elig (filter #(eligible? 5 date1 %) clean-ticnames)
        results (map vector elig  (map (partial bull-entry 1  date1) elig))]
    (stats/mean (map second (remove #(nil? (second %)) results)))
    (remove #(nil? (second %)) results)))</pre></td></tr><tr><td class="docs"><p>(pprint (bull-trading 20180308 ))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def tics (filter #(eligible? 5 20180224 %) clean-ticnames))</pre></td></tr><tr><td class="docs"><p>(pprint tics)
(eligible? 5 20180224 "BIVV")</p>
</td><td class="codes"><pre class="brush: clojure">(def b-dates (take-last 10 (drop-last 0 (recent-dates))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def res-1 (map vector b-dates (map #(bull-trading %)   b-dates)))</pre></td></tr><tr><td class="docs"><p>(def res-2 (map vector b-dates (map #(bear-trading % )   b-dates  )))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def long-pnls (map #(reduce + (map second (nth (map second res-1) %)))  (range 10)))</pre></td></tr><tr><td class="docs"><p>(pprint long-pnls)
(reduce + (map #(reduce + (map second (nth (map second res-2) % )   ))  (range 10)))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(identity b-dates)</pre></td></tr><tr><td class="docs"><p>(nth (map second res-1) 2 )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(pprint res-1)
(utils/csum (map second (bull-trading (first b-dates) ) ))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def res (bull-trading 20180223   ))
(pprint res)
(reduce + (map second res))
(eligible? 1 20180223 "PODD")
try threshold breach idea</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bear-trading [date1]
  (let [elig (filter #(eligible-bear? 1 date1 %) clean-ticnames)
        results (map vector elig  (map (partial bear-entry date1) elig))]
    (stats/mean (map second (remove #(nil? (second %)) results)))
    (remove #(nil? (second %)) results)))</pre></td></tr><tr><td class="docs"><p>(utils/lPlot (utils/csum (map second res-1)))
(map first res-1)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment [max-till-now (atom (first price-breaches))]
         (doseq [p price-breaches]

           (let [draw-now (utils/return_bps  @max-till-now p)
                 d (pprint draw-now)] (if (&gt;= draw-now 100) (pprint p)))

           (if (&gt; p @max-till-now) (reset! max-till-now p))))</pre></td></tr><tr><td class="docs"><p>clean</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.data" name="matrix.data"><h1 class="project-name">matrix.data</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.data (:require
                 [matrix.utils :as utils]
                 [matrix.indicators :as indicators]
                 [matrix.agents :as agents]
                 [matrix.timekeeper :as timekeeper]
                 [matrix.tickers :as tickers]
                 [matrix.jutsudata :as jutsudata]
                 [matrix.tradinglogic :as tradinglogic]
                 [matrix.pnl :as pnl]
                 [repltrader.execution :as execution]
                 [repltrader.gateway :as gateway]
                 [jutsu.core :as j]
                 [clojure.java.io :as io]
                 [clojure.string :as str]
                 [clj-http.client :as client]
                 [clj-time.format :as tf]
                 [clj-time.core :as tt]
                 [clojure.tools.nrepl.server :as serv]
                 [incanter.interpolation :refer :all]
                 [incanter [core :refer [$]
                            :as incanter$]
                  [core :as incanter]
                  [stats :as stats]
                  [io :as io2]
                  [charts :as charts]
                  [datasets :as dataset]
                                        ;[interpolation :as interpolation]
]
                 [clojure.core.async
                  :as clojurecoreasync
                  :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
                          alts! alts!! timeout]]
                 [clojure.tools.cli :refer [cli]] [matrix.utils :as u]
                 [taoensso.timbre :as timbre]
                 [clojure.term.colors :refer :all])  (:use clojure.pprint)
    (:require [clojure.tools.cli :refer [parse-opts]])
    (:gen-class))</pre></td></tr><tr><td class="docs"><p>slow entry in morning trading seems bad, you get in late and lose
elimintate 5 minute check
add returns frm open check, dont enter opposite this sign
cutoff max loss at 200/300 a tic
exit if ro is opposite sign now</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>can talk about good exit and good entry functions
good exit functions switch slowly
good entry conditions are fast</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>enter on p>p5 and dispersion in inc ; and ro is positive
exit if p5<p12 or draw based</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>dont have to take max loss then</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>first reasonable idea is the drawdown implementation in take-position exec logic 20180201
next, i want better criteria for entry:
use moving mean and SD (say max 5 minutes) to decide whether a point
is an activation point or not - leave it to later whether to include activation points going forward or not
each signal is activated as above, add market direction signal
use majority voting or unanimous to decide entry - backtest</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>bigger question is asset selection from pre-market data
this is an accounting question as well - do pre market disclosures cause
excess volatility -> are people who file friday night smart?</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>third important question is - should each ticker have its own max loss?
small price tickers show lot of volatility - OPGN is example</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>should we use volatility for position sizing?</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>20180131 in drawdown if bid ask is large, you are already sitting on DD on $1*108 positin, so thats exit - maybe not enter when bask is large?
or reference price for m2mpnl compute is mid-price not opposite</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>enter on 3 exit on 4 in cross section? -> does this make money consistently?
keep moving window by discarding old data
add 52 week high low information to bolster this</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>if spy trend is high, and self trend aligns then enter trade
write first relative indicator
for that in backtest quotes and trades are sorted</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>fernholz idea needs more work
we need clear distributional information on max draw and avg and sharpe
based on that we can tune the optimal capital for a ticker
practically you have only 40K max
ideally you have to run as many tickers as possible
next experiment with conditioning on relative volatility - if too high
dont trade or reduce risk considerably
time of day might be a natural salve for this
also solve the implementation shortfall issue
does hedging with the market help?</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>right now we peg to open, what if we dynamically peg to a moving
average, does that work better?
also when dispersion is moving, that is a bad time to peg</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>cross section idea: if we can catch NKTR as its volume explodes, we can make $$
first show me a measure of relative volume on a day -> collect 20 day average of per minute volume
per minute volume is just ohlcv volume divided by 390 -> approximate -> done
write indicator to show how frequently someone is trading it
measure log?inverse(t(last-trade) - t(trade-prior-to-that))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>another idea, if volume profile is average, then do MR else trend follow
decide volume profile with z score of cumulative volumes ie high volume day or low?</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>color code your output logs for readability</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>another thread that might be worthwhile
market making idea of putting two orders across price
make small profit for each ticker and run
avoid sharply trending tickers
mutreja used a combination of volatility adjusted market making momentum and reversal</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>phase 2 of project
need to generate gen strat type of
split into ranking exec
then simulate ranking
all on aws</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>next define indicators using only standardize information
convert p-ema into pseudo-price ema
write returns-quality</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>be able to run param permute
small pnl targets are a good idea
write returns quality indicator, based on return stream sharpe ratio
should be robust to jumps outliers
enter only if returns quality is high in the recent past</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>20171121, main things to be done:
1. create sim-strategy to test out of sample effectiveness
sim-strategy ticker-coll date-coll
memoize the tick data functions to test 100 strats per ticker
show me results of walkforward for various strats
write up volume information</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>portfoflio setup</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(ticker->sector "FOLD")
setup</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>read tickers from offline file</p>
</td><td class="codes"><pre class="brush: clojure">(comment (def tickers (sort (concat [&quot;TGT&quot; &quot;TEVA&quot; &quot;HAS&quot;] (take 300 (read-string (slurp &quot;/home/puru/Dropbox/data/small-tickers.data&quot;)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def N 3)</pre></td></tr><tr><td class="docs"><p>(def tickers (take N (sort (take 3000 (read-string (slurp "/home/puru/Dropbox/data/most-liquid-tickers.data" ))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def ticker-date-list (drop 1 (read-string (slurp "/home/puru/Dropbox/data/trade-these-mid.data" ))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def tickers ["MATW"] )
these are not used just placeholders</p>
</td><td class="codes"><pre class="brush: clojure">(def portfolio [&quot;NOK&quot; &quot;MDLZ&quot; &quot;BEN&quot; &quot;BABA&quot; &quot;FB&quot; &quot;TWTR&quot; &quot;RIG&quot; &quot;PYPL&quot; &quot;HAL&quot; &quot;VZ&quot;])
(def portfolio [&quot;MDXG&quot;])</pre></td></tr><tr><td class="docs"><p>(pprint ticker-date-list)</p>

<p>(def tickers (concat (second (last (drop-last 2 ticker-date-list))) ["XIV"]  )  )
(pprint tickers)</p>
</td><td class="codes"><pre class="brush: clojure">(def dates [20171114])</pre></td></tr><tr><td class="docs"><p>(def dates (take N (read-string (slurp "/home/puru/Dropbox/data/recent-dates.data"))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def dates [  (first (last (drop-last 2 ticker-date-list)))        ])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(count dates)
(pprint dates)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>important what is eond of day, 3 55 usually</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>eod at 1255 PM
(def end-time (utils/msec "20171124125500000" ))
eod at 3 55 PM
(def end-time (utils/msec "20171124155500000" ))
(pprint end-time)
(utils/tradingTime "201711241555 00000" )</p>
</td><td class="codes"><pre class="brush: clojure">(def end-time-string &quot;20171124155900000&quot;)
(def end-time (utils/msec end-time-string))
(pprint &quot;end trading at .. &quot;)
(pprint end-time-string)</pre></td></tr><tr><td class="docs"><p>(utils/tradingTime "20171124155500000" )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>update only so many times
(def bardata-frequency-msecs 15000)</p>
</td><td class="codes"><pre class="brush: clojure">(def bardata-frequency-msecs (* 1 60 1000))  ;;</pre></td></tr><tr><td class="docs">
</td><td class="codes"></td></tr><tr><td class="docs"><p>this is the indicator structure for the stock</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>for ticker and date, this is what is updated on the fly</p>
</td><td class="codes"><pre class="brush: clojure">(defn indicator-base-unit []
  (atom {:price (atom 0.0)
         :midprice (atom 0.0)
         :bidprice (atom 0.0)
         :askprice (atom 0.0)
         :price-bars (atom [])
         :volume-bars (atom [])
         :volume-ratio-bars (atom [])
         :open (atom 0.0)
         :hi (atom 0.0)
         :volume (atom 0.0)
         :buyvolume (atom 0.0)
         :sellvolume (atom 0.0)
         :lo (atom 10000.0)
         :time (atom 0.0)
         :time-string (atom &quot;0.0&quot;)
         :previous-trade-time (atom 0.0)
         :trade-time-lapse (atom 0.0)
         :time-bars (atom [])
            ;; range of stock
         :dispersion (atom 0.0)
         :dispersion-bars (atom [])
         :eod? (atom false)
         :eod-plus-one? (atom false)
         :seq-no (atom 0.0) ;; increment for bar data
         :pnl (atom 0.0) ;; m2m pnl for tic and date
}))</pre></td></tr><tr><td class="docs"><p>dates loop</p>
</td><td class="codes"><pre class="brush: clojure">(defn indicator-state-intermediate [dates indicator-base-unit]
  (zipmap (map keyword (map str dates)) (repeatedly (count dates)
                                                    indicator-base-unit)))</pre></td></tr><tr><td class="docs"><p>return indicator instances on tickers and dates, typically assigned to indicator-state variable</p>

<p>just loop over tickers</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-indicator-state
  [tickers dates] (zipmap (map keyword tickers)
                          (repeatedly (count tickers) #(indicator-state-intermediate dates indicator-base-unit))))</pre></td></tr><tr><td class="docs"><p>(indicator-state ["TGT" "TEVA"] [20171116 20171117])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(declare indicator-state)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>void function now delete</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(my-indicators-reset! ["TGT" "TEVA"] [20171116 20171117 ])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(indicator-state-intermediate [20171116 20171117 ] indicator-base-unit)
(def indicator-state (create-indicator-state ["TGT" "TEVA"] dates) )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>hmmm this is right format; do it again!!!
check if this works</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>some helper functions</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (defn getTradesQuotes
    [tic date start end]
    (let [tail (str &quot;&amp;trades=1&amp;quotes=1&amp;beginTime=&quot; date start &quot;&amp;endTime=&quot; date end)]
      (:body (client/get (str &quot;http://localhost:5000/tickData?symbol=&quot; tic tail)))))
  (defn getTrades
    [tic date start end]
    (let [tail (str &quot;&amp;trades=1&amp;quotes=0&amp;beginTime=&quot; date start &quot;&amp;endTime=&quot; date end)]
      (:body (client/get (str &quot;http://localhost:5000/tickData?symbol=&quot; tic tail)))))
  (defn getTradesQuotes-extended
    [tic date]
    (let [times [[&quot;093000&quot; &quot;103000&quot;]
                 [&quot;103000&quot; &quot;113000&quot;]
                 [&quot;113000&quot; &quot;123000&quot;]
                 [&quot;123000&quot; &quot;133000&quot;]
                 [&quot;133000&quot; &quot;143000&quot;]
                 [&quot;143000&quot; &quot;153000&quot;]
                 [&quot;153000&quot; &quot;160000&quot;]]
          dataset (atom )]
      (doseq [time times]
        (swap! dataset str (getTradesQuotes tic date (first time) (second time))))
      (identity @dataset)))
;(getTradesQuotes-extended &quot;BKD&quot; 20180222 )
  (defn getTrades-extended
    [tic date]
    (let [times [[&quot;093000&quot; &quot;113000&quot;]
                 [&quot;113000&quot; &quot;133000&quot;]
                 [&quot;133000&quot; &quot;153000&quot;]
                 [&quot;153000&quot; &quot;160000&quot;]]
          dataset (atom )]
      (doseq [time times]
        (swap! dataset str (getTrades tic date (first time) (second time))))
      (identity @dataset))) (defn getTradesQuotesNew
                              [tic date start end]
                              (let [tail (str &quot;&amp;trades=1&amp;quotes=1&amp;beginTime=&quot; date start &quot;&amp;endTime=&quot; date end)
                                    msgs (:body (client/get (str &quot;http://localhost:5000/tickData?symbol=&quot; tic tail)))
                                    split-msgs (str/split msgs #&quot;\r\n&quot;)
          ;out (first split-msgs)
                                    see (map #(conj (str/split % #&quot;,&quot;) tic)   split-msgs)
                                    see2 (map #(str/join &quot;,&quot; %) see)]
      ;out
                                see2))
  (defn getTradesNew
    [tic date start end]
    (let [tail (str &quot;&amp;trades=1&amp;quotes=0&amp;beginTime=&quot; date start &quot;&amp;endTime=&quot; date end)
          msgs (:body (client/get (str &quot;http://localhost:5000/tickData?symbol=&quot; tic tail)))
          split-msgs (str/split msgs #&quot;\r\n&quot;)
          ;out (first split-msgs)
          see (map #(conj (str/split % #&quot;,&quot;) tic)   split-msgs)
          see2 (map #(str/join &quot;,&quot; %) see)]
      ;out
      see2))
  (defn getTradesQuotes-extended-new
    [portfolio date]
    (let [;p-folio [&quot;HOG&quot; &quot;TGT&quot;]
       ;date 20180125
          times [[&quot;093000&quot; &quot;100000&quot;]
                 [&quot;100000&quot; &quot;103000&quot;]
                 [&quot;103000&quot; &quot;110000&quot;]
                 [&quot;110000&quot; &quot;113000&quot;]
                 [&quot;113000&quot; &quot;120000&quot;]
                 [&quot;120000&quot; &quot;123000&quot;]
                 [&quot;123000&quot; &quot;130000&quot;]
                 [&quot;130000&quot; &quot;133000&quot;]
                 [&quot;133000&quot; &quot;140000&quot;]
                 [&quot;140000&quot; &quot;143000&quot;]
                 [&quot;143000&quot; &quot;150000&quot;]
                 [&quot;150000&quot; &quot;153000&quot;]
                 [&quot;153000&quot; &quot;160000&quot;]]
          dataset (atom '())]
      (doseq [tic portfolio] (doseq [time times]
                               (swap! dataset concat (getTradesQuotesNew tic date (first time) (second time)))))
      (sort-by #(read-string (second (str/split % #&quot;,&quot;))) @dataset))))</pre></td></tr><tr><td class="docs"><p>(take-last 10 (getTradesQuotes-extended-new ["MDP"] 20180202))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>eod at 1255 PM
(def end-time (utils/msec "20171124125500000" ))
eod at 3 55 PM
(def end-time (utils/msec "20171124155500000" ))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>update all crucial data and bars on each trade tick for selected tickers</p>

<p>key function that update the indicator state object as data flows in
the body will change slightly for real data, this is for backtest data</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-stream-trade-backtest
  [indicator-state asset date-numeric msg]
  (let [[_ time_ price0 volume0 _ _ _ _ _ ticker] (str/split msg #&quot;,&quot;)
        price (Float/parseFloat price0)
        vol (Float/parseFloat volume0)
        k-asset (keyword asset)
        thistime (utils/msec time_)
        date (keyword (str date-numeric))
        previous-time
        (let [t @(:time-bars @((indicator-state k-asset) date))]
          (cond (empty? t) 0 :else (last t)))
        time-lapse (- thistime previous-time)
        hi-price @(:hi @((indicator-state k-asset) date))
        lo-price @(:lo @((indicator-state k-asset) date))
        my-price @(:price @((indicator-state k-asset) date))
        bidprice @(:bidprice @((indicator-state k-asset) date))
        askprice @(:askprice @((indicator-state k-asset) date))
        mid-price (/ (+ bidprice askprice) 2)
        my-volume @(:volume @((indicator-state k-asset) date))
        dispersion (cond (zero? my-price) 0.0 :else (utils/return-bps hi-price lo-price))
        ;current-trade-time @(:time @((indicator-state k-asset) date))
        ;previous-trade-time @(:previous-trade-time @((indicator-state k-asset) date))
        ;trade-time-lapse (- current-trade-time previous-trade-time)
]
;(println msg)
    (when (&lt;= thistime end-time)
      (do (reset! (@((indicator-state k-asset) date) :price)  price)
    ;(reset! (@((indicator-state k-asset) date) :previous-trade-time)  current-trade-time)
          (reset! (@((indicator-state k-asset) date) :time)  thistime)
          (reset! (@((indicator-state k-asset) date) :time-string)  time_)
          (reset! (@((indicator-state k-asset) date) :dispersion)  dispersion)
          (swap! (@((indicator-state k-asset) date) :volume)  + vol)
          (cond
          ;(&gt; price mid-price ) (swap! (@((indicator-state k-asset) date) :buyvolume)  + vol )
            (&lt; price mid-price) (swap! (@((indicator-state k-asset) date) :sellvolume)  + vol)
            (&gt; price mid-price) (swap! (@((indicator-state k-asset) date) :buyvolume)  + vol))
        ;(reset! (@((indicator-state k-asset) date) :trade-time-lapse)  trade-time-lapse ))
      (if (zero? my-price)
        (do (reset! (@((indicator-state k-asset) date) :open)  price)
            (reset! (@((indicator-state k-asset) date) :hi)  price)
            (reset! (@((indicator-state k-asset) date) :lo)  price)))
      (if (&gt; price hi-price)
        (reset! (@((indicator-state k-asset) date) :hi)  price))
      (if (&lt; price lo-price)
        (reset! (@((indicator-state k-asset) date) :lo)  price))
      (when (&gt;= time-lapse bardata-frequency-msecs)
        (do
          (swap! (@((indicator-state k-asset) date) :price-bars)  conj price)
          (swap! (@((indicator-state k-asset) date) :time-bars)  conj thistime)
          (swap! (@((indicator-state k-asset) date) :dispersion-bars)  conj dispersion)
          (swap! (@((indicator-state k-asset) date) :volume-bars)  conj my-volume)
          (reset! (@((indicator-state k-asset) date) :volume) 0.0)
          (reset! (@((indicator-state k-asset) date) :buyvolume) 0.0)
          (reset! (@((indicator-state k-asset) date) :sellvolume) 0.0)
          (swap! (@((indicator-state k-asset) date) :seq-no) inc)
;(timbre/debug  &quot;seq no update from trade&quot; @(@((indicator-state k-asset) date) :seq-no) ))))))</pre></td></tr><tr><td class="docs"><p>now write the bid ask monitor</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>update all crucial data and bars on each trade tick for selected tickers</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-stream-quote-backtest
  [indicator-state asset date-numeric msg]
  (let
   [[_ time_ bidprice0 askprice0 bidsize0 asksize0 _ _ _] (str/split msg #&quot;,&quot;)
              ;asset2 (clojure.string/replace asset #&quot;:&quot; &quot;&quot;)
    bidprice (Float/parseFloat bidprice0)
    askprice (Float/parseFloat askprice0)
    bidsize (Float/parseFloat bidsize0)
    asksize (Float/parseFloat asksize0)
    price  (/ (+ bidprice askprice) 2)
    thistime (utils/msec time_)
    thistime2 (utils/tradingTime time_)
    k-asset (keyword asset)
    date (keyword (str date-numeric))
    previous-time
    (let [t @(:time-bars @((indicator-state k-asset) date))]
      (cond (empty? t) 0 :else (last t)))
    time-lapse (- thistime previous-time)]
    (when (&lt;= thistime end-time) (do
                                   (reset! (@((indicator-state k-asset) date) :bidprice)  bidprice)
                                   (reset! (@((indicator-state k-asset) date) :askprice)  askprice)
                                   (reset! (@((indicator-state k-asset) date) :midprice)  price)
               ;(reset! (@((indicator-state k-asset) date) :price)  price ))
          (when (&gt;= time-lapse bardata-frequency-msecs)
            (do
              (swap! (@((indicator-state k-asset) date) :price-bars)  conj price)
              (swap! (@((indicator-state k-asset) date) :time-bars)  conj thistime)
              (reset! (@((indicator-state k-asset) date) :volume) 0.0)
              (swap! (@((indicator-state k-asset) date) :seq-no) inc)
              (swap! (@((indicator-state k-asset) date) :volume-bars)  conj 0)
;(timbre/debug  &quot;seq no update from quote&quot; @(@((indicator-state k-asset) date) :seq-no) ))))))</pre></td></tr><tr><td class="docs"><p>update all crucial data and bars on each trade tick for selected tickers</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-stream-trade-backtest-new
  [indicator-state date-numeric msg]
  (let [[_ time_ price0 volume0 _ _ _ _ _ ticker] (str/split msg #&quot;,&quot;)
        price (Float/parseFloat price0)
        vol (Float/parseFloat volume0)
        k-asset (keyword ticker)
        thistime (utils/msec time_)
        date (keyword (str date-numeric))
        previous-time
        (let [t @(:time-bars @((indicator-state k-asset) date))]
          (cond (empty? t) 0 :else (last t)))
        time-lapse (- thistime previous-time)
        hi-price @(:hi @((indicator-state k-asset) date))
        lo-price @(:lo @((indicator-state k-asset) date))
        my-price @(:price @((indicator-state k-asset) date))
        bidprice @(:bidprice @((indicator-state k-asset) date))
        askprice @(:askprice @((indicator-state k-asset) date))
        mid-price (/ (+ bidprice askprice) 2)
        my-volume @(:volume @((indicator-state k-asset) date))
        bv @(:buyvolume @((indicator-state k-asset) date))
        sv @(:sellvolume @((indicator-state k-asset) date))
        my-volume-ratio (cond (zero? (+ bv sv)) 0 :else (/ bv (+ bv sv)))
        dispersion (cond (zero? my-price) 0.0 :else (utils/return-bps hi-price lo-price))
        ;current-trade-time @(:time @((indicator-state k-asset) date))
        ;previous-trade-time @(:previous-trade-time @((indicator-state k-asset) date))
        ;trade-time-lapse (- current-trade-time previous-trade-time)
]
;(println msg)
    (when (&lt;= thistime end-time)
      (do (reset! (@((indicator-state k-asset) date) :price)  price)
          (reset! (@((indicator-state k-asset) date) :midprice)  price)
    ;(reset! (@((indicator-state k-asset) date) :previous-trade-time)  current-trade-time)
          (reset! (@((indicator-state k-asset) date) :time)  thistime)
          (reset! (@((indicator-state k-asset) date) :time-string)  time_)
          (reset! (@((indicator-state k-asset) date) :dispersion)  dispersion)
          (swap! (@((indicator-state k-asset) date) :volume)  + vol)
          (cond
            (&gt; price mid-price) (swap! (@((indicator-state k-asset) date) :buyvolume)  + vol)
            (&lt; price mid-price) (swap! (@((indicator-state k-asset) date) :sellvolume)  + vol))
        ;(reset! (@((indicator-state k-asset) date) :trade-time-lapse)  trade-time-lapse )
          (reset! timekeeper/global-time-now  thistime))
      (if (zero? my-price)
        (do (reset! (@((indicator-state k-asset) date) :open)  price)
            (reset! (@((indicator-state k-asset) date) :hi)  price)
            (reset! (@((indicator-state k-asset) date) :lo)  price)))
      (if (&gt; price hi-price)
        (reset! (@((indicator-state k-asset) date) :hi)  price))
      (if (&lt; price lo-price)
        (reset! (@((indicator-state k-asset) date) :lo)  price))
      (when (&gt;= time-lapse bardata-frequency-msecs)
        (do
          (swap! (@((indicator-state k-asset) date) :price-bars)  conj price)
          (swap! (@((indicator-state k-asset) date) :time-bars)  conj thistime)
          (swap! (@((indicator-state k-asset) date) :dispersion-bars)  conj dispersion)
          (swap! (@((indicator-state k-asset) date) :volume-bars)  conj my-volume)
          (swap! (@((indicator-state k-asset) date) :volume-ratio-bars)  conj my-volume-ratio)
          (reset! (@((indicator-state k-asset) date) :volume) 0.0)
          (reset! (@((indicator-state k-asset) date) :buyvolume) 0.0)
          (reset! (@((indicator-state k-asset) date) :sellvolume) 0.0)
          (swap! (@((indicator-state k-asset) date) :seq-no) inc)
;(timbre/debug  &quot;seq no update from trade &quot; ticker &quot; &quot; @(@((indicator-state k-asset) date) :seq-no) ))))))</pre></td></tr><tr><td class="docs"><p>(def msgs (getTradesQuotes-extended-new (take 2 portfolio) 20171114))
(pprint (take 10 msgs))
(first msgs)
(parse-stream-quote-backtest-new i-state 20171114 (first msgs))
(parse-stream-trade-backtest-new i-state 20171114 (nth msgs 5 ))
(pprint i-state)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>now write the bid ask monitor</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>update all crucial data and bars on each trade tick for selected tickers</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-stream-quote-backtest-new
  [indicator-state date-numeric msg]
  (let
   [[_ time_ bidprice0 askprice0 bidsize0 asksize0 _ _ _ ticker] (str/split msg #&quot;,&quot;)
              ;asset2 (clojure.string/replace asset #&quot;:&quot; &quot;&quot;)
    bidprice (Float/parseFloat bidprice0)
    askprice (Float/parseFloat askprice0)
              ;bidsize (Float/parseFloat bidsize0)
              ;asksize (Float/parseFloat asksize0)
    price  (/ (+ bidprice askprice) 2)
    thistime (utils/msec time_)
    thistime2 (utils/tradingTime time_)
    k-asset (keyword ticker)
    date (keyword (str date-numeric))
    previous-time
    (let [t @(:time-bars @((indicator-state k-asset) date))]
      (cond (empty? t) 0 :else (last t)))
    time-lapse (- thistime previous-time)]
    (when (&lt;= thistime end-time) (do
                                   (reset! (@((indicator-state k-asset) date) :bidprice)  bidprice)
                                   (reset! (@((indicator-state k-asset) date) :askprice)  askprice)
                                   (reset! (@((indicator-state k-asset) date) :midprice)  price)
                                        ;(reset! (@((indicator-state k-asset) date) :price)  price )
                                   (reset! timekeeper/global-time-now  thistime))
          (when (&gt;= time-lapse bardata-frequency-msecs)
            (do
              (swap! (@((indicator-state k-asset) date) :price-bars)  conj price)
              (swap! (@((indicator-state k-asset) date) :time-bars)  conj thistime)
              (reset! (@((indicator-state k-asset) date) :volume) 0.0)
              (swap! (@((indicator-state k-asset) date) :seq-no) inc)
              (swap! (@((indicator-state k-asset) date) :volume-bars)  conj 0)
;(timbre/debug  &quot;seq no update from quote&quot; @(@((indicator-state k-asset) date) :seq-no) ))))))</pre></td></tr><tr><td class="docs"><p>update all crucial data and bars on each trade tick for selected tickers</p>

<p>key function that update the indicator state object as data flows in
this is for real data</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-stream-trade
  [indicator-state date-numeric msg]
  (let [;[_ time_ price0 volume0 _ _ _ _ _ ticker] (str/split msg #&quot;,&quot;)
        [_ asset _ _ _ _ _ _ price0 volume0 time_] (str/split msg #&quot;,&quot;)
        price (Float/parseFloat price0)
        vol (Float/parseFloat volume0)
        k-asset (keyword asset)
        thistime (utils/msec time_)
        date (keyword (str date-numeric))
        previous-time
        (let [t @(:time-bars @((indicator-state k-asset) date))]
          (cond (empty? t) 0 :else (last t)))
        time-lapse (- thistime previous-time)
        hi-price @(:hi @((indicator-state k-asset) date))
        lo-price @(:lo @((indicator-state k-asset) date))
        my-price @(:price @((indicator-state k-asset) date))
        my-volume @(:volume @((indicator-state k-asset) date))
        ;current-trade-time @(:time @((indicator-state k-asset) date))
        ;previous-trade-time @(:previous-trade-time @((indicator-state k-asset) date))
        ;trade-time-lapse (- current-trade-time previous-trade-time)
        dispersion (cond (zero? my-price) 0.0 :else (utils/return-bps hi-price lo-price))]
;(println msg)
    (when (&lt;= thistime end-time)
      (do (reset! (@((indicator-state k-asset) date) :price)  price)
;(reset! (@((indicator-state k-asset) date) :previous-trade-time)  current-trade-time)
          (reset! (@((indicator-state k-asset) date) :time)  thistime)
          (reset! timekeeper/global-time-now  thistime)
          (reset! (@((indicator-state k-asset) date) :time-string)  time_)
          (reset! (@((indicator-state k-asset) date) :dispersion)  dispersion)
          (swap! (@((indicator-state k-asset) date) :volume)  + vol)
        ;(reset! (@((indicator-state k-asset) date) :trade-time-lapse)  trade-time-lapse ))
      (if (zero? my-price)
        (do (reset! (@((indicator-state k-asset) date) :open)  price)
            (reset! (@((indicator-state k-asset) date) :hi)  price)
            (reset! (@((indicator-state k-asset) date) :lo)  price)))
      (if (&gt; price hi-price)
        (reset! (@((indicator-state k-asset) date) :hi)  price))
      (if (&lt; price lo-price)
        (reset! (@((indicator-state k-asset) date) :lo)  price))
      (when (&gt;= time-lapse bardata-frequency-msecs)
        (do
          (swap! (@((indicator-state k-asset) date) :price-bars)  conj price)
          (swap! (@((indicator-state k-asset) date) :time-bars)  conj thistime)
          (swap! (@((indicator-state k-asset) date) :dispersion-bars)  conj dispersion)
          (swap! (@((indicator-state k-asset) date) :volume-bars)  conj my-volume)
          (reset! (@((indicator-state k-asset) date) :volume) 0.0)
          (swap! (@((indicator-state k-asset) date) :seq-no) inc))))))</pre></td></tr><tr><td class="docs"><p>test</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>now write the bid ask monitor for real data</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>update all crucial data and bars on each trade tick for selected tickers</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-stream-quote
  [indicator-state date-numeric msg]
  (let
   [;[_ time_ bidprice0 askprice0 bidsize0 asksize0 _ _ _ ] (str/split msg #&quot;,&quot;)
    [_ asset _ _ _ bidprice0 askprice0 bidsize0 asksize0 time_] (str/split msg #&quot;,&quot;)
              ;asset2 (clojure.string/replace asset #&quot;:&quot; &quot;&quot;)
    bidprice (Float/parseFloat bidprice0)
    askprice (Float/parseFloat askprice0)
    bidsize (Float/parseFloat bidsize0)
    asksize (Float/parseFloat asksize0)
    price  (/ (+ bidprice askprice) 2)
    thistime (utils/msec time_)
    thistime2 (utils/tradingTime time_)
    k-asset (keyword asset)
    date (keyword (str date-numeric))
    previous-time
    (let [t @(:time-bars @((indicator-state k-asset) date))]
      (cond (empty? t) 0 :else (last t)))
    time-lapse (- thistime previous-time)]
    (when (&lt;= thistime end-time) (do
                                   (reset! (@((indicator-state k-asset) date) :bidprice)  bidprice)
                                   (reset! (@((indicator-state k-asset) date) :askprice)  askprice)
                                   (reset! (@((indicator-state k-asset) date) :time-string)  time_) ;; i want to know if my algo is that slow?!
                                        ;(reset! (@((indicator-state k-asset) date) :price)  price ) ;; midprice if no traded price?
                                   (reset! (@((indicator-state k-asset) date) :midprice)  price)
                                   (reset! timekeeper/global-time-now  thistime)
               ;(reset! (@((indicator-state k-asset) date) :price)  price ))
          (when (&gt;= time-lapse bardata-frequency-msecs)
            (do
              (swap! (@((indicator-state k-asset) date) :price-bars)  conj price)
              (swap! (@((indicator-state k-asset) date) :time-bars)  conj thistime)
              (reset! (@((indicator-state k-asset) date) :volume) 0.0)
              (swap! (@((indicator-state k-asset) date) :seq-no) inc)
              (swap! (@((indicator-state k-asset) date) :volume-bars)  conj 0)
 ;(timbre/debug  &quot;seq no update from quote&quot; @(@((indicator-state k-asset) date) :seq-no) ))))
    ;; new update price as midprice even no trade has happened))</pre></td></tr><tr><td class="docs"><p>(def msgs (getTradesQuotes-extended-new ["TGT" "HOG"] 20171117)   )
(last (take 10 msgs))
(parse-stream-trade-backtest-new 20171117 (last (take 10 msgs))  )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(spit "/home/puru/matw" (getTradesQuotes-extended "MATW" 20171124))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>run through dates and tickers and update the indicator structure, includes quotes</p>

<p>now pass indicator state into this</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-data-quotes
  [indicator-state ticker date]
  (let [msgs (str/split (getTradesQuotes-extended ticker date)  #&quot;\r\n&quot;)
        ;msgs (str/split (getTrades-extended ticker date)  #&quot;\r\n&quot; )
]
    (doseq [msg msgs]
      (if (= \T (first msg)) (parse-stream-trade-backtest indicator-state ticker date msg)
          (if (= \Q (first msg)) (parse-stream-quote-backtest indicator-state ticker date msg))))
    (reset! (@((indicator-state (keyword ticker)) (keyword (str date))) :eod?)  true)
    (reset! (@((indicator-state (keyword ticker)) (keyword (str date))) :eod-plus-one?)  true)))</pre></td></tr><tr><td class="docs"><p>run through dates and tickers and update the indicator structure, includes quotes</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-data-quotes-new
  [indicator-state portfolio date]
  (let [msgs (getTradesQuotes-extended-new portfolio date)
        ;msgs (str/split (getTrades-extended ticker date)  #&quot;\r\n&quot; )
]
    (doseq [msg msgs]
      (if (= \Q (first msg)) (parse-stream-quote-backtest-new indicator-state date msg)
          (parse-stream-trade-backtest-new indicator-state date msg)))
    (pprint &quot;Setting EOD flags...&quot;)
    (doseq [ticker portfolio]
      (reset! (@((indicator-state (keyword ticker)) (keyword (str date))) :eod?)  true)
      (reset! (@((indicator-state (keyword ticker)) (keyword (str date))) :eod-plus-one?)  true))))</pre></td></tr><tr><td class="docs"><p>run through dates and tickers and update the indicator structure, includes quotes</p>

<p>print trades to file</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-data-trades
  [file ticker date]
  (let [msgs (str/split (getTrades-extended ticker date)  #&quot;\r\n&quot;)]
    (doseq [msg msgs]
      (if (= \T (first msg)) (spit file (str msg &quot;\n&quot;) :append true)))));(print-data-trades &quot;/home/puru/data/nktr.trades&quot; &quot;NKTR&quot; 20180109)</pre></td></tr><tr><td class="docs"><p>(print-data-trades "/home/puru/data/nktr.trades" "NKTR" 20180109)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>write the aboves live trading counterpart</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>live trading counterpart ends</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>test this
(update-data "TGT" 20171117)
takes time, update now!
(doall (for [this-ticker tickers this-date dates] (update-data this-ticker this-date)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def tic (keyword (first tickers)) )
(def date (keyword (str (first dates))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>show me price dispersion to check if correct
(utils/lPlot @(:price-bars @((indicator-state tic) date)))
(utils/lPlot @(:dispersion-bars @((indicator-state tic) date )))</p>
</td><td class="codes"><pre class="brush: clojure">(comment (doseq [date dates] (utils/lPlot (:dispersion-bars @((indicator-state tic) date)))))</pre></td></tr><tr><td class="docs"><p>show me returns</p>
</td><td class="codes"><pre class="brush: clojure">(comment (utils/lPlot (let [price @(:price-bars @((indicator-state tic) date))]
                        (conj (map utils/return-bps-col (partition 2 1 price)) 0))))</pre></td></tr><tr><td class="docs"><p>with a lookback of 5 units, what is the stdev of returns, ema</p>
</td><td class="codes"><pre class="brush: clojure">(comment (utils/lPlot (let [price @(:price-bars @((indicator-state tic) date))

                            returns (conj (map utils/return-bps-col (partition 2 1 price)) 0)]

                        (utils/ema 20 (map #(utils/sd (take-last 5 (take % returns)))  (range 1 (+ 1 (count  returns))))))))</pre></td></tr><tr><td class="docs"><p>with a lookback of 10 units, what is the sum of returns</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment (utils/lPlot  (let [price @(:price-bars @((indicator-state tic) date))
                             returns (conj (map utils/return-bps-col (partition 2 1 price)) 0)]

                         (map #(reduce + (take-last 5 (take % returns)))  (range 1 (+ 1 (count returns)))))))</pre></td></tr><tr><td class="docs"><p>ok now line up all these guys together for a predictive model
now these are all functions on price-bars, can be done by putting a watch
on :price-bars in simulation object
(identity tic)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def indicator-state (create-indicator-state portfolio dates))</pre></td></tr><tr><td class="docs"><p>indicators moved to indicators.clj</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>returns true if day has ended as per indicator state object</p>
</td><td class="codes"><pre class="brush: clojure">(defn eod-flat?
  [indicator-state tic date]  (let [eod? @(:eod? @((indicator-state tic) date))]
                                eod?))</pre></td></tr><tr><td class="docs"><p>define strat
if recent returns > 1% and stdev lo enter
exit on pnl target</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>general form of long entry is a function of indicator state,
which is a listener to bar-data</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>trade is
dispersion > 300 bps
delta dispersion is non zero - logic prod is moving in breakout
look at ema5-ema12 for direction and enter (might need to calibrate 0 points
from past data, ie when is it just noise?
use dd exit of 50 bps? with ema 5
max otl of 100 bps again with ema 5</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>make forecast using ema diff in the next 5 mins
calculate expected pnl
if positive expectation after t-cost, enter trade
when bps target is reached exit trade</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>--> next step
working as expected, but entry in diff of ema has to be calibrated
appears that high volatility is bad, so we can add conditions around that</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(str (str/join "," [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7)  ]) "\n")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>[current-position pnl m2m-pnl-bps max-pnl-this-round total-pnl ]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def token (utils/random-word))</p>
</td><td class="codes"><pre class="brush: clojure">(declare token)</pre></td></tr><tr><td class="docs"><p>write a max-loss map that cuts tickers at a certain loss 100 bps for BPMC seems appropriate from data, for a mean reversion strat</p>
</td><td class="codes"><pre class="brush: clojure">(def max-loss
  {:BPMC 100.0})</pre></td></tr><tr><td class="docs"><p>each agent attaches to each tic date matrix entry</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-state-intermediate [agent dates]
  (zipmap (map keyword (map str dates)) (repeatedly (count dates)
                                                    agent)))</pre></td></tr><tr><td class="docs"><p>just loop over tickers</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-agent-state [agent tickers dates] (zipmap (map keyword tickers) (repeatedly (count tickers) #(agent-state-intermediate agent dates))))</pre></td></tr><tr><td class="docs"><p>check this works
(create-agent-state #(agent-2 30 60 100) tickers [20171116 20171117])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>void now</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>check this
@((agent-state :TGT) :20171117)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>token identifies each run for datagen and pnl results reconsiliation
(def token (utils/random-word))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>define datagen file
(declare datagen-file (str utils/HOME "/data/datagen-" (str (gensym token )) ".txt" ))
(pprint (str "data gen file " datagen-file))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(declare datagen-file)</p>
</td><td class="codes"><pre class="brush: clojure">(def datagen-file (str utils/HOME &quot;/data/datagen-&quot; (str (gensym token)) &quot;.txt&quot;))</pre></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
to do: otl loss, global max loss ttc cuts larger position</p>

<p>trading logic</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic
  [datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        entry-condition (first ((:entry agent) indicator-state tic date))
        datagen-output (cond (nil? (:datagen agent)) nil
                             :else ((:datagen agent) indicator-state tic date)) short-entry-condition (second ((:entry agent) indicator-state tic date))
        ;allowed-to-enter? true
        uts (agent :uts)
        current-position @(agent :position)
        current-n-trades @(agent :n-trades)
        allowed-to-enter? (&lt; current-n-trades (agent :max-n-trades));;correct pnl accounting, if long i can get out on bid only
        reference-price (cond (pos? current-position) bidprice (neg? current-position) askprice :else price)
        mur (agent :mur)
        ;pnl (agent :pnl)
        last-entry @(agent :last-entry-price)
        agent-name (agent :name)
        last-entry-time @(agent :last-entry-time)
        time-now @(@((indicator-state tic) date) :time)
        ttc-now-minutes (cond (zero? current-position) 0.0 :else (utils/round (/ (- time-now last-entry-time) 60000)))
        pnls (cond (empty? last-entry) '(0.0) :else (map utils/round (map #(* % current-position) (map - (repeat (count last-entry) reference-price) last-entry))))
        pnls-bps (cond (empty? last-entry) '(0.0) :else
                       (map utils/round (map
                                         #(* % (utils/sign current-position))  (map utils/return-bps (repeat (count last-entry) reference-price)  last-entry))))
        pnl (utils/round (stats/mean pnls))
        pnl-bps (utils/round (stats/mean pnls-bps))
        max-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        total-pnl @(:total-pnl agent) ;; this is in bps
        m2m-pnl-bps @(:m2m-pnl-bps agent) ;; this is in bps
        drawdown (- max-pnl-this-round pnl-bps)
        ;dummy (pprint current-position)
        pnl-target-reached? (cond (nil? (:pnl-target-bps agent)) false :else (&gt;= pnl-bps (:pnl-target-bps agent)))
        drawdown-breached? (cond (nil? (:max-draw-bps agent)) false :else (&gt;= drawdown (:max-draw-bps agent)))
        ttc-breached? (cond (nil? ttc-now-minutes) false :else (&gt;= ttc-now-minutes (:max-ttc-minutes agent))) eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.0
        first-datapoint? (not (.exists (io/as-file datagen-file)))
        agent-datagen-output [agent-name current-position pnl m2m-pnl-bps max-pnl-this-round total-pnl drawdown ttc-now-minutes bidprice askprice (first last-entry)]
        agent-datagen-header [&quot;agent-name&quot; &quot;current-position&quot; &quot;pnl&quot; &quot;m2m-pnl-bps&quot; &quot;max-pnl-this-round&quot; &quot;total-pnl&quot; &quot;drawdown&quot; &quot;ttc&quot; &quot;bidprice&quot; &quot;askprice&quot; &quot;last-entry&quot;]]
    ;;remember eod positions and total-pnls are not correct in datagen bcos
    ;; after eod it does not print another point
    (if datagen? (if first-datapoint?
                   (spit datagen-file (utils/coll-&gt;string (concat (:header datagen-output) agent-datagen-header)) :append true)
                   (spit datagen-file (utils/coll-&gt;string (concat (:data datagen-output) agent-datagen-output)) :append true)))
    (if (and eod? (not eod-plus-one?))
      (do
        ;(pprint (str &quot;doing eod process &quot; tic date))
        (when (not (zero? current-position))
          (swap! (:position agent) - current-position)
          (swap! (:total-pnl agent) + (- (reduce + pnls) commission))
          (pprint (str &quot;eod pnl &quot; tic &quot; &quot; date &quot; &quot; @(:total-pnl agent))))
          ;; at EOD, the current list of prices is the list of positions we have, so pnl is just sum of these pnls);;else not eod so do regular stuff
      (cond
        ;true (pprint &quot;I com here&quot;)
        (zero? current-position)
        (do (when (and entry-condition allowed-to-enter?)
   ;(pprint &quot;long inc enter...&quot;)
              (do
           ;(alter ((sim-results this-agent) date) update-in [:position] + uts )
                (swap! (:position agent) + uts)
                (swap! (:last-entry-price agent) conj askprice)
                (reset! (:last-entry-time agent) time-now))
 ;  (enterlong))
            (when (and short-entry-condition allowed-to-enter?)
      ;(pprint &quot;short inc enter...&quot;)
              (do
                (swap! (:position agent) - uts)
                (swap! (:last-entry-price agent) conj bidprice)
                (reset! (:last-entry-time agent) time-now))))
        (not (zero? current-position))
        (do (reset! (:m2m-pnl-bps agent) pnl-bps)
            (when (&gt; pnl-bps max-pnl-this-round)
              (reset! (:max-pnl-this-round agent) pnl-bps))
            (when (or pnl-target-reached? drawdown-breached? ttc-breached?) ;; for now only this exit
  ;;time to get out
;(pprint (str &quot;pnl target reached, consider exit at pnl &quot; (first pnls)))
;  (exitposition)
              (cond
                (&gt; current-position 0)
                (do
                  (swap! (:position agent) - uts)
                  (swap! (:last-exit-price agent) conj price)
                  (swap! (:last-entry-price agent) pop)
                  (swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)))
                  (reset! (:m2m-pnl-bps agent) 0.0)
                  (reset! (:max-pnl-this-round agent) 0.0)
                  (reset! (:last-entry-time agent) nil)
                  (swap! (:n-trades agent) inc))
                (&lt; current-position 0)
                (do
                  (swap! (:position agent) + uts)
                  (swap! (:last-exit-price agent) conj price)
                  (swap! (:last-entry-price agent) pop)
                  (swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)))
                  (reset! (:m2m-pnl-bps agent) 0.0)
                  (reset! (:max-pnl-this-round agent) 0.0)
                  (reset! (:last-entry-time agent) nil)
                  (swap! (:n-trades agent) inc)))))
;;update m2m pnl
;; position is at +-mur);;consider entry)))</pre></td></tr><tr><td class="docs"><p>trading logic, called for each strat, tic date</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>this is a different logic, for market making type of behavior</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
market making
commit is true means you are ready to commit to a band and wait
this is when volatility is low, can be a fn of indicators
calculate band at all times as price+-dp when commit is false
if commit is true, then commit to band, dont update band, watch prices and enter if true
trade n times
for now i only exit on profit goals, ideally this exit is based on other side of band</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-make-markets
  [log-file-name datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [dummy (timbre/debug &quot;TL called with &quot; log-file-name datagen? agent indicator-state tic date)
        price @(@((indicator-state tic) date) :price)
        price-bars @(@((indicator-state tic) date) :price-bars)
                                        ;sigma (incanter/sd price-bars)
        sigma (:price-band-cents agent)       ;; only 3 cents for now
        ;price-band [ (utils/round (- price sigma)) (utils/round (+ price sigma)) ]
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        commit? (first ((:commit agent) indicator-state tic date)) ;; update band if commit not true, else monitor for entry exit only,
        long? (second ((:commit agent) indicator-state tic date)) ;; update band if commit not true, else monitor for entry exit only,
        short? (nth ((:commit agent) indicator-state tic date) 2) ;; update band if commit not true, else monitor for entry exit only,
;; reversed for momentum
        short-entry-condition (and short? @(:commit-lock agent) (&lt; price @(:price-band-lower agent)))
        entry-condition (and long?  @(:commit-lock agent) (&gt; price @(:price-band-upper agent)));uts (agent :uts)
        capital 1000.0
        uts (:data (indicators/position-to-take capital indicator-state tic date))
        current-position @(agent :position)
        current-position-abs (incanter/abs current-position)
        exit? (cond (pos? current-position) short-entry-condition (neg? current-position) entry-condition :else false)
        current-n-trades @(agent :n-trades)
        allowed-to-enter? (and @(:allowed-to-enter? agent) (&lt; current-n-trades (agent :max-n-trades)))
        ;;correct pnl accounting, if long i can get out on bid only
        reference-price (cond (pos? current-position) bidprice (neg? current-position) askprice :else price)
        mur (agent :mur)
        ;pnl (agent :pnl)
        last-entry @(agent :last-entry-price)
        agent-name (agent :agent-name)
        last-entry-time @(agent :last-entry-time)
        time-now @(@((indicator-state tic) date) :time)
        ttc-now-minutes (cond (zero? current-position) 0.0 :else (utils/round (/ (- time-now last-entry-time) 60000)))
        pnls (cond (empty? last-entry) '(0.0) :else (map utils/round (map #(* % current-position) (map - (repeat (count last-entry) reference-price) last-entry))))
        pnls-bps (cond (empty? last-entry) '(0.0) :else
                       (map utils/round (map
                                         #(* % (utils/sign current-position))  (map utils/return-bps (repeat (count last-entry) reference-price)  last-entry))))
        pnl (utils/round (stats/mean pnls))
        pnl-bps (utils/round (stats/mean pnls-bps))
        max-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        total-pnl @(:total-pnl agent) ;; this is in bps
        m2m-pnl-bps @(:m2m-pnl-bps agent) ;; this is in bps
        drawdown (- max-pnl-this-round pnl-bps)
        ;dummy (pprint current-position)
        pnl-target-reached? (cond (nil? (:pnl-target-bps agent)) false :else (&gt;= pnl-bps (:pnl-target-bps agent)))
        drawdown-breached? (cond (nil? (:max-draw-bps agent)) false :else (&gt;= drawdown (:max-draw-bps agent)))
        ttc-breached? (cond (nil? ttc-now-minutes) false :else (&gt;= ttc-now-minutes (:max-ttc-minutes agent))) eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.5
        first-datapoint? (not (.exists (io/as-file datagen-file)))
        agent-datagen-output [agent-name current-position pnl m2m-pnl-bps max-pnl-this-round total-pnl drawdown ttc-now-minutes bidprice askprice (first last-entry)]
        agent-datagen-header [&quot;agent-name&quot; &quot;current-position&quot; &quot;pnl&quot; &quot;m2m-pnl-bps&quot; &quot;max-pnl-this-round&quot; &quot;total-pnl&quot; &quot;drawdown&quot; &quot;ttc&quot; &quot;bidprice&quot; &quot;askprice&quot; &quot;last-entry&quot;]
        datagen-output (cond (nil? (:datagen agent)) nil
                             :else ((:datagen agent) indicator-state tic date))
        live? (cond (nil? @(:live? agent)) false :else @(:live? agent)) ;; place orders
        time @(:seq-no @((indicator-state tic) date))
        ib-tic (name tic)
        cash-account @(:cash-account agent) ;; this is in bps
        jutsu? (cond (nil? (:jutsu agent)) false :else (:jutsu agent))]
    ;;remember eod positions and total-pnls are not correct in datagen bcos
    ;; after eod it does not print another point
    (if jutsu? ;; start server from main
      ;;else update from jutsu of agent
      (doseq [update ((:jutsu agent) indicator-state tic date)
                                        ;dummy (pprint update)
]
        (do
          ;(pprint update)
          (j/update-graph!
           (:chart update)
           (:plotly-data update))
          (Thread/sleep 10)))) (if (and datagen? (:print-datagen? agent)) (if first-datapoint?
                                                                            (spit datagen-file (utils/coll-&gt;string (concat (:header datagen-output) agent-datagen-header)) :append true)
                                                                            (spit datagen-file (utils/coll-&gt;string (concat (:data datagen-output) agent-datagen-output)) :append true)))
    (if (and eod? (not eod-plus-one?))
      (do
        (when (not (zero? current-position))
          (swap! (:position agent) - current-position)
          (reset! (:eod-position agent) current-position)
          (swap! (:n-trades agent) inc)
       ;(swap! (:total-pnl agent ) + (- (reduce + pnls) commission) )
          (if (pos? current-position) (swap! (:cash-account agent) + (* current-position-abs bidprice)) (swap! (:cash-account agent) - (* current-position-abs askprice)))
          (reset! (:allowed-to-enter? agent) false)
        ;(timbre/debug &quot;EOD... time tic price pnl&quot; time tic price @(:total-pnl agent))
          (if live? (if (pos? current-position)
                      (execution/SELL ib-tic (incanter/abs current-position))
                      (execution/BUY ib-tic (incanter/abs current-position))))
          (reset! (:total-pnl agent) (int (- @(:cash-account agent) (* commission @(:n-trades agent)))))
          (reset! (:m2m-pnl agent) @(:cash-account agent))
;; eod pnl can be max pnl or min
          (let [pnl @(:m2m-pnl agent)]
            (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
            (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl))))
        (spit log-file-name (str (name date) &quot; stock &quot; ib-tic &quot; agent-name &quot; agent-name &quot; n-trades &quot; @(:n-trades agent)  &quot; max-pos &quot; @(:max-position agent)  &quot; min-pos &quot;  @(:min-position agent) &quot; eod position &quot;  @(:eod-position agent)     &quot; max-pnl &quot; (int @(:max-pnl agent)) &quot; min-pnl &quot; (int @(:min-pnl agent))  &quot; net-pnl &quot; (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))        &quot;\n&quot;) :append true)
        (let [net-pnl   (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))]
          (if (pos? net-pnl)
            (timbre/debug (green (str (name date) &quot; stock &quot; ib-tic &quot; agent-name &quot; agent-name &quot; n-trades &quot; @(:n-trades agent)  &quot; max-pos &quot; @(:max-position agent)  &quot; min-pos &quot;  @(:min-position agent) &quot; eod position &quot;  @(:eod-position agent)     &quot; max-pnl &quot; (int @(:max-pnl agent)) &quot; min-pnl &quot; (int @(:min-pnl agent))  &quot; net-pnl &quot; (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))        &quot;\n&quot;)))
            (timbre/debug (red (str (name date) &quot; stock &quot; ib-tic &quot; agent-name &quot; agent-name &quot; n-trades &quot; @(:n-trades agent)  &quot; max-pos &quot; @(:max-position agent)  &quot; min-pos &quot;  @(:min-position agent) &quot; eod position &quot;  @(:eod-position agent)     &quot; max-pnl &quot; (int @(:max-pnl agent)) &quot; min-pnl &quot; (int @(:min-pnl agent))  &quot; net-pnl &quot; (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))        &quot;\n&quot;)))));; at EOD, the current list of prices is the list of positions we have, so pnl is just sum of these pnls)
      (do
        (if commit? (reset! (:commit-lock agent) true))
        (if (not @(:commit-lock agent))
          (do
            (reset! (:price-band-lower agent)  (utils/round (- price sigma)))
            (reset! (:price-band-upper agent)  (utils/round (+ price sigma)))
 ;(timbre/debug &quot;set band... time tic price-band1 2&quot; time tic @(:price-band-lower agent ) @(:price-band-upper agent )  ))
;;else commit-lock is true, i have to monitor entry exit
          (do
            (cond
              (zero? current-position)
              (do (when (and entry-condition allowed-to-enter?)
                                        ;(pprint &quot;long inc enter...&quot;)
                    (do
                                        ;(alter ((sim-results this-agent) date) update-in [:position] + uts )
                      (swap! (:position agent) + uts)
                      (swap! (:last-entry-price agent) conj askprice)
                      (reset! (:last-entry-time agent) time-now)
             ;(timbre/debug &quot;check band... time tic price-band1 2&quot; time tic @(:price-band-lower agent ) @(:price-band-upper agent )  )
             ;(timbre/debug &quot;Enter long... time tic price pnl&quot; time tic price @(:total-pnl agent))
                      (swap! (:cash-account agent) - (* uts askprice))
            ;(timbre/debug &quot;buy-hedge call&quot; capital indicator-state tic date )
                      (execution/buy-hedge capital indicator-state tic date) (swap! (:n-trades agent) inc))
                                        ;  (enterlong))
                  (when (and short-entry-condition allowed-to-enter?)
                                        ;(pprint &quot;short inc enter...&quot;)
                    (do
                      (swap! (:position agent) - uts)
                      (swap! (:last-entry-price agent) conj bidprice)
                      (reset! (:last-entry-time agent) time-now)
             ;(timbre/debug &quot;check band... time tic price-band1 2&quot; time tic @(:price-band-lower agent ) @(:price-band-upper agent )  )
             ;(timbre/debug &quot;Enter short... time tic price pnl&quot; time tic price @(:total-pnl agent))
                      (swap! (:cash-account agent) + (* uts bidprice))
            ;(timbre/debug &quot;sell-hedge call&quot; capital indicator-state tic date )
                      (execution/sell-hedge capital indicator-state tic date)
                      (swap! (:n-trades agent) inc))))
              (not (zero? current-position))  ;; update pnls
              (do (reset! (:m2m-pnl-bps agent) pnl-bps)
                  (when (&gt; pnl-bps max-pnl-this-round)
                    (reset! (:max-pnl-this-round agent) pnl-bps))
                  (when (or pnl-target-reached? drawdown-breached? ttc-breached?) ;; change exit idea
          ;;time to get out
                                        ;(pprint (str &quot;pnl target reached, consider exit at pnl &quot; (first pnls)))
                                        ;  (exitposition)
                    (cond
                      (&gt; current-position 0)
                      (do
                        (swap! (:position agent) - uts)
                        (swap! (:last-exit-price agent) conj price)
                        (swap! (:last-entry-price agent) pop)
                        (swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)))
                        (reset! (:m2m-pnl-bps agent) 0.0)
                        (reset! (:max-pnl-this-round agent) 0.0)
                        (reset! (:last-entry-time agent) nil)
                        (swap! (:n-trades agent) inc)
                        (reset! (:commit-lock agent) false)   ;; start updating price bands
                        (swap! (:cash-account agent) + (* current-position-abs bidprice))
                        (execution/sell-hedge capital indicator-state tic date)
             ;(timbre/debug &quot;Exit long... time tic price pnl&quot; time tic price @(:total-pnl agent)))
                      (&lt; current-position 0)
                      (do
                        (swap! (:position agent) + uts)
                        (swap! (:last-exit-price agent) conj price)
                        (swap! (:last-entry-price agent) pop)
                        (swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)))
                        (reset! (:m2m-pnl-bps agent) 0.0)
                        (reset! (:max-pnl-this-round agent) 0.0)
                        (reset! (:last-entry-time agent) nil)
                        (swap! (:n-trades agent) inc)
                        (reset! (:commit-lock agent) false)
                        (swap! (:cash-account agent) - (* current-position-abs askprice))
                        (execution/buy-hedge capital indicator-state tic date)
             ;(timbre/debug &quot;Exit short... time tic price pnl&quot; time tic price @(:total-pnl agent)))))))
            (reset! (:m2m-pnl agent) (+ @(:cash-account agent) (* @(:position agent) reference-price)))
            (let [position @(:position agent)]
              (if (&gt; position @(:max-position agent)) (reset! (:max-position agent) position))
              (if (&lt; position @(:min-position agent)) (reset! (:min-position agent) position)))
            (let [pnl @(:m2m-pnl agent)]
              (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
              (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl))) (do (timbre/debug (green &quot;STATUS &quot; &quot; stock &quot; ib-tic &quot; current-position &quot; @(:position agent) &quot; n-trades &quot; @(:n-trades agent) &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; net-pnl &quot; (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))))
                                                                                ((indicator-state tic) date)
                                                                                (reset! (@((indicator-state tic) date) :pnl)   @(:m2m-pnl agent)))))) ;; if commit true, then lock commit-lock into true, stop updating price band)))</pre></td></tr><tr><td class="docs"><p>trading logic, called for each strat, tic date</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>market making logic ends</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>open jutsu window before calls from tradng logic</p>
</td><td class="codes"><pre class="brush: clojure">(def first-time? (atom true))
(def running-trace-id (atom 0))</pre></td></tr><tr><td class="docs"><p>(j/start-jutsu!)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
to do: otl loss, global max loss ttc cuts larger position</p>

<p>trading logic</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-follow-trend
  [datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        entry-condition (first ((:entry agent) indicator-state tic date))
        exit-condition (cond (nil? (:exit agent)) false :else (first ((:exit agent) indicator-state tic date))) datagen-output (cond (nil? (:datagen agent)) nil
                                                                                                                                     :else ((:datagen agent) indicator-state tic date))
        jutsu? (if (nil? (:jutsu agent)) false
                   true)
        ;(every? utils/notnan? datagen-output)
        short-entry-condition (second ((:entry agent) indicator-state tic date))
        short-exit-condition (cond (nil? (:exit agent)) false :else (second ((:exit agent) indicator-state tic date))) uts (agent :uts)
        current-position @(agent :position)
        current-n-trades @(agent :n-trades)
        allowed-to-enter? (and
                           @(:allowed-to-enter? agent)
                           (&lt; current-n-trades (agent :max-n-trades)));;correct pnl accounting, if long i can get out on bid only
        reference-price (cond (pos? current-position) bidprice (neg? current-position) askprice :else price)
        mur (agent :mur)
        ;pnl (agent :pnl)
        last-entry @(agent :last-entry-price)
        agent-name (agent :name)
        last-entry-time @(agent :last-entry-time)
        time-now @(@((indicator-state tic) date) :time)
        ttc-now-minutes (cond (zero? current-position) 0.0 :else (utils/round (/ (- time-now last-entry-time) 60000)))
        pnls (cond (empty? last-entry) '(0.0) :else (map utils/round (map #(* % current-position) (map - (repeat (count last-entry) reference-price) last-entry))))
        pnls-bps (cond (empty? last-entry) '(0.0) :else
                       (map utils/round (map
                                         #(* % (utils/sign current-position))  (map utils/return-bps (repeat (count last-entry) reference-price)  last-entry))))
        pnl (utils/round (stats/mean pnls))
        pnl-bps (utils/round (stats/mean pnls-bps))
        max-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        min-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        total-pnl @(:total-pnl agent) ;; this is in bps
        m2m-pnl-bps @(:m2m-pnl-bps agent) ;; this is in bps
        drawdown (- max-pnl-this-round pnl-bps)
        ;dummy (pprint current-position)
        pnl-target-reached? (cond (nil? (:pnl-target-bps agent)) false :else (&gt;= pnl-bps (:pnl-target-bps agent)))
        drawdown-breached? (cond (nil? (:max-draw-bps agent)) false :else (&gt;= drawdown (:max-draw-bps agent)))
        ttc-breached? (cond (nil? ttc-now-minutes) false :else (&gt;= ttc-now-minutes (:max-ttc-minutes agent)))
        max-loss-breached? (cond (nil? (max-loss tic)) false :else (&lt; pnl-bps (- (max-loss tic)))) eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.0
        datagen-file (str utils/HOME &quot;/data/datagen-&quot; token  &quot;.txt&quot;)
        first-datapoint? (not (.exists (io/as-file datagen-file)))
        agent-datagen-output [agent-name current-position pnl m2m-pnl-bps max-pnl-this-round total-pnl drawdown ttc-now-minutes bidprice askprice (first last-entry)]
        agent-datagen-header [&quot;agent-name&quot; &quot;current-position&quot; &quot;pnl&quot; &quot;m2m-pnl-bps&quot; &quot;max-pnl-this-round&quot; &quot;total-pnl&quot; &quot;drawdown&quot; &quot;ttc&quot; &quot;bidprice&quot; &quot;askprice&quot; &quot;last-entry&quot;]
        time @(:seq-no @((indicator-state tic) date))
        ;dummy (log/debug &quot;Trading logic called..&quot;)
        live? (cond (nil? @(:live? agent)) false :else @(:live? agent)) ;; place orders
        ib-tic (name tic)
        ;dummy (log/debug &quot;Trading logic called..&quot; live? ib-tic)
];; start  jutsu
    (if jutsu? (if (zero? time)
                 ;; start server plot first point
                 (do (when @first-time? (j/start-jutsu!) (reset! first-time? false))
                 ;(log/debug &quot;waiting for server&quot;)
                 ;(Thread/sleep 3000)
                 ;(log/debug &quot;value of jutsu&quot; ((:jutsu agent) indicator-state tic date  ) )
                 ;; assign trace id
                     (swap! jutsudata/trace-id-map assoc-in [tic] @running-trace-id)
                     (swap! running-trace-id inc)
                     (j/graph!
                      &quot;Foo&quot;
                      (first ((:jutsu agent) indicator-state tic date))))
             ;;else update from jutsu of agent
                 (let [update (second ((:jutsu agent) indicator-state tic date))]
                   (j/update-graph!
                    &quot;Foo&quot;
                    update))));;end jutsu
    (if datagen? (if first-datapoint?
                   (spit datagen-file (utils/coll-&gt;string (concat (:header datagen-output) ;agent-datagen-header)):append true)
                   (if (every? utils/notnan? (:data datagen-output))
                     (spit datagen-file (utils/coll-&gt;string (concat (:data datagen-output) ;agent-datagen-output)):append true)))) (if (and eod? (not eod-plus-one?))
                                                                                         (do
                                                                                           (reset! (:allowed-to-enter? agent) false)
                                                                                           (timbre/debug &quot;doing eod process &quot; time tic date)
                                                                                           (when (not (zero? current-position))
                                                                                             (swap! (:position agent) - current-position)
                                                                                             (swap! (:total-pnl agent) + (- (reduce + pnls) commission))
                                                                                             (if live? (if (pos? current-position)
                                                                                                         (execution/SELL ib-tic (incanter/abs current-position))
                                                                                                         (execution/BUY ib-tic (incanter/abs current-position)))))
                                                                                           (timbre/debug &quot;EOD:  tic date pnl min-pnl-bps n-trades &quot; tic date @(:total-pnl agent) @(:min-pnl-this-round agent) @(:n-trades agent))
          ;; at EOD, the current list of prices is the list of positions we have, so pnl is just sum of these pnls)
      ;;else not eod so do regular stuff
                                                                                         (cond
        ;true (pprint &quot;I com here&quot;)
                                                                                           (zero? current-position)
                                                                                           (do (when (and entry-condition allowed-to-enter?)
                                                                                                 (timbre/debug &quot;long inc enter...time tic price pnl&quot; time tic price @(:total-pnl agent))
                                                                                                 (do
           ;(alter ((sim-results this-agent) date) update-in [:position] + uts )
                                                                                                   (swap! (:position agent) + uts)
                                                                                                   (swap! (:last-entry-price agent) conj askprice)
                                                                                                   (reset! (:last-entry-time agent) time-now)
                                                                                                   (if live? (execution/BUY ib-tic uts)))
 ;  (enterlong))
                                                                                               (when (and short-entry-condition allowed-to-enter?)
                                                                                                 (timbre/debug &quot;short inc enter...time tic price pnl&quot; time tic price @(:total-pnl agent))
                                                                                                 (do
                                                                                                   (swap! (:position agent) - uts)
                                                                                                   (swap! (:last-entry-price agent) conj bidprice)
                                                                                                   (reset! (:last-entry-time agent) time-now)
                                                                                                   (if live? (execution/SELL ib-tic uts)))))
                                                                                           (not (zero? current-position))
                                                                                           (do
                                                                                             (reset! (:m2m-pnl-bps agent) pnl-bps)
    ;(log/debug &quot;pnl update...time tic pnl price&quot; time tic pnl price)
                                                                                             (when (&gt; pnl-bps max-pnl-this-round)
                                                                                               (reset! (:max-pnl-this-round agent) pnl-bps))
                                                                                             (when (&lt; pnl-bps min-pnl-this-round)
                                                                                               (reset! (:min-pnl-this-round agent) pnl-bps))
                                                                                             (when (or
                                                                                                    pnl-target-reached? drawdown-breached? ttc-breached? max-loss-breached?
                                                                                                    (and (pos? current-position) exit-condition) (and (neg? current-position) short-exit-condition)) ;; for now only this exit
  ;;time to get out
;(pprint (str &quot;pnl target reached, consider exit at pnl &quot; (first pnls)))
                                        ;  (exitposition)
                                                                                               (cond
                                                                                                 (&gt; current-position 0)
                                                                                                 (do
           ;(log/debug &quot;exiting long position...&quot; time tic)
                                                                                                   (swap! (:position agent) - uts)
                                                                                                   (swap! (:last-exit-price agent) conj price)
                                                                                                   (swap! (:last-entry-price agent) pop)
                                                                                                   (swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)))
                                                                                                   (reset! (:m2m-pnl-bps agent) 0.0)
                                                                                                   (reset! (:max-pnl-this-round agent) 0.0)
                                                                                                   (reset! (:last-entry-time agent) nil)
                                                                                                   (swap! (:n-trades agent) inc)
                                                                                                   (timbre/debug &quot;exiting long position... time tic price pnl&quot; time tic price @(:total-pnl agent))
                                                                                                   (if live? (execution/SELL ib-tic uts)))
                                                                                                 (&lt; current-position 0)
                                                                                                 (do
           ;(log/debug &quot;exiting short position...&quot; time tic)
                                                                                                   (swap! (:position agent) + uts)
                                                                                                   (swap! (:last-exit-price agent) conj price)
                                                                                                   (swap! (:last-entry-price agent) pop)
                                                                                                   (swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)))
                                                                                                   (reset! (:m2m-pnl-bps agent) 0.0)
                                                                                                   (reset! (:max-pnl-this-round agent) 0.0)
                                                                                                   (reset! (:last-entry-time agent) nil)
                                                                                                   (swap! (:n-trades agent) inc)
                                                                                                   (timbre/debug &quot;exiting short position... time tic price pnl&quot; time tic price @(:total-pnl agent))
                                                                                                   (if live? (execution/BUY ib-tic uts))))))
;;update m2m pnl
;; position is at +-mur);;consider entry)  ;; eod match);;remember eod positions and total-pnls are not correct in datagen bcos
    ;; after eod it does not print another point
      ;; eod match)</pre></td></tr><tr><td class="docs"><p>trading logic, called for each strat, tic date</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>trading logic for fernholz
agent ouputs target position
logic compares both with threshold in agent, and places order
eod same all else is same
cash accounting needs to be to manage arbit positions</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
to do: otl loss, global max loss ttc cuts larger position</p>

<p>trading logic</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-fernholz
  [log-file-name datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        current-position @(agent :position)
        current-position-abs (incanter/abs current-position)
        target-position ((:target-position agent) indicator-state tic date)
        ;; if NaN this becomes zero!
        share-diff (utils/round2 0 (- target-position current-position))
        share-diff-abs (incanter/abs share-diff)
        threshold (:inventory-threshold agent)
        cash-account @(:cash-account agent)
        m2m-pnl @(:m2m-pnl agent)
        current-n-trades @(agent :n-trades)
        agent-name (agent :agent-name)
        allowed-to-enter? (and
                           @(:allowed-to-enter? agent)
                           (&lt; current-n-trades (agent :max-n-trades)));;correct pnl accounting, if long i can get out on bid only
        reference-price (cond (pos? current-position) bidprice (neg? current-position) askprice :else price) eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.5 time @(:seq-no @((indicator-state tic) date))
        ;dummy (log/debug &quot;Trading logic called..&quot;)
        live? (cond (nil? @(:live? agent)) false :else @(:live? agent)) ;; place orders
        ib-tic (name tic)
        jutsu? (cond (nil? (:jutsu agent)) false :else (:jutsu agent))
        ;dummy (log/debug &quot;Trading logic called..&quot; live? ib-tic)
]
    (if jutsu? ;; start server from main
      ;;else update from jutsu of agent
      (doseq [update ((:jutsu agent) indicator-state tic date)
                                        ;dummy (pprint update)
]
        (do
          ;(pprint update)
          (j/update-graph!
           (:chart update)
           (:plotly-data update))
          (Thread/sleep 10)))) (if eod?
                                 (do
                                   (reset! (:allowed-to-enter? agent) false) (when (not (zero? current-position))
                                                                               (swap! (:position agent) - current-position)
                                                                               (swap! (:n-trades agent) inc)
                                                                               (reset! (:eod-position agent) current-position) (if (pos? current-position) (do (swap! (:cash-account agent) + (* current-position-abs bidprice))
                                                                                                                                                               (timbre/debug (red &quot;SELL to close &quot; &quot; price &quot; price &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl))
                                                                                                                                                               (if live? (execution/SELL ib-tic current-position-abs)))
                                                                                                                                   (do (swap! (:cash-account agent) - (* current-position-abs askprice))
                                                                                                                                       (timbre/debug (green &quot;BUY to close &quot; &quot; price &quot; price &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl))
                                                                                                                                       (if live? (execution/BUY ib-tic current-position-abs))))
                                                                               (reset! (:total-pnl agent) (int (- @(:cash-account agent) (* commission @(:n-trades agent)))))
                                                                               (reset! (:m2m-pnl agent) @(:cash-account agent))
;; eod pnl can be max pnl or min
                                                                               (let [pnl @(:m2m-pnl agent)]
                                                                                 (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
                                                                                 (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl)))
                                                                               (let [net-pnl   (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))]
                                                                                 (if (pos? net-pnl)
                                                                                   (timbre/debug (green &quot;STATUS &quot; &quot; stock &quot; ib-tic &quot; current-position &quot; @(:position agent) &quot; n-trades &quot; @(:n-trades agent) &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; net-pnl &quot;
                                                                                                        net-pnl))
                                                                                   (timbre/debug (red &quot;STATUS &quot; &quot; stock &quot; ib-tic &quot; current-position &quot; @(:position agent) &quot; n-trades &quot; @(:n-trades agent) &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; net-pnl &quot;
                                                                                                      net-pnl))))
                                                                               (spit log-file-name (str (name date) &quot; stock &quot; ib-tic &quot; agent-name &quot; agent-name &quot; n-trades &quot; @(:n-trades agent)  &quot; max-pos &quot; @(:max-position agent)  &quot; min-pos &quot;  @(:min-position agent) &quot; eod position &quot;  @(:eod-position agent)     &quot; max-pnl &quot; (int @(:max-pnl agent)) &quot; min-pnl &quot; (int @(:min-pnl agent))  &quot; net-pnl &quot; (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))        &quot;\n&quot;) :append true))
          ;; at EOD, the current list of prices is the list of positions we have, so pnl is just sum of these pnls)
      ;;else not eod so do regular stuff
;; write logic here
                                 (do
                                   (cond (and (pos? share-diff) (&gt;= share-diff-abs threshold))
                                         (do
                                           (timbre/debug (green &quot;BUY &quot; &quot; tic &quot; ib-tic &quot; askprice &quot; askprice &quot; share-diff &quot; share-diff &quot; share-diff abs &quot; share-diff-abs &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl))
                                           (swap! (:n-trades agent) inc)
                                           (swap! (:position agent) + share-diff-abs)
                                           (swap! (:cash-account agent) - (* share-diff-abs askprice))
                                           (if live? (execution/BUY ib-tic share-diff-abs))
         ;; buying so decrease wins)
                                         (and (neg? share-diff) (&gt;= share-diff-abs threshold))
                                         (do
                                           (timbre/debug (red &quot;SELL &quot; &quot; tic &quot; ib-tic &quot; bidprice &quot; bidprice &quot; share-diff &quot; share-diff &quot; share-diff abs &quot; share-diff-abs &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl))
                                           (swap! (:n-trades agent) inc)
                                           (swap! (:position agent)  - share-diff-abs)
                                           (swap! (:cash-account agent) + (* share-diff-abs bidprice))
         ;; buying so decrease wins
                                           (if live? (execution/SELL ib-tic share-diff-abs))))
                                   (reset! (:m2m-pnl agent) (+ cash-account (* current-position reference-price)))
                                   (let [position @(:position agent)]
                                     (if (&gt; position @(:max-position agent)) (reset! (:max-position agent) position))
                                     (if (&lt; position @(:min-position agent)) (reset! (:min-position agent) position)))
                                   (let [pnl @(:m2m-pnl agent)]
                                     (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
                                     (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl))))
;;consider entry)  ;; eod match))</pre></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
to do: otl loss, global max loss ttc cuts larger position</p>

<p>trading logic</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-datagen
  [datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        ib-tic (name tic)
        datagen-output (cond (nil? (:datagen agent)) nil
                             :else ((:datagen agent) indicator-state tic date))
        datagen-file (str utils/HOME &quot;/data/1_min/&quot; (str/lower-case ib-tic)  &quot;.us.txt&quot;)
        first-datapoint? (not (.exists (io/as-file datagen-file)))
        time @(:seq-no @((indicator-state tic) date))
        ;dummy (log/debug &quot;Trading logic called..&quot;)
        ib-tic (name tic)
        ;dummy (log/debug &quot;Trading logic called..&quot; live? ib-tic)
]
    (when datagen?
      (if (every? utils/notnan? (:data datagen-output))
        (timbre/debug (yellow (utils/coll-&gt;string (concat (:data datagen-output) ;agent-datagen-output)))))
      (if first-datapoint?
        (spit datagen-file (utils/coll-&gt;string (concat (:header datagen-output) ;agent-datagen-header)):append true)
        (if (every? utils/notnan? (:data datagen-output))
          (spit datagen-file (utils/coll-&gt;string (concat (:data datagen-output) ;agent-datagen-output)):append true))))))</pre></td></tr><tr><td class="docs"><p>new</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>this is a different logic, cross sectional entry exit</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
market making
commit is true means you are ready to commit to a band and wait
this is when volatility is low, can be a fn of indicators
calculate band at all times as price+-dp when commit is false
if commit is true, then commit to band, dont update band, watch prices and enter if true
trade n times
for now i only exit on profit goals, ideally this exit is based on other side of band
tic and date are keyword here</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-cross-sectional
  [log-file-name datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        price-bars @(@((indicator-state tic) date) :price-bars)
                                        ;sigma (incanter/sd price-bars)
        ;price-band [ (utils/round (- price sigma)) (utils/round (+ price sigma)) ]
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        entry-condition (first ((:entry agent) indicator-state tic date))
        exit-condition (cond (nil? (:entry agent)) false :else (nth ((:entry agent) indicator-state tic date) 2)) short-entry-condition (second ((:entry agent) indicator-state tic date))
        short-exit-condition (cond (nil? (:entry agent)) false :else (nth ((:entry agent) indicator-state tic date) 3));; reversed for momentum
                                        ;uts (agent :uts)
        capital 1000.0
        uts (:data (indicators/position-to-take capital indicator-state tic date))
        current-position @(agent :position)
        current-position-abs (incanter/abs current-position)
        exit? (cond (pos? current-position) short-entry-condition (neg? current-position) entry-condition :else false)
        current-n-trades @(agent :n-trades)
        allowed-to-enter? (and @(:allowed-to-enter? agent) (&lt; current-n-trades (agent :max-n-trades)))
        ;;correct pnl accounting, if long i can get out on bid only
        reference-price (cond (pos? current-position) bidprice (neg? current-position) askprice :else price)
        mur (agent :mur)
        ;pnl (agent :pnl)
        last-entry @(agent :last-entry-price)
        agent-name (agent :agent-name)
        last-entry-time @(agent :last-entry-time)
        time-now @(@((indicator-state tic) date) :time)
        ;ttc-now-minutes (cond (zero? current-position) 0.0 :else (utils/round (/ (- time-now last-entry-time) 60000 )) )
        pnls (cond (empty? last-entry) '(0.0) :else (map utils/round (map #(* % current-position) (map - (repeat (count last-entry) reference-price) last-entry))))
        pnls-bps (cond (empty? last-entry) '(0.0) :else
                       (map utils/round (map
                                         #(* % (utils/sign current-position))  (map utils/return-bps (repeat (count last-entry) reference-price)  last-entry))))
        pnl (utils/round (stats/mean pnls))
        pnl-bps (utils/round (stats/mean pnls-bps))
        max-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        total-pnl @(:total-pnl agent) ;; this is in dollars now
        m2m-pnl-bps @(:m2m-pnl-bps agent) ;; this is in bps
        drawdown (- max-pnl-this-round pnl-bps)
        ;dummy (pprint current-position)
        pnl-target-reached? (cond (nil? (:pnl-target-bps agent)) false :else (&gt;= pnl-bps (:pnl-target-bps agent)))
        drawdown-breached? (cond (nil? (:max-draw-bps agent)) false :else (&gt;= drawdown (:max-draw-bps agent)))
        ;ttc-breached? (cond (nil? ttc-now-minutes ) false :else (&gt;= ttc-now-minutes (:max-ttc-minutes agent ))  )
        eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.5
        first-datapoint? (not (.exists (io/as-file datagen-file)))
        agent-datagen-output [agent-name current-position pnl m2m-pnl-bps max-pnl-this-round total-pnl drawdown bidprice askprice (first last-entry)]
        agent-datagen-header [&quot;agent-name&quot; &quot;current-position&quot; &quot;pnl&quot; &quot;m2m-pnl-bps&quot; &quot;max-pnl-this-round&quot; &quot;total-pnl&quot; &quot;drawdown&quot; &quot;bidprice&quot; &quot;askprice&quot; &quot;last-entry&quot;]
        datagen-output (cond (nil? (:datagen agent)) nil
                             :else ((:datagen agent) indicator-state tic date))
        live? (cond (nil? @(:live? agent)) false :else @(:live? agent)) ;; place orders
        time @(:seq-no @((indicator-state tic) date))
        ib-tic (name tic)
        cash-account @(:cash-account agent) ;; this is in bps
        jutsu? (cond (nil? (:jutsu agent)) false :else (:jutsu agent))
        m2m-pnl @(:m2m-pnl agent)]
    ;;remember eod positions and total-pnls are not correct in datagen bcos
    ;; after eod it does not print another point
    (if (and datagen? (:print-datagen? agent)) (if first-datapoint?
                                                 (spit datagen-file (utils/coll-&gt;string (concat (:header datagen-output) agent-datagen-header)) :append true)
                                                 (spit datagen-file (utils/coll-&gt;string (concat (:data datagen-output) agent-datagen-output)) :append true)))
    (if (and eod? (not eod-plus-one?))
      (do
        (when (not (zero? current-position))
          (swap! (:position agent) - current-position)
          (reset! (:eod-position agent) current-position)
          (swap! (:n-trades agent) inc)
          (if (pos? current-position) (swap! (:cash-account agent) + (* current-position-abs bidprice)) (swap! (:cash-account agent) - (* current-position-abs askprice)))
          (reset! (:allowed-to-enter? agent) false)
          (swap! (:total-pnl agent) + (int (- @(:cash-account agent) (* commission @(:n-trades agent)))))
          (if (pos? current-position)
            (do (execution/SELL ib-tic (incanter/abs current-position))
                (timbre/debug (red &quot;EODSELLCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl   &quot; total-pnl &quot; (:total-pnl agent))))
            (do (execution/BUY ib-tic (incanter/abs current-position))
                (timbre/debug (green &quot;EODBUYCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl   &quot; total-pnl &quot; (:total-pnl agent)))))
          (reset! (:m2m-pnl agent) @(:cash-account agent))
;; eod pnl can be max pnl or min
          (let [pnl @(:m2m-pnl agent)]
            (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
            (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl))))
        (spit log-file-name (str (name date) &quot; stock &quot; ib-tic &quot; agent-name &quot; agent-name &quot; n-trades &quot; @(:n-trades agent)  &quot; max-pos &quot; @(:max-position agent)  &quot; min-pos &quot;  @(:min-position agent) &quot; eod position &quot;  @(:eod-position agent)     &quot; max-pnl &quot; (int @(:max-pnl agent)) &quot; min-pnl &quot; (int @(:min-pnl agent))  &quot; net-pnl &quot; (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))        &quot;\n&quot;) :append true)
        (let [net-pnl   (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent))))])
     ;; at EOD, the current list of prices is the list of positions we have, so pnl is just sum of these pnls)
      (do
        (cond
          (zero? current-position)
          (do (when (and entry-condition allowed-to-enter?)
                (do
                  (swap! (:position agent) + uts)
                  (swap! (:last-entry-price agent) conj askprice)
                  (reset! (:last-entry-time agent) time-now)
                  (swap! (:cash-account agent) - (* uts askprice))
                  (execution/buy-hedge capital indicator-state tic date)
                  (timbre/debug (green &quot;BUY &quot; &quot; tic &quot; ib-tic  &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl &quot; total-pnl &quot; total-pnl)) (swap! (:n-trades agent) inc))
                                        ;  (enterlong))
              (when (and short-entry-condition allowed-to-enter?)
                                        ;(pprint &quot;short inc enter...&quot;)
                (do
                  (swap! (:position agent) - uts)
                  (swap! (:last-entry-price agent) conj bidprice)
                  (reset! (:last-entry-time agent) time-now)
                                        ;(timbre/debug &quot;check band... time tic price-band1 2&quot; time tic @(:price-band-lower agent ) @(:price-band-upper agent )  )
                                        ;(timbre/debug &quot;Enter short... time tic price pnl&quot; time tic price @(:total-pnl agent))
                  (swap! (:cash-account agent) + (* uts bidprice))
                                        ;(timbre/debug &quot;sell-hedge call&quot; capital indicator-state tic date )
                  (execution/sell-hedge capital indicator-state tic date)
                  (timbre/debug (yellow &quot;SELL &quot; &quot; tic &quot; ib-tic &quot; price &quot; bidprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl &quot; total-pnl &quot; total-pnl)) (swap! (:n-trades agent) inc))))
          (not (zero? current-position))  ;; update pnls
          (do (reset! (:m2m-pnl-bps agent) pnl-bps)
              (when (&gt; pnl-bps max-pnl-this-round)
                (reset! (:max-pnl-this-round agent) pnl-bps))
              (when (or pnl-target-reached? drawdown-breached? exit-condition short-exit-condition) ;; change exit idea
        ;;time to get out
                                        ;(pprint (str &quot;pnl target reached, consider exit at pnl &quot; (first pnls)))
                                        ;  (exitposition)
                (cond
                  (&gt; current-position 0)
                  (do
                    (swap! (:position agent) - (incanter/abs current-position))
                    (swap! (:last-exit-price agent) conj price)
            ;(swap! (:last-entry-price agent) pop )
            ;(swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)) )
                    (reset! (:m2m-pnl-bps agent) 0.0)
                    (reset! (:max-pnl-this-round agent) 0.0)
                    (reset! (:last-entry-time agent) nil)
                    (swap! (:n-trades agent) inc)
                    (swap! (:cash-account agent) + (* current-position-abs bidprice))
                    (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent)))))
            ;(execution/sell-hedge capital indicator-state tic date )
                    (timbre/debug (yellow &quot;SELLCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; bidprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl  &quot; total-pnl &quot; total-pnl));(timbre/debug &quot;Exit long... time tic price pnl&quot; time tic price @(:total-pnl agent)))
                  (&lt; current-position 0)
                  (do
                    (swap! (:position agent) + (incanter/abs current-position))
                    (swap! (:last-exit-price agent) conj price)
            ;(swap! (:last-entry-price agent) pop )
                    (swap! (:total-pnl agent)   + (- (first pnls) (* 2 commission)))
                    (reset! (:m2m-pnl-bps agent) 0.0)
                    (reset! (:max-pnl-this-round agent) 0.0)
                    (reset! (:last-entry-time agent) nil)
                    (swap! (:n-trades agent) inc)
                    (swap! (:cash-account agent) - (* current-position-abs askprice))
                    (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent)))))
            ;(execution/buy-hedge capital indicator-state tic date )
                    (timbre/debug (green &quot;BUYCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl   &quot; total-pnl &quot; total-pnl));(timbre/debug &quot;Exit short... time tic price pnl&quot; time tic price @(:total-pnl agent)))))))
        (reset! (:m2m-pnl agent) (+ @(:cash-account agent) (* @(:position agent) reference-price)))
        (let [position @(:position agent)]
          (if (&gt; position @(:max-position agent)) (reset! (:max-position agent) position))
          (if (&lt; position @(:min-position agent)) (reset! (:min-position agent) position)))
        (let [pnl @(:m2m-pnl agent)]
          (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
          (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl))) (do (comment (timbre/debug (green &quot;STATUS &quot; &quot; stock &quot; ib-tic &quot; current-position &quot; @(:position agent) &quot; n-trades &quot; @(:n-trades agent) &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; net-pnl &quot; (utils/round (- @(:cash-account agent) (* commission @(:n-trades agent)))))))
      ;((indicator-state tic) date)
                                                                            (reset! (@((indicator-state tic) date) :pnl)   @(:m2m-pnl agent))));; if commit true, then lock commit-lock into true, stop updating price band)))</pre></td></tr><tr><td class="docs"><p>trading logic, called for each strat, tic date</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>

<p>add watch to both prices and eod flag
now define this with indicator state as input</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent
  [datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-make-markets
  [log-file-name datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-make-markets log-file-name datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-make-markets log-file-name datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-make-markets log-file-name datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-cross-sectional
  [log-file-name datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-cross-sectional log-file-name datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-cross-sectional log-file-name datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-cross-sectional log-file-name datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-position-target
  [log-file-name datagen-file datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-position-target log-file-name datagen-file datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-position-target log-file-name datagen-file datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-position-target log-file-name datagen-file datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-position-target-limit
  [log-file-name datagen-file datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-position-target-limit log-file-name datagen-file datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-position-target-limit log-file-name datagen-file datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-position-target-limit log-file-name datagen-file datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-debug
  [log-file-name datagen-file datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-debug log-file-name datagen-file datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-debug log-file-name datagen-file datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-debug log-file-name datagen-file datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-follow-trend
  [datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-follow-trend datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-follow-trend datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-follow-trend datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-fernholz
  [log-file-name datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-fernholz log-file-name datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-fernholz log-file-name datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (trading-logic-fernholz log-file-name datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>for indicator-state object and an agent, subscribe the agent to all the indicators states of tics and dates - agent is listening to all M*N price-bars</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-callback-agent-datagen
  [datagen? indicator-state agent tic date]
  (do (add-watch (:price-bars @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-datagen datagen? agent indicator-state tic date)))
      (add-watch (:eod? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-datagen datagen? agent indicator-state tic date)))
;; seems stupid to write datagen one last time after eod call, i do this
      (add-watch (:eod-plus-one? @((indicator-state tic) date)) (keyword (str (gensym (utils/random-word))))
                 (fn [key atom old-state new-state]
                   (tradinglogic/trading-logic-datagen datagen? agent indicator-state tic date)))))</pre></td></tr><tr><td class="docs"><p>sim-strategy takes agent ticker-coll and date-coll</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>helper functions for retrieval</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn retrieve-pnls [agent-state tic date]
  (let [k-tic (keyword tic)
        k-date (keyword (str date))]
    @(:total-pnl @((agent-state k-tic) k-date))))</pre></td></tr><tr><td class="docs"><p>pnl sharpe noofdatapoints min</p>
</td><td class="codes"><pre class="brush: clojure">(defn retrieve-pnl-sharpe
  [agent-state tic date]
  (let [k-tic (keyword tic)
        k-date (keyword (str date))
        pnls @(:total-pnl @((agent-state k-tic) k-date))]
    pnls))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn retrieve-pnls-tmp [agent-state dates tic] (map (partial retrieve-pnls agent-state tic) dates))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn retrieve-pnl-sharpe-tmp [agent-state dates tic] (utils/pnl-sharpe (map (partial retrieve-pnl-sharpe agent-state tic) dates)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare agent-states)
(defn pnls-for-the-day [date-coll ticker] (let [this-ticker ticker
                                                result (flatten (map #(retrieve-pnls-tmp % date-coll this-ticker) agent-states))
                                        ;f- (str &quot;/home/puru/Dropbox/data/ticker-&quot; this-ticker &quot;.data&quot;)
]
                            ;(pprint this-ticker)
                                            result
                                        ;(spit f- (pr-str result   ))))</pre></td></tr><tr><td class="docs"><p>readies indicator matrix
readies agent matrix
adds callbacks to trading logics
runs through tickers and dates
reports final pnl map</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> readies indicator matrix
 readies agent matrix
 adds callbacks to trading logics
 runs through tickers and dates
 reports final pnl map</p>
</td><td class="codes"><pre class="brush: clojure">(defn sim-strategy
  [datagen? agent ticker-coll date-coll]
  (let [indicator-state (create-indicator-state ticker-coll date-coll)
        agent-state (create-agent-state agent ticker-coll date-coll)]
    (doall (for [this-ticker ticker-coll this-date date-coll]
             (let [tic (keyword  this-ticker)
                   date (keyword (str this-date))
                   agent-listening-to-this-node  @((agent-state tic) date)]
               (add-callback-agent datagen? indicator-state agent-listening-to-this-node tic date))))
;;run through tickers
    (doall (for [this-ticker ticker-coll this-date date-coll] (update-data-quotes indicator-state this-ticker this-date)))
;; collect results
    (zipmap (map keyword ticker-coll) (map (partial retrieve-pnls-tmp agent-state date-coll)  ticker-coll))))</pre></td></tr><tr><td class="docs"><p> readies indicator matrix
 readies agent matrix
 adds callbacks to trading logics
 runs through tickers and dates
 reports final pnl map</p>
</td><td class="codes"><pre class="brush: clojure">(defn sim-strategy-make-markets
  [datagen? agent ticker-coll date-coll]
  (let [indicator-state (create-indicator-state ticker-coll date-coll)
        agent-state (create-agent-state agent ticker-coll date-coll)]
    (doall (for [this-ticker ticker-coll this-date date-coll]
             (let [tic (keyword  this-ticker)
                   date (keyword (str this-date))
                   agent-listening-to-this-node  @((agent-state tic) date)]
               (add-callback-agent-make-markets datagen? indicator-state agent-listening-to-this-node tic date))))
;;run through tickers
    (doall (for [this-ticker ticker-coll this-date date-coll] (update-data-quotes indicator-state this-ticker this-date)))
;; collect results
    (zipmap (map keyword ticker-coll) (map (partial retrieve-pnls-tmp agent-state date-coll)  ticker-coll))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn view-results [f-]
  (let [r (read-string (slurp f-))]
    (reverse (sort-by #(-&gt; % second first) r))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn init-jutsu [ticker]
  {:x [-1]
   :y [0]
   :mode &quot;markers&quot;
   :type &quot;scatter&quot;
   :name ticker})</pre></td></tr><tr><td class="docs"><p>looks like it works
(sim-strategy (agent-2 60 10 5) ["GGAL" "CSOD"] [20171117 20171120 ])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>test it
(def dates [20171113 20171114 20171115 20171116 20171117 ])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>right now this is ineffecient, cos it queries data repeatedly</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>and this is how you can write to datagen</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def f- (str "/home/puru/Dropbox/data/results-" (str (gensym)) ".data" ))
(spit f- (pr-str results-state))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
;defn -main [&amp; args]
;(serv/start-server :port 7888)
;;setup dates
                                        ;defn -main [&amp; args]
                                        ;(pprint (:tickers (parse-opts args cli-options)))
  (def cmd-args (let [{:keys [options arguments summary errors]} (parse-opts args
                                                                             [[&quot;-t&quot; &quot;--tickers&quot; &quot;ticker list&quot;
                                                                               :default [&quot;AAPL&quot;]]
                                                                              [&quot;-d&quot; &quot;--start-date&quot; &quot;date&quot;
                                                                               :default [20180108]]
                                                                              [&quot;-d2&quot; &quot;--end-date&quot; &quot;date&quot;
                                                                               :default [20180108]] [&quot;-f&quot; &quot;--file&quot; &quot;file to write results to&quot;
                                                                                                     :default (u/random-word)]
                                                                              [&quot;-h&quot; &quot;--help&quot; &quot;Print this help&quot; :default false]])]
                  arguments));(def cmd-args [20171205 &quot;CGNX,GWPH,PBYI,TTWO,SHOP&quot; &quot;fatwa&quot;])
  (def ticker-coll (str/split (first cmd-args) #&quot;,&quot;))
;(def ticker-coll (concat [&quot;SPY&quot;] ticker-coll))
  (def date-coll (let [start-date (read-string (second cmd-args))
                       end-date (read-string (nth cmd-args 2))
                       date-coll (filter #(and (&gt;= % start-date) (&lt;= % end-date))
                                         (tickers/recent-dates))]
                   date-coll))
; (def date-coll [ (second cmd-args) ]  )
  (def arg-token (nth cmd-args 3))
  (def token arg-token);(def ticker-coll [&quot;BPMC&quot;])
                                        ;(def date-coll [20171215 20171214])
                                        ;(def arg-token &quot;test&quot;)
                                        ;(def token arg-token)
  (comment (j/start-jutsu!)
           (Thread/sleep 3000)
           (doseq [portfolio tickers/portfolio-name-tickers]
             (do
                                        ;            (Thread/sleep 3000)
                                        ;            (j/start-jutsu!)
                                        ;           (Thread/sleep 3000)
               (j/graph!
                (str (first portfolio) &quot;-prices&quot;)
                (map init-jutsu (vec (second portfolio))))
               (j/graph!
                (str (first portfolio) &quot;-volumes&quot;)
                (map init-jutsu (vec (second portfolio))))
               (comment (j/graph!
                         (str (first portfolio) &quot; LM&quot;)
                         (map init-jutsu (vec (second portfolio))))) (let [ticker-coll (second portfolio)
                                                                           p-key (keyword (first portfolio))] (doseq [counter (range (count ticker-coll))]
                                                                                                                (swap! (p-key jutsudata/trace-id-map) assoc-in [(keyword (nth ticker-coll counter))] counter))))))
;(def ticker-coll (sort (flatten (map second tickers/portfolio-name-tickers))))
;; now datagen comes from agent itself
  (def datagen? true)
;(def ticker-coll (concat ticker-coll '(&quot;SPY&quot;) ))
;(def ticker-coll portfolio)
  ;;cannot be more than 20
                                        ; (def N 20)
                                        ;(def ticker-coll (take N (sort (read-string (slurp &quot;/home/puru/Dropbox/data/mid-tickers.data&quot; )))))
                                        ;(def dates [20171113 20171114 20171115 20171116 20171117 ])
                                        ;(def date-coll (take N (read-string (slurp &quot;/home/puru/Dropbox/data/recent-dates.data&quot;))))
;; setup logging
  (def log-file-name (str utils/HOME &quot;/Dropbox/data/&quot; arg-token &quot;.data&quot;))
  (io/delete-file log-file-name :quiet)
  (def datagen-file (str utils/HOME &quot;/Dropbox/data/&quot; arg-token &quot;.datagen&quot;))
  (io/delete-file datagen-file :quiet)
  (def results-file-name (str utils/HOME &quot;/Dropbox/data/&quot; arg-token &quot;.results&quot;)) (do
    ;(def a-list (identity agents/a-list-datagen ))
                                                                                   (def a-list (identity agents/a-list))
                                        ;(if (= &quot;true&quot; datagen?) (do (pprint &quot;Got datagen true, doing only one datagen strat eval..&quot;) (def a-list agents/a-list-datagen)))
                                        ;(def source- (rand-nth (drop-last 2 ticker-date-list) ))
                                                                                   (def agent-states (map #(create-agent-state % ticker-coll date-coll) a-list))
                                                                                   (def i-state (create-indicator-state ticker-coll date-coll)))
                                        ;(pprint &quot;here&quot;)
  (doseq [agent-state agent-states]
    (doseq [this-ticker ticker-coll]
      (doseq [this-date date-coll]
        (let [tic (keyword  this-ticker)
              date (keyword (str this-date))
              agent-listening-to-this-node  @((agent-state tic) date)]
                                        ;(pprint (str tic &quot; &quot; date))
;                                                (add-callback-agent-make-markets log-file-name datagen? i-state agent-listening-to-this-node tic date )
;          (add-callback-agent-follow-trend datagen? i-state agent-listening-to-this-node tic date )
;          (add-callback-agent-fernholz log-file-name datagen? i-state agent-listening-to-this-node tic date )
          ;(add-callback-agent-datagen datagen? i-state agent-listening-to-this-node tic date )
          ;(add-callback-agent-cross-sectional log-file-name datagen? i-state agent-listening-to-this-node tic date )
          ;(add-callback-agent-position-target log-file-name datagen-file datagen? i-state agent-listening-to-this-node tic date )
          (add-callback-agent-position-target-limit log-file-name datagen-file datagen? i-state agent-listening-to-this-node tic date)))))
  (pprint &quot;Doing...&quot;);; from here backtest system will diverge from live system
 ;; this is backtest
 ;; setup logging
; The default setup is simple console logging.  We with to turn off console logging and
; turn on file logging to our chosen filename.
;(timbre/set-config! [:appenders :standard-out   :enabled?] false)
;(timbre/set-config! [:appenders :spit           :enabled?] true)
;(timbre/set-config! [:shared-appender-config :spit-filename] log-file-name)
;(timbre/set-config! [:shared-appender-config :spit-filename] log-file-name)
 ;; end setup logging
  (doseq
   [this-date date-coll]
    ;(pprint (str &quot;Doing this tic and date &quot; this-ticker &quot; &quot; this-date))
    (update-data-quotes-new i-state ticker-coll  this-date)) (def total-pnl (reduce + (map #(:data (indicators/pnl-indicator i-state (keyword %) (keyword (str (first date-coll))))) ticker-coll)))
  (def total-pnls (map #(:data (indicators/pnl-indicator i-state (keyword %) (keyword (str (first date-coll))))) ticker-coll)) (pprint (str &quot;Total pnl -&gt; &quot; ticker-coll &quot; &quot; (first date-coll) &quot; &quot; total-pnl))
  (pprint &quot;pnls by ticker -&gt; &quot;)
  (pprint (map vector ticker-coll total-pnls))
  (def write-this (str (first date-coll) &quot; &quot; (str/join &quot;,&quot; ticker-coll)  &quot; &quot; total-pnl &quot;\n&quot;))
  (spit results-file-name write-this :append true)
  (shutdown-agents)) ;;end main</pre></td></tr><tr><td class="docs"><p>end main</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>live trading main</p>
</td><td class="codes"><pre class="brush: clojure">(;comment
  defn -main [&amp; args]
  (serv/start-server :port 7888)
  (def cmd-args (let [{:keys [options arguments summary errors]} (parse-opts args
                                                                             [[&quot;-t&quot; &quot;--tickers&quot; &quot;ticker list&quot;
                                                                               :default [&quot;AAPL&quot;]]])]
                  arguments));(def cmd-args [20171205 &quot;CGNX,GWPH,PBYI,TTWO,SHOP&quot; &quot;fatwa&quot;])
  (def ticker-coll (str/split (first cmd-args) #&quot;,&quot;))
;(def ticker-coll (str/split (slurp &quot;/home/puru/Dropbox/data/corr_tickers.data&quot;) #&quot;\n&quot;))
  (def ticker-coll (take 5 (shuffle (filter tickers/good-ticker? tickers/tickers))))
  (def ticker-coll (concat [&quot;SPY&quot;] ticker-coll))
  (comment (j/start-jutsu!)
           (Thread/sleep 3000)
           (doseq [portfolio tickers/portfolio-name-tickers]
             (do
            ;(j/start-jutsu!)
               (Thread/sleep 3000)
               (j/graph!
                (str (first portfolio) &quot;-prices&quot;)
                (let [out (atom [])]
                  (doseq [ticker (vec (second portfolio))]
                    (swap! out conj (init-jutsu ticker)))
                  @out))
               (Thread/sleep 3000)
               (j/graph!
                (str (first portfolio) &quot;-volumes&quot;)
             ;(map init-jutsu (vec (second portfolio)))
                (let [out (atom [])]
                  (doseq [ticker (vec (second portfolio))]
                    (swap! out conj (init-jutsu ticker)))
                  @out))
               (Thread/sleep 3000)
               (comment
                 (str (first portfolio) &quot;-realprices&quot;)
                 (map init-jutsu (vec (second portfolio)))) (let [ticker-coll (second portfolio)
                                                                  p-key (keyword (first portfolio))] (doseq [counter (range (count ticker-coll))]
                                                                                                       (swap! (p-key jutsudata/trace-id-map) assoc-in [(keyword (nth ticker-coll counter))] counter))))))
  (defn forever [indicator-state ticker-coll date]
    (do
      (doseq [ticker ticker-coll]
        (j/update-graph!
         &quot;prices&quot;
         (:jutsu (indicators/returns-from-open indicator-state (keyword ticker) (keyword (str date)))))
        (Thread/sleep 10)
        (timbre/debug &quot;Sent update to graph &quot;  (:jutsu (indicators/returns-from-open indicator-state (keyword ticker) (keyword (str date))))))
      (Thread/sleep bardata-frequency-msecs)))
  (defn forever-pnl [indicator-state ticker-coll date]
    (do
      (doseq [ticker ticker-coll])
  ;(Thread/sleep bardata-frequency-msecs)))
;(def ticker-coll (sort (flatten (map second tickers/portfolio-tickers-relevant))))
;(def ticker-coll portfolio)
  (def datagen? false)
  (def log-file-name (str utils/HOME &quot;/Dropbox/data/&quot; &quot;live&quot; &quot;.data&quot;))
  (io/delete-file log-file-name :quiet)
  (def datagen-file (str utils/HOME &quot;/Dropbox/data/&quot; &quot;live&quot; &quot;.datagen&quot;))
  (io/delete-file datagen-file :quiet)
;  (def ticker-coll [&quot;CRSP&quot;])
  (def date-coll [@tickers/today_int])
  (do
    (def a-list (identity agents/a-list))
    (def agent-states (map #(create-agent-state % ticker-coll date-coll) a-list))
    (def i-state (create-indicator-state ticker-coll date-coll)))
                                        ;(pprint &quot;here&quot;)
  (doseq [agent-state agent-states]
    (doseq [this-ticker ticker-coll]
      (doseq [this-date date-coll]
        (let [tic (keyword  this-ticker)
              date (keyword (str this-date))
              agent-listening-to-this-node  @((agent-state tic) date)]
          (pprint (str tic &quot; adding callbacks &quot; date))
         ;(add-callback-agent-make-markets log-file-name datagen? i-state agent-listening-to-this-node tic date )
         ;(add-callback-agent-cross-sectional log-file-name datagen? i-state agent-listening-to-this-node tic date )
                                        ;(add-callback-agent-position-target log-file-name datagen-file datagen? i-state agent-listening-to-this-node tic date )
          (add-callback-agent-position-target-limit log-file-name datagen-file datagen? i-state agent-listening-to-this-node tic date)
;        (add-callback-agent-follow-trend datagen? i-state agent-listening-to-this-node tic date )
        ;(add-callback-agent-fernholz log-file-name datagen? i-state agent-listening-to-this-node tic date )))))
  (def streamURL (str &quot;http://localhost:5000/quoteStream?symbol=&quot; (clojure.string/join &quot;+&quot; ticker-coll)))
  (println streamURL)
  (defn trades-chan
    &quot;Open the URL as a stream of trades information. Return a channel of the trades, represented as strings.&quot;
    [url]
    (let [lines (-&gt; url
                    (client/get {:as :stream})
                    :body
                    io/reader
                    line-seq)];;A lazy seq of each line in the stream.
      (clojurecoreasync/to-chan lines))) ;;Return a channel which outputs the lines
  (def live-date (first date-coll))
  ;; view jutsu data forever
  (comment
    (Thread. (forever i-state ticker-coll live-date))
    (.setDaemon true)
    (.start)) (defn onTick
                [msg]
 ;(pprint msg)
                (if (= \T (first msg)) (parse-stream-trade i-state live-date msg)
                    (if (= \Q (first msg)) (parse-stream-quote i-state live-date msg))))
;;;;;;;position sizing logic
  (println &quot;Trying Subscription to data...&quot;)
  (def msgBlock (trades-chan streamURL))
  (println &quot;Subscribed to data...&quot;)
  (println &quot;Trying Connection to gateway...&quot;)
  (gateway/connect)
  (gateway/subscribe prn)
  (println &quot;Done...&quot;)
  (Thread/sleep 1000)
  (println &quot;account updates...&quot;)
 ;(gateway/request-account-updates true &quot;1&quot;)
  (println &quot;Done...&quot;)
  (Thread/sleep 1000) (clojurecoreasync/go-loop [takes 100]
                        (when (&lt; 0 takes)
                          (onTick (clojurecoreasync/&lt;! msgBlock))
                          (recur takes)))
;; doesnt work
  (comment (dotimes [_ 390]
             (doseq [ticker ticker-coll]
               (j/update-graph!
                (str (tickers/ticker-&gt;sector ticker) &quot;-prices&quot;)
                (:jutsu (indicators/returns-from-open i-state (keyword ticker) (keyword (str live-date)))))
               (Thread/sleep 10)
               (j/update-graph!
                (str (tickers/ticker-&gt;sector ticker) &quot;-volumes&quot;)
                (:jutsu (indicators/cumulative-relative-volume i-state (keyword ticker) (keyword (str live-date)))))
               (Thread/sleep 10)
               (comment
                 (str (tickers/ticker-&gt;sector ticker) &quot;-realprices&quot;)
                 (:jutsu (indicators/l1-price i-state (keyword ticker) (keyword (str live-date)))))
                                        ;(Thread/sleep 10)
               (timbre/debug &quot;Sent update to graph &quot;  (:jutsu (indicators/returns-from-open i-state (keyword ticker) (keyword (str live-date))))))
             (Thread/sleep bardata-frequency-msecs))) (Thread/sleep (* 380 60 1000))
  (doseq [ticker ticker-coll]
    (doseq [date date-coll]
      (reset! (@((i-state (keyword ticker)) (keyword (str date))) :eod?)  true)
 ;(reset! (@((indicator-state (keyword ticker)) (keyword (str date))) :eod-plus-one?)  true)))
  (pprint &quot;Getting EOD Flat...&quot;)
  (pprint &quot;Getting EOD Flat...&quot;)
  (pprint &quot;Getting EOD Flat...&quot;)
  (pprint &quot;Getting EOD Flat...&quot;)
  (pprint &quot;Getting EOD Flat...&quot;)
  (pprint &quot;Getting EOD Flat...&quot;)
  (Thread/sleep (* 3 60 1000))  ;; 3 minutes to get flat
;;raise eod flags to be true
  (shutdown-agents))   ;;end live main</pre></td></tr><tr><td class="docs"><p>end live main
(map class (tickers/recent-dates))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def ticker-coll ["AAPL" "BARD"])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(@(jutsudata/trace-id-map (keyword (tickers/ticker->sector (name :HCP)))) :HCP )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; to send user_msg
  (do
    (def ticker-coll (str/split &quot;SPLK&quot; #&quot;,&quot;))
  ;(def ticker-coll [&quot;AMBA&quot; &quot;PSTG&quot; &quot;SPY&quot; ])
    (def portfolio ticker-coll)
    (def date-coll [20180302])
                                        ;(def a-list (identity agents/a-list-datagen ))
    (def a-list (identity agents/a-list))
    (def agent-states (map #(create-agent-state % ticker-coll date-coll) a-list))
    (def a-list-datagen (identity agents/a-list-datagen))
    (def agent-states-datagen (map #(create-agent-state % ticker-coll date-coll) a-list)) (def i-state (create-indicator-state ticker-coll date-coll))
    (def log-file-name (str utils/HOME &quot;/Dropbox/data/&quot; &quot;test&quot; &quot;.data&quot;))
    (io/delete-file log-file-name :quiet)
    (def datagen-file (str utils/HOME &quot;/Dropbox/data/&quot; &quot;test&quot; &quot;.datagen&quot;))
    (io/delete-file datagen-file :quiet)
    (def datagen? false)
    (pprint portfolio))
                                        ;(pprint &quot;here&quot;)
  (doseq [agent-state agent-states]
    (doseq [this-ticker ticker-coll]
      (doseq [this-date date-coll]
        (let [tic (keyword  this-ticker)
              date (keyword (str this-date))
              agent-listening-to-this-node  @((agent-state tic) date)]
          (pprint (str tic &quot; &quot; date))
                                                ;(add-callback-agent-make-markets log-file-name datagen? i-state agent-listening-to-this-node tic date )
;          (add-callback-agent-follow-trend datagen? i-state agent-listening-to-this-node tic date )
;          (add-callback-agent-fernholz log-file-name datagen? i-state agent-listening-to-this-node tic date )
          ;(add-callback-agent-datagen datagen? i-state agent-listening-to-this-node tic date )
                ;                        (add-callback-agent-cross-sectional log-file-name datagen? i-state agent-listening-to-this-node tic date )
          (add-callback-agent-position-target log-file-name datagen-file datagen? i-state agent-listening-to-this-node tic date))))) (def datagen? true)
  (doseq [agent-state agent-states-datagen]
    (doseq [this-ticker ticker-coll]
      (doseq [this-date date-coll]
        (let [tic (keyword  this-ticker)
              date (keyword (str this-date))
              agent-listening-to-this-node  @((agent-state tic) date)]
          (pprint (str tic &quot;-datagen- &quot; date))
                                                ;(add-callback-agent-make-markets log-file-name datagen? i-state agent-listening-to-this-node tic date )
;          (add-callback-agent-follow-trend datagen? i-state agent-listening-to-this-node tic date )
;          (add-callback-agent-fernholz log-file-name datagen? i-state agent-listening-to-this-node tic date )
          (add-callback-agent-datagen datagen? i-state agent-listening-to-this-node tic date)
                ;                        (add-callback-agent-cross-sectional log-file-name datagen? i-state agent-listening-to-this-node tic date ))))))(comment</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">          )))))(comment
                 (doseq
                  [this-date date-coll]
                   (update-data-quotes-new i-state portfolio this-date)))</pre></td></tr><tr><td class="docs"><p>(identity @tickers/today_int)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(getTradesQuotesNew "AAPL" 20180125 "093000" "103000")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(pprint (count (getTradesQuotesNew-extended ["SPY" "AAPL"] 20180125 )))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def msgs (getTradesQuotes-extended-new (take 2 portfolio) 20171114))
(pprint (take 2 msgs))
(parse-stream-trade-backtest-new i-state (keyword (str 20171114)) (first msgs))
(getTradesQuotes-extended-new-premarket ["AAPL"] 20180202 )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>work for pre market stuff</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(spit "/home/puru/data/bkd.tics"(str/join "\n"(take 2000 (str/split (getTradesQuotes-extended "BKD" 20180222 ) #"\n"))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(["CPRT" -587.4])
(["GKOS" -665.35] ["M" -338.16] ["DDS" 596.87])
IndexOutOfBoundsException   clojure.lang.PersistentVector.arrayFor (PersistentVector.java:158)
()
(["SPLK" 5.46])
ArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:158)
(["DDD" 84.48] ["MU" 14.97] ["EVH" 163.93] ["XL" -222.62])
(["CREE" -152.29] ["BZUN" 1248.67])</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.indicators" name="matrix.indicators"><h1 class="project-name">matrix.indicators</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.indicators
  (:use [bigml.histogram.core])
  (:require (bigml.histogram.test [examples :as ex]))
  (:require
   [matrix.utils :as utils] [matrix.tickers :as tickers]
   [matrix.jutsudata :as jutsudata]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clj-http.client :as client]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [incanter.interpolation :refer :all]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]
                                        ;[interpolation :as interpolation]
];   [matrix.tickers :as tickers]
   [matrix.indicators :as indicators])
  (:use clojure.pprint)
  (:gen-class))</pre></td></tr><tr><td class="docs"><p>idea to decide indicator distribution on the fly</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>return indicator instances on tickers and dates, typically assigned to indicator-state variable</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-indicator-hist
  [tickers] (zipmap (map keyword tickers)
                    (repeatedly (count tickers) create)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def distributions (create-indicator-hist tickers/huge-tickers))
(def distributions-last-return (create-indicator-hist tickers/huge-tickers))</pre></td></tr><tr><td class="docs"><p>(pprint distributions)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>indicator has a header and data, so i know what it is</p>

<p>so this is the function that operates on bar data</p>
</td><td class="codes"><pre class="brush: clojure">(defn returns
  [indicator-state tic date]
  (let [price @(:price-bars @((indicator-state tic) date))]
    (conj (map utils/return-bps-col (partition 2 1 price)) 0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn returns-from-open [indicator-state tic date] (let [price @(:price @((indicator-state tic) date))
                                                         seq-no @(:seq-no @((indicator-state tic) date))
                                                         open @(:open @((indicator-state tic) date))
                                                         indicator-value (utils/return-bps  price open)]
                                                     {:header &quot;returns-from-open&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn returns-from-open-smooth [indicator-state tic date] (let [price-bars @(:price-bars @((indicator-state tic) date))
                                                                pb-smooth (reverse (utils/ema-all 10 (reverse price-bars)))
                                                                open (first pb-smooth)
                                                                indicator-value (utils/return-bps (last price-bars) open)]
                                                            {:header &quot;returns-from-open-smooth&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn returns-from-origin [indicator-state tic date duration] (let [price-bars (take-last duration @(:price-bars @((indicator-state tic) date)))
                                                                    open (first price-bars)
                                                                    indicator-value (utils/return-bps (last price-bars) open)]
                                                                {:header &quot;returns-from-origin&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn recent-returns [indicator-state tic date]  (let [price @(:price-bars @((indicator-state tic) date))
                                                       returns (conj (map utils/return-bps-col (partition 2 1 price)) 0)
                                                       indicator-value (last (map (partial utils/round2 2) (map #(reduce + (take-last 5 (take % returns)))  (range 1 (+ 1 (count returns))))))]
                                                   {:header &quot;recent-returns&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stdev-ema [duration indicator-state tic date] (let [price @(:price-bars @((indicator-state tic) date))
                                                          returns (conj (map utils/return-bps-col (partition 2 1 price)) 0)
                                                          intermediate (utils/ema duration (map #(utils/sd (take-last 5 (take % returns)))  (range 1 (+ 1 (count  returns)))))
                                                          indicator-value (cond (nil? intermediate) Double/NaN :else intermediate)]
                                                      {:header &quot;stdev-ema-20&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn volume-ema [indicator-state tic date] (let [volume @(:volume-bars @((indicator-state tic) date))
                                                  intermediate (utils/ema 20 volume)
                                                  indicator-value (cond (nil? intermediate) Double/NaN :else intermediate)]
                                              {:header &quot;volume-ema-20&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn price-ema [duration indicator-state tic date]
  (let [prices @(:price-bars @((indicator-state tic) date))
        indicator-value
        (cond (nil? (utils/ema duration prices)) Double/NaN :else
              (utils/ema duration prices))]
    {:header (str &quot;price-ema-&quot; duration) :data indicator-value}))</pre></td></tr><tr><td class="docs"><p>yes only if dispersion is moving, not if flat</p>
</td><td class="codes"><pre class="brush: clojure">(defn moving-dispersion
  [indicator-state tic date]
  (let [dispersion @(:dispersion-bars @((indicator-state tic) date))
        indicator-value
        (cond (&lt; (count dispersion) 2) 0 :else (- (last dispersion) (last (drop-last dispersion))))]
    {:header &quot;moving-dispersion&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pseudo-price-ema [duration indicator-state tic date]
  (let [prices @(:price-bars @((indicator-state tic) date))
        opens (repeat (count prices) @(:open @((indicator-state tic) date)))
        pseudo-prices (map utils/return-bps prices opens)
        indicator-value
        (cond (nil? (utils/ema duration pseudo-prices)) Double/NaN :else
              (utils/ema duration pseudo-prices))]
    {:header (str &quot;pseudo-price-ema-&quot; duration) :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn returns-quality [duration indicator-state tic date]
  (let [prices (take-last duration @(:price-bars @((indicator-state tic) date)))
        returns (conj (map utils/return-bps-col (partition 2 1 prices)) 0)
        indicator-value (first (utils/pnl-sharpe (map utils/sign returns)))]
    {:header &quot;returns-quality&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bidask [indicator-state tic date]
  (let [askprice @(:askprice @((indicator-state tic) date))
        bidprice @(:bidprice @((indicator-state tic) date)) indicator-value (apply max [0.20 (- askprice bidprice)])]
    {:header &quot;bidask&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs"><p>takes a coll and tranforms to psedusdo price in bps</p>
</td><td class="codes"><pre class="brush: clojure">(defn p-&gt;pseudo
  [p]
  (cond (empty? p) nil :else (let [opens (repeat (count p) (first p))
                                   pseudo-prices (map utils/return-bps p opens)]
                               pseudo-prices)))</pre></td></tr><tr><td class="docs"><p>fit lm model to last N points and report slope value</p>
</td><td class="codes"><pre class="brush: clojure">(defn linear-regression-slope
  [cutoff indicator-state tic date]
  (let [prices @(:price-bars @((indicator-state tic) date))
      ;prices-ema
      ;(comment (nil? (utils/ema duration prices )) Double/NaN :else (utils/ema duration prices ))
        prices-nonan (filter #(not (Double/isNaN %)) prices)
        N (count prices-nonan)
        indicator-value
        (cond (&gt;= N cutoff)  ;; atleast 20+12 data points (32 mins)
              (let [points (reverse (take-last cutoff prices-nonan))
                    points-pseudo (p-&gt;pseudo points)
                    points-lm (map vector points-pseudo (range cutoff))
                    lm-slope (first (:coefs
                                     (stats/linear-model
                                      (map first points-lm)
                                      (map second points-lm)
                                      :intercept false)))]
                (- lm-slope))
              :else
              (identity Double/NaN))]
  ;(if (not (Double/isNaN indicator-value)) (insert! (tic distributions) indicator-value )  )
    {:header &quot;linear-regression-slope&quot; :data indicator-value :distribution (tic distributions)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sharpe-from-distribution [indicator-state tic date]
  (let [dist (tic distributions)
        m (median dist)
        v (variance dist)
        sharpe (cond (or (nil? v) (zero? v)) 0.0 :else (/ m v))
        indicator-value (utils/round sharpe)]
    {:header &quot;sharpe-from-distribution&quot;  :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lm-zscore [indicator-state tic date]
  (let [dist (tic distributions)
        value (:data (linear-regression-slope 10 indicator-state tic date))
        m (median dist)
        v (incanter/sqrt (variance dist))
        zscore (cond (or (nil? v) (zero? v)) 0.0 :else (/ (- value m) v))
        indicator-value (utils/round zscore)]
    {:header &quot;lm-zscore&quot;  :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn variance-from-distribution [indicator-state tic date]
  (let [dist (tic distributions)
        m (median dist)
        v (variance dist)
        v-clean (cond (or (nil? v) (zero? v)) 0.0 :else v)
        indicator-value (utils/round v-clean)]
    {:header &quot;variance-from-distribution&quot;  :data indicator-value}))</pre></td></tr><tr><td class="docs"><p>(insert! (:BUD distributions) Double/NaN )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>fit lm model to last N points and report slope value</p>
</td><td class="codes"><pre class="brush: clojure">(defn linear-regression-slope-diff
  [indicator-state tic date]
  (let [prices @(:price-bars @((indicator-state tic) date))
        prices-nonan (filter #(not (Double/isNaN %)) prices)
        N (count prices-nonan)
        indicator-value
        (cond (&gt;= N 5)  ;; atleast 20+12 data points (32 mins)
              (let [cutoff N
                    points (reverse prices-nonan)
                    points-pseudo (p-&gt;pseudo points)
                    points-lm (map vector points-pseudo (range cutoff))
                    lm-slope (first (:coefs
                                     (stats/linear-model
                                      (map first points-lm)
                                      (map second points-lm)
                                      :intercept false)))
                    points-prev (reverse (drop-last prices-nonan))
                    points-pseudo-prev (p-&gt;pseudo points-prev)
                    points-lm-prev (map vector points-pseudo-prev (range cutoff))
                    lm-slope-prev (first (:coefs
                                          (stats/linear-model
                                           (map first points-lm-prev)
                                           (map second points-lm-prev)
                                           :intercept false)))]
                (- lm-slope-prev lm-slope))
              :else
              (identity Double/NaN))]
    {:header (str &quot;linear-regression-slope-diff-&quot; (name tic)) :data indicator-value}))</pre></td></tr><tr><td class="docs"><p>high r2, slope negative, and slope diff >
0.75 length 100 for lm-diff
0.96 length for r-square</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn returns-from-open-zscore [indicator-state tic date portfolio duration] (let [all-returns (map #(:data (returns-from-origin indicator-state % date duration)) (map keyword portfolio))
                                                                                   this-return (:data (returns-from-origin indicator-state tic date duration))
                                                                                   indicator-value (utils/zscore2 this-return all-returns)]
                                                                               {:header &quot;returns-from-open-zscore&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def capital 1000000)
(defn allocation [price] (utils/round (/ (/ capital 40) price)))</pre></td></tr><tr><td class="docs"><p>what is target inventory for equal portfolio</p>
</td><td class="codes"><pre class="brush: clojure">(defn fernholz-target
  [when-to-peg indicator-state tic date]
  (let [prices @(:price-bars @((indicator-state tic) date))
        fernholz-inventories (map allocation prices)
        indicator-value (cond (&lt;= (count prices) when-to-peg) Double/NaN
                              :else (let [starting-position (nth fernholz-inventories when-to-peg)]
                                      (- (last fernholz-inventories) starting-position)))]
    {:header &quot;fernholz-target&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment fernholz-target-2
         &quot;what is target inventory for equal portfolio&quot;
         [indicator-state tic date]
         (let [prices @(:price-bars @((indicator-state tic) date))
               fernholz-inventories (map allocation prices)
               indicator-value (cond (&lt;= (count prices) when-to-peg) Double/NaN
                                     :else (let [starting-position (nth fernholz-inventories when-to-peg)]
                                             (- (last fernholz-inventories) starting-position)))]
           {:header &quot;fernholz-target&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn cumulative-relative-volume [indicator-state tic date] (let [volume @(:volume-bars @((indicator-state tic) date))
                                                                  seq-no @(:seq-no @((indicator-state tic) date))
                                                                  adj-factor (/ 390 (+ 1 seq-no))
                                                                  avg-volume-per-day (stats/mean (:v (tickers/ohlcv (name tic))))
                                                                  indicator-value (cond (nil? avg-volume-per-day) Double/NaN :else
                                                                                        (* adj-factor (reduce + (map #(/ % avg-volume-per-day) volume))))] {:header &quot;cumulative-relative-volume&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn l1-price [indicator-state tic date] (let [indicator-value @(:price @((indicator-state tic) date))
                                                seq-no @(:seq-no @((indicator-state tic) date))] {:header &quot;l1-price&quot;
                                                                                                  :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ticker-time [indicator-state tic date] (let [indicator-value @(:time @((indicator-state tic) date))] {:header &quot;ticker-time&quot;
                                                                                                            :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn l1-volume [indicator-state tic date] (let [indicator-value @(:volume @((indicator-state tic) date))] {:header &quot;l1-volume&quot;
                                                                                                            :data indicator-value}))</pre></td></tr><tr><td class="docs"><p>inverse of time diff, large means someone is trading actively</p>
</td><td class="codes"><pre class="brush: clojure">(defn trade-time-lapse
  [indicator-state tic date]
  (let [ttl @(:trade-time-lapse @((indicator-state tic) date))
        indicator-value (cond (zero? ttl) 0.0
                              :else (/ 1 ttl))]
    {:header &quot;trade-time-lapse&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn autocorr [indicator-state tic date] (let [prices @(:price-bars @((indicator-state tic) date))
                                                lag-prices (utils/lag 1 prices)
                                                diff  (rest (map - prices lag-prices))
                                                indicator-value (cond (&lt; (count diff) 2)  Double/NaN :else
                                                                      ;(last diff)
                                                                      (stats/correlation (drop-last diff) (rest diff)))]
                                            {:header &quot;autocorr&quot; :data (utils/round2 4 indicator-value)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-return [duration indicator-state tic date] (let [prices @(:price-bars @((indicator-state tic) date))
                                                            lag-prices (utils/lag 1 prices)
                                                            diff  (rest (map - prices lag-prices))
                                                            indicator-value (cond (&lt; (count diff) duration)  Double/NaN :else
                                                                                  ;(- (last prices) (last (drop-last prices)))
                                                                                  (reduce + (take-last duration diff)))] {:header &quot;last-return&quot; :data (utils/round2 4 indicator-value)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-return-zscore [indicator-state tic date]
  (let [dist (tic distributions-last-return)
        value (:data (last-return indicator-state tic date))
        m (median dist)
        v (incanter/sqrt (variance dist))
        zscore (cond (or (nil? v) (zero? v)) 0.0 :else (/ (- value m) v))
        indicator-value (utils/round zscore)]
    {:header &quot;last-return-zscore&quot;  :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn simple-trend [duration indicator-state tic date]
  (let [prices @(:price-bars @((indicator-state tic) date))
        opens (repeat (count prices) @(:open @((indicator-state tic) date)))
        pprices (utils/csum (map utils/return-bps prices opens)) indicator-value
        (cond (nil? (utils/ema duration pprices)) Double/NaN :else
              (- (last pprices) (utils/ema duration pprices)))]
    {:header (str &quot;simple-trend-&quot; duration) :data (utils/round indicator-value)}))
(defn position-to-take [capital indicator-state tic date]
  (let [price @(:price @((indicator-state tic) date))
        value (cond (zero? price) 0 :else (utils/round2 0 (/ capital price))) indicator-value
        (cond (nil? value) Double/NaN :else
              value)]
    {:header (str &quot;position-to-take&quot;) :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pnl-indicator [indicator-state tic date]
  (let [pnl @(:pnl @((indicator-state tic) date))
        indicator-value
        (cond (nil? pnl) Double/NaN :else
              pnl)]
    {:header (str &quot;pnl-indicator&quot;) :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stdev-price [duration indicator-state tic date] (let [price @(:price-bars @((indicator-state tic) date))
                                                            rel-prices (take-last duration price)
                                                            intermediate (stats/sd rel-prices)
                                                            indicator-value (cond (or (&lt; (count rel-prices) duration) (nil? intermediate)) Double/NaN :else intermediate)]
                                                        {:header &quot;stdev-price&quot; :data indicator-value}))</pre></td></tr><tr><td class="docs"><p>fit lm model to last N points and report slope value</p>
</td><td class="codes"><pre class="brush: clojure">(defn r-square
  [indicator-state tic date]
  (let [prices (reverse @(:price-bars @((indicator-state tic) date)))
      ;prices-ema
      ;(comment (nil? (utils/ema duration prices )) Double/NaN :else (utils/ema duration prices ))
        prices-nonan (filter #(not (Double/isNaN %)) prices)
        N (count prices-nonan)
        indicator-value
        (cond (&gt;= N 5)  ;; atleast 20+12 data points (32 mins)
              (let [points prices-nonan
                    points-pseudo (p-&gt;pseudo points)
                    points-lm (map vector points-pseudo (range N))
                    r2 (:r-square
                        (stats/linear-model
                         (map first points-lm)
                         (map second points-lm)))]
                r2)
              :else
              (identity Double/NaN))]
    {:header  (str &quot;r-square-&quot; (name tic)) :data indicator-value}))</pre></td></tr><tr><td class="docs"><p>fit lm model to last N points and report slope value, reverses price series</p>
</td><td class="codes"><pre class="brush: clojure">(defn lm-intercept-slope
  [indicator-state tic date]
  (let [prices @(:price-bars @((indicator-state tic) date))
      ;prices-ema
      ;(comment (nil? (utils/ema duration prices )) Double/NaN :else (utils/ema duration prices ))
        prices-nonan (filter #(not (Double/isNaN %)) prices)
        N (count prices-nonan)
        indicator-value
        (cond (&gt;= N 5)  ;; atleast 20+12 data points (32 mins)
              (let [points (reverse prices-nonan)
                    points-pseudo (p-&gt;pseudo points)
                    points-lm (map vector points-pseudo (range N))
                    coefs (:coefs
                           (stats/linear-model
                            (map first points-lm)
                            (map second points-lm)
                            :intercept false))]
                (- (first coefs))
              ;coefs)
              :else
              (identity Double/NaN))]
    {:header (str &quot;lm-intercept-slope-&quot; (name tic)) :data indicator-value}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment

  #(and (&gt; (:data (r-square i-state (keyword %) :20180319)) 0.96)
        (&gt; (:data (linear-regression-slope-diff i-state (keyword %) :20180319)) 0.50)) ticker-coll)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.neuralnet" name="matrix.neuralnet"><h1 class="project-name">matrix.neuralnet</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.neuralnet
  (:require
   [matrix.utils :as utils]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clj-http.client :as client]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [incanter.interpolation :refer :all]
   [matrix.train :as train]
   [cortex.nn.execute :as execute]
   [cortex.nn.layers :as layers]
   [cortex.nn.network :as network]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]
    ;[interpolation :as interpolation]
])
  (:use clojure.pprint)
  (:gen-class))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def trade-dataset (io2/read-dataset &quot;/home/puru/Dropbox/data/regdata.csv&quot; :header false :delim \space))
(incanter$/$ :col0 trade-dataset)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(incanter$/$ [:col0 :col1]  trade-dataset)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def trade-dataset (str/split (slurp &quot;/home/puru/Dropbox/data/regdata.csv&quot;) #&quot;\n&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(read-string (first (str/split (first trade-dataset) #&quot; &quot;)))
(map read-string (rest (str/split (first trade-dataset) #&quot; &quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-dataset [trade-dataset-line] {:y [(read-string (first (str/split trade-dataset-line #&quot; &quot;)))] :x (vec (map read-string (rest (str/split trade-dataset-line #&quot; &quot;))))})
(def xor-dataset (map create-dataset trade-dataset))
(first xor-dataset)
(def xor-dataset
  [{:x [0.0 0.0] :y [0.0]}
   {:x [0.0 1.0] :y [1.0]}
   {:x [1.0 0.0] :y [1.0]}
   {:x [1.0 1.0] :y [0.0]}])</pre></td></tr><tr><td class="docs"><p>Definition of the neural network</p>
</td><td class="codes"><pre class="brush: clojure">(def nn
  (network/linear-network
   [(layers/input 8 1 1 :id :x) ;; input :x 2*1 dimensions
    (layers/linear-&gt;tanh 10)
    (layers/linear-&gt;tanh 15)
    (layers/linear-&gt;tanh 10)
    (layers/linear 1 :id :y)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn train-xor []
  (let [trained (train/train-n nn xor-dataset xor-dataset
                               :batch-size 4
                               :epoch-count 100
                               :simple-loss-print? true)]
    (println &quot;\nXOR results before training:&quot;)
    (clojure.pprint/pprint (execute/run nn xor-dataset))
    (println &quot;\nXOR results after training:&quot;)
    (clojure.pprint/pprint (execute/run trained xor-dataset))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(train-xor)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.train" name="matrix.train"><h1 class="project-name">matrix.train</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.train
  (:require [clojure.java.io :as io]
            [think.parallel.core :as parallel]
            [cortex.optimize :as opt]
            [cortex.optimize.adam :as adam]
            [cortex.nn.execute :as execute]
            [cortex.nn.compute-binding :as compute-binding]
            [cortex.nn.network :as network]
            [cortex.nn.traverse :as traverse]
            [cortex.graph :as graph]
            [cortex.util :as util]
            [cortex.loss.core :as loss])
  (:import [java.io File]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-network-filestem &quot;trained-network&quot;)
(def trained-networks-folder &quot;trained-networks/&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>Loads a map of {:cv-loss :network-description}.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-network
  [network-filename]
  (if (.exists (io/file network-filename))
    (util/read-nippy-file network-filename)
    (throw (ex-info &quot;Saved network not found.&quot; {:filename network-filename}))))</pre></td></tr><tr><td class="docs"><p>Saves a trained network out to the filesystem.</p>
</td><td class="codes"><pre class="brush: clojure">(defn save-network
  [network network-filename]
  (util/write-nippy-file network-filename network)
  network)</pre></td></tr><tr><td class="docs"><p>returns the predicted labels for the given network and dataset</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-labels
  ([new-network  batch-size test-ds]
   (execute/run new-network test-ds
                :batch-size batch-size
                :loss-outputs? true))
  ([new-network  batch-size context test-ds]
   (execute/run new-network test-ds
                :batch-size batch-size :context context
                :loss-outputs? true)))</pre></td></tr><tr><td class="docs"><p>calculate the loss on the given network and dataset. Returns a map with
  the raw loss (per label)  and the sum of loss for all labels</p>
</td><td class="codes"><pre class="brush: clojure">(defn network-loss
  [new-network labels test-ds]
  (let [loss-fn (execute/execute-loss-fn new-network labels test-ds)]
    {:raw-loss loss-fn :loss-sum (apply + (map :value loss-fn))}))</pre></td></tr><tr><td class="docs"><p>Evaluate the network using its current loss terms</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-network-loss-eval-fn
  [simple-loss-print? new-network test-ds batch-size]
  (let [labels (get-labels new-network batch-size test-ds)
        {:keys [raw-loss loss-sum]} (network-loss new-network labels test-ds)]
    (when-not simple-loss-print?
      (println (loss/loss-fn-&gt;table-str raw-loss)))
    loss-sum))</pre></td></tr><tr><td class="docs"><p>Test functions take two map arguments, one with global information and one
  with information local to the epoch. The job of a test function is to return a
  map indicating if the new network is indeed the best one and the network with
  enough information added to make comparing networks possible.
    {:best-network? boolean
     :network (assoc new-network :whatever information-needed-to-compare).}</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-network-test-fn
  ;; TODO: No need for context here.
  [loss-val-fn
   loss-compare-fn
   ;; global arguments
   {:keys [batch-size context]}
   ;per-epoch arguments
   {:keys [new-network old-network test-ds]}]
  (let [batch-size (long batch-size)
        loss-val (double (loss-val-fn new-network test-ds batch-size))
        current-best-loss (if-let [best-loss (get old-network :cv-loss)]
                            (if (sequential? best-loss)
                              (apply + (map :value best-loss))
                              (try
                                (double best-loss)
                                (catch Throwable e
                                  nil))))
        best-network? (or (nil? current-best-loss)
                          (loss-compare-fn (double loss-val)
                                           (double current-best-loss)))
        updated-network (assoc new-network :cv-loss (if best-network?
                                                      loss-val
                                                      current-best-loss))
        epoch (get new-network :epoch-count)]
    (println (format &quot;Loss for epoch %3d: (current) %.8f (best) %.8f%s&quot;
                     epoch loss-val current-best-loss
                     (if best-network? &quot; [new best]&quot; &quot;&quot;)))
    {:best-network? best-network?
     :network updated-network}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- per-epoch-fn
  [test-fn network-filename training-context epoch-args]
  (let [test-results (test-fn training-context epoch-args)]
    (when (:best-network? test-results)
      (save-network (:network test-results) network-filename))
    (:network test-results)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn backup-trained-network
  [network-filestem]
  (let [network-filename (str network-filestem &quot;.nippy&quot;)]
    (when (.exists (io/file network-filename))
      (let [backup-filename (-&gt;&gt; (rest (range))
                                 (map #(format &quot;%s%s-%s.nippy&quot; trained-networks-folder network-filestem %))
                                 (remove #(.exists (io/file %)))
                                 (first))]
        (io/make-parents backup-filename)
        (io/copy (io/file network-filename)
                 (io/file backup-filename))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- create-n-callable-fn
  [src-fn max-call-count]
  (if max-call-count
    (let [counter (atom 0)
          max-call-count (long max-call-count)]
      (fn []
        (when (&lt; @counter max-call-count)
          (swap! counter inc)
          (src-fn))))
    src-fn))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- to-epoch-seq-fn
  [item epoch-count]
  (if-not (fn? item)
    (parallel/create-next-item-fn
     (let [retval (if (map? (first item))
                    (repeat item)
                    item)]
       (if epoch-count
         (take epoch-count retval)
         retval)))
    (create-n-callable-fn item epoch-count)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- recur-train-network
  [network train-ds-fn test-ds-fn optimizer train-fn epoch-eval-fn]
  ;[{:keys [network train-ds-fn test-ds-fn optimizer train-fn epoch-eval-fn] :as recur-args}]
  (let [train-data (train-ds-fn)
        test-data (test-ds-fn)
        old-network network]
    (when (and train-data test-data)
      (let [{:keys [network optimizer]} (train-fn network train-data optimizer)
            epoch-args {:new-network (update network :epoch-count inc)
                        :old-network old-network :train-ds train-data
                        :test-ds test-data}
            network (epoch-eval-fn epoch-args)]
        (cons network
              (lazy-seq
               (recur-train-network network train-ds-fn test-ds-fn
                                    optimizer train-fn epoch-eval-fn)))))))</pre></td></tr><tr><td class="docs"><p>Given a network description, start training from scratch or given a trained
  network continue training. Keeps track of networks that are actually improving
  against a test-ds.</p>

<p>  Networks are saved with a <code>:cv-loss</code> that is set to the best cv loss so far.</p>

<p>  This system expects a dataset with online data augmentation so that it is
  effectively infinite although the cross-validation and holdout sets do not
  change. By default, the best network is saved to: <code>trained-network.nippy</code></p>

<p>  Note, we have to have enough memory to store the cross-validation dataset
  in memory while training.</p>

<p>  Every epoch a test function is called with these 2 map arguments:</p>

<p>  (test-fn global-context epoch-context)</p>

<p>  It must return a map containing at least:
    {:best-network? true if this is the best network
     :network The new network with any extra information needed for comparison assoc'd onto it.}</p>

<p>  If epoch-count is provided then we stop training after that many epochs else
  we continue to train forever.</p>
</td><td class="codes"><pre class="brush: clojure">(defn train-n
  [network train-ds test-ds
   &amp; {:keys [batch-size epoch-count
             network-filestem
             optimizer
             reset-score
             force-gpu?
             simple-loss-print?
             test-fn
             context]
      :or {batch-size 128
           network-filestem default-network-filestem
           reset-score false}}]
  (let [context (or context (execute/compute-context))]
    (execute/with-compute-context context
      (let [optimizer (or optimizer (adam/adam))
            context (execute/compute-context)
            network-filename (str network-filestem &quot;.nippy&quot;)
            ;; If someone is training with an infinite data sequence they have to
            ;; actually pass in a function that when called returns the next epoch
            ;; of data.  This is the only way so far to avoid 'holding onto head'
            ;; when the number of epochs rises.
            train-ds-fn (to-epoch-seq-fn train-ds epoch-count)
            test-ds-fn (to-epoch-seq-fn test-ds epoch-count)
            network (if (vector? network)
                      (do
                        (backup-trained-network network-filestem)
                        (network/linear-network network))
                      (if reset-score
                        (assoc network :cv-loss {})
                        network))
            network (if (number? (get network :epoch-count))
                      network
                      (assoc network :epoch-count 0))
            train-fn #(execute/train %1 %2
                                     :batch-size batch-size
                                     :optimizer %3
                                     :context context)
            training-context {:batch-size batch-size :context context}
            test-fn  (or test-fn
                         ;;Normally if the loss goes down then this is the best network
                         (partial default-network-test-fn (partial default-network-loss-eval-fn simple-loss-print?) &lt;))
            epoch-eval-fn (partial per-epoch-fn test-fn network-filename training-context)]
        (println &quot;Training network:&quot;)
        (network/print-layer-summary network (traverse/training-traversal network))
        (-&gt;&gt; (recur-train-network network train-ds-fn test-ds-fn optimizer train-fn epoch-eval-fn)
             last)))))</pre></td></tr><tr><td class="docs"><p>Prints a summary of the different networks trained so far.
  Respects an (optional) <code>network-filestem</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-trained-networks-summary
  [&amp; {:keys [network-filestem
             cv-loss-&gt;number
             cv-loss-display-precision
             extra-keys]
      :or {network-filestem default-network-filestem
           cv-loss-&gt;number #(apply + (vals %))
           cv-loss-display-precision 3}}]
  (let [cv-loss-format-string (format &quot;%%.%sf&quot; cv-loss-display-precision)]
    (-&gt;&gt; trained-networks-folder
         io/file
         file-seq
         (filter #(let [n (.getPath ^File %)]
                    (and (.contains ^String n (.concat ^String trained-networks-folder
                                                       ^String network-filestem))
                         (.endsWith ^String n &quot;.nippy&quot;))))
         (map (fn [f] [f (util/read-nippy-file f)]))
         (map (fn [[f network]] (assoc network :filename (.getName ^File f))))
         (map (fn [network] (update network :cv-loss cv-loss-&gt;number)))
         (sort-by :cv-loss)
         (map (fn [network] (update network :cv-loss #(format cv-loss-format-string %))))
         (clojure.pprint/print-table (concat [:filename :cv-loss :parameter-count] extra-keys)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.core" name="matrix.core"><h1 class="project-name">matrix.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.core
  (:gen-class))</pre></td></tr><tr><td class="docs"><p>I don't do a whole lot ... yet.</p>
</td><td class="codes"><pre class="brush: clojure">(comment (defn -main
           [&amp; args]
           (println &quot;Hello, World!&quot;)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.agents" name="matrix.agents"><h1 class="project-name">matrix.agents</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.agents (:require
                   [matrix.utils :as utils]
                   [matrix.indicators :as indicators]
                   [matrix.jutsudata :as jutsudata]
                   [matrix.tickers :as tickers]
                   [clojure.java.io :as io]
                   [clojure.string :as str]
                   [clj-http.client :as client]
                   [clj-time.format :as tf]
                   [clj-time.core :as tt]
                   [incanter.interpolation :refer :all]
                   [incanter [core :refer [$]
                              :as incanter$]
                    [core :as incanter]
                    [stats :as stats]
                    [io :as io2]
                    [charts :as charts]
                    [datasets :as dataset]
                                        ;[interpolation :as interpolation]
]
                   [trees.models :as models]
                   [trees.dostuff :refer [learn classify]] [matrix.tickers :as tickers])
    (:use clojure.pprint))</pre></td></tr><tr><td class="docs"><p>(identity models/iris-tree-model1)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>simple strat that enters here exits there, no parameters</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-1
  []
  (atom {;; dispersion larger than 100 bps
      ;; dispersion not constant
      ;; ttc exit
         ;; ema diff positive
         ;;consolidated signal to [long-entry short-entry] booleans
         :entry
         #(let [indicator-state %1
                tic %2
                date %3
                i5 (:data (indicators/price-ema 5 indicator-state tic date))
                i6 (:data (indicators/price-ema 26 indicator-state tic date))
                i8 (:data (indicators/moving-dispersion indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))]
            [(and
              (&gt; dispersion 100.0)
              (not (zero? i8))
              (pos? (- i5 i6)))
             (and
              (&gt; dispersion 100.0)
              (not (zero? i8))
              (neg? (- i5 i6)))])
         :pnl-target-bps 50
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps nil
         :n-trades (atom 0.0)
         :max-n-trades 1.0 ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name &quot;Trooper&quot;
         :max-ttc-minutes 40.0
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           i1 (indicators/returns-from-open indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema 5 indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                           i10 (indicators/returns-quality indicator-state tic date) dispersion @(:dispersion @((indicator-state tic) date)) price @(:price @((indicator-state tic) date))
                           time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                       {:header
                        [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i9) (:header i10)]
                        :data [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i9) (:data i10)]})}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-2
  [rr stdev pnl-target]
  (atom {:long-entry
         #(let [indicator-state %1
                tic %2
                date %3] (and (&gt; (:data (indicators/recent-returns indicator-state tic date)) rr)
                              (&lt; (:data (indicators/stdev-ema indicator-state tic date)) stdev)))
         :short-entry
         #(let [indicator-state %1
                tic %2
                date %3] (and (:data (&lt; (indicators/recent-returns indicator-state tic date) (- rr)))
                              (&lt; (:data (indicators/stdev-ema indicator-state tic date)) stdev)))
         :pnl-target pnl-target
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps 50.00}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-3
  [D zpp draw max-ttc rq]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i8 (:data (indicators/moving-dispersion indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
                i5 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i6 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                i7 (:data (indicators/returns-quality indicator-state tic date))]
            [(and
              (&gt; dispersion D)
              (not (zero? i8))
              (&gt;= (- i5 i6) zpp)
              (&gt;= i7 rq)  ;; returns quality threshold)
             (and
              (&gt; dispersion D)
              (not (zero? i8))
              (&lt;= (- i5 i6) (- zpp))
              (&lt;= i7 (- rq)) ;; returns quality threshold)])
         :pnl-target-bps nil
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps draw
         :n-trades (atom 0.0)
         :max-n-trades 10.0 ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes max-ttc
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           i1 (indicators/returns-from-open indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                           i10 (indicators/returns-quality indicator-state tic date)
                           dispersion @(:dispersion @((indicator-state tic) date))
                           price @(:price @((indicator-state tic) date))
                           time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                       {:header
                        [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i9) (:header i10)]
                        :data
                        [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i9) (:data i10)]})}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-4-profit-taker
  [zpp rq pnl-target-bps max-n-trades]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i8 (:data (indicators/moving-dispersion indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
                i5 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i6 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                i7 (:data (indicators/returns-quality indicator-state tic date))]
            [(and
              (&gt; dispersion 100)
              (not (zero? i8))
              (&gt;= (- i5 i6) zpp)
              (&gt;= i7 rq)  ;; returns quality threshold)
             (and
              (&gt; dispersion 100)
              (not (zero? i8))
              (&lt;= (- i5 i6) (- zpp))
              (&lt;= i7 (- rq)) ;; returns quality threshold)])
         :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps 500
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 60
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           i1 (indicators/returns-from-open indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                           i10 (indicators/returns-quality indicator-state tic date)
                           dispersion @(:dispersion @((indicator-state tic) date))
                           price @(:price @((indicator-state tic) date))
                           time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                       {:header
                        [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i9) (:header i10)]
                        :data
                        [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i9) (:data i10)]})}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
dispersion limited and not moving
high zpp enter short
returns quality poor
pnl bps target small</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-5-k-filter
  [zpp rq pnl-target-bps]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i8 (:data (indicators/moving-dispersion indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
                i5 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i6 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                i7 (:data (indicators/returns-quality indicator-state tic date))]
            [(and
              (&lt; dispersion 200)
              (zero? i8)
              (&lt;= (- i5 i6) (- zpp))
              (&lt;= i7 rq)  ;; returns quality threshold)
             (and
              (&lt; dispersion 200)
              (zero? i8)
              (&gt;= (- i5 i6) zpp)
              (&lt;= i7 rq)  ;; returns quality threshold)])
         :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps 500
         :n-trades (atom 0.0)
         :max-n-trades 10.0 ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 60
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           i1 (indicators/returns-from-open indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                           i10 (indicators/returns-quality indicator-state tic date)
                           dispersion @(:dispersion @((indicator-state tic) date))
                           price @(:price @((indicator-state tic) date))
                           time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                       {:header
                        [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i9) (:header i10)]
                        :data
                        [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i9) (:data i10)]})}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-6-rare-trader
  [zpp dd-bps]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i8 (:data (indicators/moving-dispersion indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
                i5 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i6 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                i7 (:data (indicators/returns-quality indicator-state tic date))]
            [(and
              (&gt; dispersion 300)
              (not (zero? i8))
              (&gt;= (- i5 i6) zpp)
              (&gt;= i7 0.30)  ;; returns quality threshold)
             (and
              (&gt; dispersion 300)
              (not (zero? i8))
              (&lt;= (- i5 i6) (- zpp))
              (&lt;= i7 (- 0.30)) ;; returns quality threshold)])
         :pnl-target-bps nil
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps dd-bps
         :n-trades (atom 0.0)
         :max-n-trades 1.0 ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 300
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           i1 (indicators/returns-from-open indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                           i10 (indicators/returns-quality indicator-state tic date)
                           dispersion @(:dispersion @((indicator-state tic) date))
                           price @(:price @((indicator-state tic) date))
                           time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                       {:header
                        [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i9) (:header i10)]
                        :data
                        [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i9) (:data i10)]})}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-7-returns-quality-mr
  [zpp pnl-target-bps r-o max-n-trades agent-name]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i9 (incanter/abs (:data (indicators/returns-from-open indicator-state tic date)))
                i7 (- (/ (:data (indicators/returns-quality indicator-state tic date)) 0.15))]
            [(and
              (&gt;= i9 r-o)
              (&gt;= i7 zpp) ;; returns quality threshold)
             (and
              (&gt;= i9 r-o)
              (&lt;= i7 (- zpp)) ;; returns quality threshold)])
         :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps 500
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name agent-name
         :max-ttc-minutes 60
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           i1 (indicators/returns-from-open indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                           i10 (indicators/returns-quality indicator-state tic date)
                           i11 (- (/ (:data (indicators/returns-quality indicator-state tic date)) 0.15))
                           long-signal   (cond (and
                                                (&gt;= (incanter/abs (:data i1)) r-o)
                                                (&gt;= i11 zpp) ;; returns quality threshold)1 :else 0)
                           short-signal (cond (and
                                               (&gt;= (incanter/abs (:data i9)) r-o)
                                               (&lt;= i11 (- zpp)) ;; returns quality threshold)1 :else 0) dispersion @(:dispersion @((indicator-state tic) date))
                           price @(:price @((indicator-state tic) date))
                           time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                       {:header
                        [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i9) (:header i10) &quot;i11&quot; &quot;long-signal&quot; &quot;short-signal&quot;]
                        :data
                        [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i9) (:data i10) i11 long-signal short-signal]})}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-7-returns-quality-trend
  [zpp pnl-target-bps r-o max-n-trades agent-name]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i9 (incanter/abs (:data (indicators/returns-from-open indicator-state tic date)))
                i7 (/ (:data (indicators/returns-quality indicator-state tic date)) 0.15)]
            [(and
              (&gt;= i9 r-o)
              (&gt;= i7 zpp) ;; returns quality threshold)
             (and
              (&gt;= i9 r-o)
              (&lt;= i7 (- zpp)) ;; returns quality threshold)])
         :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps 500
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name agent-name
         :max-ttc-minutes 60
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           i1 (indicators/returns-from-open indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                           i10 (indicators/returns-quality indicator-state tic date)
                           i11 (- (/ (:data (indicators/returns-quality indicator-state tic date)) 0.15))
                           long-signal   (cond (and
                                                (&gt;= (incanter/abs (:data i1)) r-o)
                                                (&gt;= i11 zpp) ;; returns quality threshold)1 :else 0)
                           short-signal (cond (and
                                               (&gt;= (incanter/abs (:data i9)) r-o)
                                               (&lt;= i11 (- zpp)) ;; returns quality threshold)1 :else 0) dispersion @(:dispersion @((indicator-state tic) date))
                           price @(:price @((indicator-state tic) date))
                           time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                       {:header
                        [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i9) (:header i10) &quot;i11&quot; &quot;long-signal&quot; &quot;short-signal&quot;]
                        :data
                        [(name date) time (name tic) price (:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i9) (:data i10) i11 long-signal short-signal]})}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-8-lm
  [zpp pnl-target-bps max-n-trades]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (incanter/abs (:data (indicators/returns-from-open indicator-state tic date)))
                i2 (:data (indicators/recent-returns indicator-state tic date))
                i3 (:data (indicators/stdev-ema indicator-state tic date))
                i4 (:data (indicators/volume-ema indicator-state tic date))
                i5 (:data (indicators/price-ema 5 indicator-state tic date))
                i6 (:data (indicators/price-ema 12 indicator-state tic date))
                i7 (:data (indicators/price-ema 26 indicator-state tic date))
                i8 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i9 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                bidask (:data (indicators/bidask indicator-state tic date))
                emadiff (- i8 i9)
                i10 (:data (indicators/returns-quality indicator-state tic date))
                signal (reduce + (map * [i10 bidask emadiff] [-0.0001 8.69 -0.002]))
;returns-from-open              bidask             emadiff
;-8e-06        0.45       -1e-04
]
            [(and
              (&gt;= i1 650)
              (&gt;= signal zpp))
             (and
              (&gt;= i1 650)
              (&lt;= signal (- zpp)))])
         :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps 500
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 60
         :datagen nil}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn header-fn [x] (:header x))
(defn data-fn [x] (:data x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn agent-9-datagen
  []
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3]
            [false false])
         :pnl-target-bps 100
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-draw-bps 500
         :n-trades (atom 0.0)
         :max-n-trades 1 ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name &quot;datagen&quot;
         :max-ttc-minutes 60
         :max-pnl-this-round (atom (- 99.0))
         :min-pnl-this-round (atom 99.0)
         :allowed-to-enter? (atom true)
         :datagen   #(let [indicator-state %1
                           tic %2
                           date %3
                           mkt :SPY
                           i1 (indicators/returns-from-open-smooth indicator-state tic date)
                           i2 (indicators/recent-returns indicator-state tic date)
                           i3 (indicators/stdev-ema 5 indicator-state tic date)
                           i4 (indicators/volume-ema indicator-state tic date)
                           i5 (indicators/price-ema 5 indicator-state tic date)
                           i6 (indicators/price-ema 12 indicator-state tic date)
                           i7 (indicators/price-ema 26 indicator-state tic date)
                           i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                           i11 (indicators/moving-dispersion indicator-state tic date)
                           i12-10 (indicators/linear-regression-slope 10 indicator-state tic date)
                           i12-5 (indicators/linear-regression-slope 5 indicator-state tic date)
                           i12-15 (indicators/linear-regression-slope 15 indicator-state tic date)
                           i12-10-spy (indicators/linear-regression-slope 10 indicator-state mkt date)
                           i12-5-spy (indicators/linear-regression-slope 5 indicator-state mkt date)
                           i12-15-spy (indicators/linear-regression-slope 15 indicator-state mkt date)
                           r2 (indicators/r-square indicator-state tic date)
                           r2-spy (indicators/r-square indicator-state mkt date)
                           i13 (indicators/linear-regression-slope-diff indicator-state tic date)
                           i13-spy (indicators/linear-regression-slope-diff indicator-state mkt date)
                           last-return (indicators/last-return 10 indicator-state tic date)
                           bidask (indicators/bidask indicator-state tic date)
                           price @(:price @((indicator-state tic) date))
                           emadiff1 (- price (:data i5))
                           emadiff3 (cond (Double/isNaN (:data i7)) emadiff1 :else (- (:data i6) (:data i7)))
                           emadiff2 (cond (Double/isNaN (:data i7)) emadiff1 :else (- (:data i5) (:data i6)))
                           dispersion @(:dispersion @((indicator-state tic) date))
                           bv @(:buyvolume @((indicator-state tic) date))
                           sv @(:sellvolume @((indicator-state tic) date))
                           bidprice @(:bidprice @((indicator-state tic) date))
                           askprice @(:askprice @((indicator-state tic) date))
                           seq @(:seq-no @((indicator-state tic) date))
                           i16 (indicators/cumulative-relative-volume indicator-state tic date)]
                       (let [ilist [i1
                                    i2
                                    i3
                                    i4
                                    i5
                                    i6
                                    i7
                                    i8
                                    i11
                                    i12-10
                                    i12-5
                                    i12-15
                                    i12-10-spy
                                    i12-5-spy
                                    i12-15-spy
                                    r2
                                    r2-spy
                                    i13
                                    i13-spy
                                    last-return
                                    bidask
                                    emadiff1
                                    emadiff3
                                    emadiff2
                                    dispersion
                                    bv
                                    sv
                                    seq
                                    i16]]
                         {:header
                          [&quot;date&quot; &quot;seq&quot; &quot;price&quot; &quot;bidprice&quot; &quot;askprice&quot; (map header-fn ilist)]
                          :data
                          [(name date) seq price bidprice askprice (map data-fn ilist)]}))}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-10-market-make
  [price-band-cents pnl-target-bps max-n-trades]
  (atom {:commit
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (incanter/abs (:data (indicators/returns-from-open indicator-state tic date)))
                i2 (:data (indicators/recent-returns indicator-state tic date))
                i3 (:data (indicators/stdev-ema indicator-state tic date))
                i4 (:data (indicators/volume-ema indicator-state tic date))
                i5 (:data (indicators/price-ema 5 indicator-state tic date))
                i6 (:data (indicators/price-ema 12 indicator-state tic date))
                i7 (:data (indicators/price-ema 26 indicator-state tic date))
                i8 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i9 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                bidask (:data (indicators/bidask indicator-state tic date))
                emadiff (- i8 i9)
                i10 (:data (indicators/returns-quality indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
;returns-from-open              bidask             emadiff
;-8e-06        0.45       -1e-04
]
            (&lt; i3 10))
         :commit-lock (atom false) ;; if this is true stop update price band
         :price-band-upper (atom 1000.0) ;; commit true, then lock commit-lock and do not update band
         :price-band-lower (atom -1000.0)
         :price-band-cents price-band-cents
         :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps 500
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 60
         :datagen nil}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-11-market-make
  [commit-vol price-band-cents pnl-target-bps dd max-n-trades agent-name]
  (atom {:commit
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (incanter/abs (:data (indicators/returns-from-open indicator-state tic date)))
                i2 (:data (indicators/recent-returns indicator-state tic date))
                i3 (:data (indicators/stdev-ema 5 indicator-state tic date))
                i4 (:data (indicators/volume-ema indicator-state tic date))
                i5 (:data (indicators/price-ema 5 indicator-state tic date))
                i6 (:data (indicators/price-ema 12 indicator-state tic date))
                i7 (:data (indicators/price-ema 26 indicator-state tic date))
                i8 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i9 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                bidask (:data (indicators/bidask indicator-state tic date))
                emadiff (- i8 i9)
                 ;i10 (:data (indicators/returns-quality indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
;returns-from-open              bidask             emadiff
;-8e-06        0.45       -1e-04
]
            [(&gt;= i3 commit-vol)  (pos? (- i5 i6))  (neg? (- i5 i6))]) :commit-lock (atom false) ;; if this is true stop update price band
         :price-band-upper (atom 1000.0) ;; commit true, then lock commit-lock and do not update band
         :price-band-lower (atom -1000.0)
         :price-band-cents price-band-cents
         :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps dd
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :agent-name agent-name
         :max-ttc-minutes 600
         :print-datagen? false
         :datagen nil
         :live? (atom true)
         :allowed-to-enter? (atom true)
         :max-pnl (atom 0.0)
         :min-pnl (atom 0.0)
         :max-position (atom 0.0)
         :min-position (atom 0.0)
         :eod-position (atom 0.0)
         :cash-account (atom 0.0) :m2m-pnl (atom 0.0)
         :jutsu false
         :jutsu2 #(let [indicator-state %1
                        tic %2
                        date %3
                        price @(:price @((indicator-state tic) date))
                        time @(:seq-no @((indicator-state tic) date))
                ;i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                        i12 (:data (indicators/linear-regression-slope 15 15 indicator-state tic date))
                        i14 (:data (indicators/returns-from-open indicator-state tic date))
                        i15 (:data (indicators/trade-time-lapse indicator-state tic date))
                        i16 (:data (indicators/cumulative-relative-volume indicator-state tic date))]
                                        ;[date tic price i1 i2 ]
                    [{:plotly-data   {:data {:y [[i14]] :x [[time]]}
                                      :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                      :chart (str (tickers/ticker-&gt;sector (name tic)) &quot;-prices&quot;)}
                     {:plotly-data   {:data {:y [[i16]] :x [[time]]}
                                      :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                      :chart (str (tickers/ticker-&gt;sector (name tic)) &quot;-volumes&quot;)}])}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-11-cross-sectional
  [entry-threshold exit-threshold pnl-target-bps dd max-n-trades agent-name live?]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (incanter/abs (:data (indicators/returns-from-open indicator-state tic date)))
                i2 (:data (indicators/recent-returns indicator-state tic date))
                i3 (:data (indicators/stdev-ema 5 indicator-state tic date))
                i4 (:data (indicators/volume-ema indicator-state tic date))
                i5 (:data (indicators/price-ema 5 indicator-state tic date))
                i6 (:data (indicators/price-ema 12 indicator-state tic date))
                i7 (:data (indicators/price-ema 26 indicator-state tic date))
                i8 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i9 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                i10 (:data (indicators/returns-from-open-zscore indicator-state tic tickers/portfolio date))
                bidask (:data (indicators/bidask indicator-state tic date))
          ;dummy (pprint i10)
                emadiff (- i8 i9)
                 ;i10 (:data (indicators/returns-quality indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
;returns-from-open              bidask             emadiff
;-8e-06        0.45       -1e-04
]
            [(&lt;= entry-threshold i10 exit-threshold) (&lt;= (- exit-threshold) i10   (- entry-threshold)) (&gt; i10 exit-threshold) (&lt; i10 (- exit-threshold))]) :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps dd
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :agent-name agent-name
         :max-ttc-minutes 600
         :print-datagen? false
         :datagen nil
         :live? (atom live?)
         :allowed-to-enter? (atom true)
         :max-pnl (atom 0.0)
         :min-pnl (atom 0.0)
         :max-position (atom 0.0)
         :min-position (atom 0.0)
         :eod-position (atom 0.0)
         :cash-account (atom 0.0) :m2m-pnl (atom 0.0)
         :jutsu false
         :jutsu2 #(let [indicator-state %1
                        tic %2
                        date %3
                        price @(:price @((indicator-state tic) date))
                        time @(:seq-no @((indicator-state tic) date))
                ;i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                        i12 (:data (indicators/linear-regression-slope 15 15 indicator-state tic date))
                        i14 (:data (indicators/returns-from-open indicator-state tic date))
                        i15 (:data (indicators/trade-time-lapse indicator-state tic date))
                        i16 (:data (indicators/cumulative-relative-volume indicator-state tic date))]
                                        ;[date tic price i1 i2 ]
                    [{:plotly-data   {:data {:y [[i14]] :x [[time]]}
                                      :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                      :chart (str (tickers/ticker-&gt;sector (name tic)) &quot;-prices&quot;)}
                     {:plotly-data   {:data {:y [[i16]] :x [[time]]}
                                      :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                      :chart (str (tickers/ticker-&gt;sector (name tic)) &quot;-volumes&quot;)}])}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-11-position-target
  [entry-threshold exit-threshold pnl-target-bps dd max-n-trades agent-name live?]
  (atom {:target-position
         #(let [indicator-state %1
                tic %2
                date %3
                mkt :SPY
                i1 (indicators/returns-from-open-smooth indicator-state tic date)
                i2 (indicators/recent-returns indicator-state tic date)
                i3 (indicators/stdev-ema 5 indicator-state tic date)
                i4 (indicators/volume-ema indicator-state tic date)
                i5 (indicators/price-ema 5 indicator-state tic date)
                i6 (indicators/price-ema 12 indicator-state tic date)
                i7 (indicators/price-ema 26 indicator-state tic date)
                i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                i11 (indicators/moving-dispersion indicator-state tic date)
                i12-10 (indicators/linear-regression-slope 10 indicator-state tic date)
                i12-5 (indicators/linear-regression-slope 5 indicator-state tic date)
                i12-15 (indicators/linear-regression-slope 15 indicator-state tic date)
                i12-10-spy (indicators/linear-regression-slope 10 indicator-state mkt date)
                i12-5-spy (indicators/linear-regression-slope 5 indicator-state mkt date)
                i12-15-spy (indicators/linear-regression-slope 15 indicator-state mkt date)
                r2 (indicators/r-square indicator-state tic date)
                r2-spy (indicators/r-square indicator-state mkt date)
                i13 (indicators/linear-regression-slope-diff indicator-state tic date)
                i13-spy (indicators/linear-regression-slope-diff indicator-state mkt date)
                last-return (indicators/last-return 10 indicator-state tic date)
                bidask (indicators/bidask indicator-state tic date)
                p @(:price @((indicator-state tic) date))
                emadiff1 (- p (:data i5))
                emadiff3 (cond (Double/isNaN (:data i7)) emadiff1 :else (- (:data i6) (:data i7)))
                emadiff2 (cond (Double/isNaN (:data i7)) emadiff1 :else (- (:data i5) (:data i6)))
                dispersion @(:dispersion @((indicator-state tic) date))
                bv @(:buyvolume @((indicator-state tic) date))
                sv @(:sellvolume @((indicator-state tic) date))
                seq @(:seq-no @((indicator-state tic) date))
                i16 (indicators/cumulative-relative-volume indicator-state tic date)]
            (cond (and
             ;(&gt;= i12 1.0)
             ;(pos? i13)
             ;(pos? i1)
             ;(&gt;= i16 1 )
                   (&gt;= (:data i13) 0.50)
             ;(pos? emadiff1)
             ;(pos? emadiff2)
                                        ;(pos? emadiff3)
             ;(&lt;= last-return-zscore (- 3.0))
             ;(&gt;=  (:data autocorr) 0.15 )
             ;(pos? (:data last-return))
                                        ;(&gt; seq 200)
                   (&gt;= (:data r2) 0.98)
             ;(identity false)
             ;(not (zero? i11))
                   (&gt; seq 30)
             ;(&gt; sharpe 0.09 )
             ;(&gt;= variance 0.20)
                 ;(not (zero? i11))
                                        ;(&lt; entry-threshold i10 exit-threshold )
;(pos? mkt-trend1) (pos? mkt-trend2))
                  [1 [seq (:data r2)]]
            ;(&gt;= i10 exit-threshold) 0.0
                  (and
             ;(&gt;= i16 1 )
                 ;(&lt;= i12 (- 1.0))
             ;(neg? i1)
             ;(&lt;= i12 (- 0.50))
             ;(neg? emadiff1)
             ;(&gt;= r2 0.70)
                                        ;(not (zero? i11))
             ;(&gt;= last-return-zscore 3.0)
             ;(&gt;=  (:data autocorr) 0.15 )
             ;(neg? (:data last-return))
                   (&gt;= (:data r2) 0.98)
                   (&lt;= (:data i13) (- 0.50))
             ;(identity false)
             ;(not (zero? i11))
                   (&gt; seq 30)
             ;(neg? emadiff1) (neg? emadiff2) (neg? emadiff3)
             ;(&lt;= signal (- 2.0))
             ;(&gt; seq 20)
             ;(&lt; sharpe (- 0.09) )
             ;(&gt;= variance 0.20)
                 ;(not (zero? i11))
                 ;(neg? mkt-trend1) (neg? mkt-trend2)
                 ;(&lt; (- exit-threshold) i10 (- entry-threshold) ))
                  [(- 1) [seq (:data r2)]]
            ;(&lt;= i10 (- exit-threshold)) 0.0
                  :else [Double/NaN Double/NaN]))
         :exit-position  ;; if this is short exit long
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (:data (indicators/returns-from-open indicator-state tic date))
                i2 (:data (indicators/recent-returns indicator-state tic date))
                i3 (:data (indicators/stdev-ema 5 indicator-state tic date))
                i4 (:data (indicators/volume-ema indicator-state tic date))
                i5 (:data (indicators/price-ema 5 indicator-state tic date))
                i6 (:data (indicators/price-ema 12 indicator-state tic date))
                i7 (:data (indicators/price-ema 26 indicator-state tic date))
                i8 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i9 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                i11 (:data (indicators/moving-dispersion indicator-state tic date))
                bidask (:data (indicators/bidask indicator-state tic date))
                p @(:price @((indicator-state tic) date))
                emadiff1 (- p i5)
                emadiff3 (cond (Double/isNaN i7) emadiff1 :else (- i6 i7))
                emadiff2 (cond (Double/isNaN i7) emadiff1 :else (- i5 i6))
          ;i14 (:data (indicators/price-ema 5 indicator-state :SPY date))
          ;i15 (:data (indicators/price-ema 12 indicator-state :SPY date))
          ;mkt-price (:data (indicators/l1-price indicator-state :SPY date))
          ;mkt-trend1 (- mkt-price i14)
          ;mkt-trend2 (- i14 i15)
]
            (cond (and
                   (pos? i1)
                   (pos? emadiff2)
             ;(pos? mkt-trend2))   ;(&lt; entry-threshold i10 exit-threshold )
                  1.0
                  (and
                   (neg? i1)
                   (neg? emadiff2)
                  ;(neg? mkt-trend2))
                  (- 1.0)
                  :else 0.0)) :reference-price
         #(let [indicator-state %1
                tic %2
                date %3
                i5 (:data (indicators/price-ema 5 indicator-state tic date))]
            i5)
         :max-otl2
         #(let [indicator-state %1
                tic %2
                date %3
                i5 (:data (indicators/bidask indicator-state tic date))
                i6 (:data (indicators/stdev-price 5 indicator-state tic date))
                i7 (:data (indicators/l1-price indicator-state tic date))
                calc-otl (* 10000 (/ (+ i5 (* 2 i6)) i7))
          ;dummy (pprint (str tic &quot; otl &quot; calc-otl ))
]
            calc-otl)
         :target-size  ;; if otl is high take a smaller size
         #(let [indicator-state %1
                tic %2
                date %3
                i5 (:data (indicators/bidask indicator-state tic date))
                i6 (:data (indicators/stdev-price 20 indicator-state tic date))
                i7 (:data (indicators/l1-price indicator-state tic date))
                size-to-take-nan (int (/ 100 (+ i5 (* 2 i6))))
                size-to-take (cond (Double/isNaN size-to-take-nan) Double/NaN :else (apply max [100 size-to-take-nan]))
          ;dummy (pprint (str tic &quot; otl &quot; calc-otl ))
]
            size-to-take) :pnl-target-bps pnl-target-bps
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :position-status (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps dd
         :n-trades (atom 0.0)
         :n-otls (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-otls 1.0
         :max-loss-per-tic nil ;; need to think through this
         :agent-name agent-name
         :max-ttc-minutes 5.0
         :print-datagen? false
         :datagen nil :live? (atom live?)
         :allowed-to-enter-short? (atom true)
         :allowed-to-enter-long? (atom true)
         :max-pnl (atom (- 99.0))
         :min-pnl (atom 99.0)
         :max-position (atom 0.0)
         :min-position (atom 0.0)
         :eod-position (atom 0.0)
         :cash-account (atom 0.0) :m2m-pnl (atom 0.0)
         :jutsu false
         :max-otl (atom 100.0)
         :break-after-otl-minutes 0.50
         :otl-start-time (atom Double/NaN) ;; time when otl is started
         :max-total-pnl (atom -99.0)
         :max-spread 0.10}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn agent-12-lowstdev-trend
  [stdev-limit lm-entry max-n-trades dd]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3 i3 (:data (indicators/stdev-ema indicator-state tic date))
                i11 (:data (indicators/linear-regression-slope 15 15 indicator-state tic date))
                i12 (:data (indicators/linear-regression-slope-diff 15 15 indicator-state tic date))]
            [(and
              (&lt; i3 stdev-limit)
              (&gt; i11 lm-entry) ;; returns quality threshold
              (&gt; i12 0.0) ;; returns quality threshold)
             (and
              (&lt; i3 stdev-limit)
              (&lt; i11 (- lm-entry))  ;; returns quality threshold
              (&lt; i12 0.0) ;; returns quality threshold)])
         :exit
         #(let [indicator-state %1
                tic %2
                date %3 i3 (:data (indicators/stdev-ema indicator-state tic date))
                i11 (:data (indicators/linear-regression-slope 15 15 indicator-state tic date))
                i12 (:data (indicators/linear-regression-slope-diff 15 15 indicator-state tic date))]
            [(or
      ;(&gt;= i3 stdev-limit )
              (&lt; i11 0.0))
             (or
      ;(&gt;= i3 stdev-limit )
              (&gt; i11 0.0))])
         :pnl-target-bps nil
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom 0.0)
         :max-draw-bps dd ;; some sanity number not expect to trigger
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 120 ;; again some sane number
         :datagen #(let [indicator-state %1
                         tic %2
                         date %3
                         i3 (indicators/stdev-ema indicator-state tic date)
                         i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                         i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                         price @(:price @((indicator-state tic) date))
                         time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                     {:header
                      [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i3) (:header i11) (:header i12)]
                      :data
                      [(name date) time (name tic) price (:data i3)  (:data i11) (:data i12)]})
         :print-datagen false}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn agent-12-lowstdev-mr
  [lm-entry max-n-trades dd pnl-target smoothing lookback]
  (atom {:entry
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (:data (indicators/returns-from-open indicator-state tic date))
                i3 (:data (indicators/stdev-ema indicator-state tic date))
                i11 (:data (indicators/linear-regression-slope smoothing lookback indicator-state tic date))
                i12 (:data (indicators/linear-regression-slope-diff smoothing lookback indicator-state tic date))]
            [(and
              (&lt; (incanter/abs i1) 300) ;; only if moves are limited
;      (&gt; i11 lm-entry) ;; returns quality threshold
              (&lt; i11 (- lm-entry))
      ;(&gt; i12 0.0) ;; returns quality threshold)
             (and
              (&lt; (incanter/abs i1) 300)
      ;(&lt; i3 stdev-limit )
              (&gt; i11 lm-entry)
      ;(&lt; i12 0.0) ;; returns quality threshold)])
         :exit
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (:data (indicators/returns-from-open indicator-state tic date))
                i3 (:data (indicators/stdev-ema indicator-state tic date))
                i11 (:data (indicators/linear-regression-slope 15 15 indicator-state tic date))
                i12 (:data (indicators/linear-regression-slope-diff 15 15 indicator-state tic date))]
            [(&gt; (incanter/abs i1) 300)
             (&gt; (incanter/abs i1) 300)])
         :pnl-target-bps pnl-target
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom (- 99.0))
         :min-pnl-this-round (atom 99.0)
         :max-draw-bps dd ;; some sanity number not expect to trigger
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 120 ;; again some sane number
         :datagen #(let [indicator-state %1
                         tic %2
                         date %3
                         i3 (indicators/stdev-ema indicator-state tic date)
                         i11 (indicators/linear-regression-slope smoothing lookback indicator-state tic date)
                         i12 (indicators/linear-regression-slope-diff smoothing lookback indicator-state tic date)
                         price @(:price @((indicator-state tic) date))
                         time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                     {:header
                      [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i3) (:header i11) (:header i12)]
                      :data
                      [(name date) time (name tic) price (:data i3)  (:data i11) (:data i12)]})
         :print-datagen true}))</pre></td></tr><tr><td class="docs"><p> first tree model learnt from data</p>
</td><td class="codes"><pre class="brush: clojure">(comment (defn agent-14-learned-tree
           [max-n-trades dd pnl-target]
           (atom {;        :entry
                  :exit nil :entry   #(let [indicator-state %1
                                            tic %2
                                            date %3
                                            i1 (indicators/returns-from-open indicator-state tic date)
                                            i2 (indicators/recent-returns indicator-state tic date)
                                            i3 (indicators/stdev-ema indicator-state tic date)
                                            i4 (indicators/volume-ema indicator-state tic date)
                                            i5 (indicators/price-ema 5 indicator-state tic date)
                                            i6 (indicators/price-ema 12 indicator-state tic date)
                                            i7 (indicators/price-ema 26 indicator-state tic date)
                                            i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                                            i81 (indicators/pseudo-price-ema 12 indicator-state tic date)
                                            i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                                            i10 (indicators/returns-quality indicator-state tic date)
                                            i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                                            i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                                            dispersion @(:dispersion @((indicator-state tic) date))
                                            price @(:price @((indicator-state tic) date))
                                            time @(:seq-no @((indicator-state tic) date))
                                            indicator-output (zipmap
                                                              [(:header i1) (:header i2) (:header i3) (:header i4) &quot;dispersion&quot; (:header i5) (:header i6) (:header i7) (:header i8) (:header i81) (:header i9) (:header i10) (:header i11) (:header i12)] [(:data i1) (:data i2) (:data i3) (:data i4) dispersion (:data i5) (:data i6) (:data i7) (:data i8) (:data i81) (:data i9) (:data i10) (:data i11) (:data i12)])
                                            report-signal? (every? utils/notnan? (map second indicator-output))
                                        ;test (pprint indicator-output)
                                            signal (cond (not report-signal?) &quot;0&quot; :else (classify models/iris-tree-model1 indicator-output))
                                            test (pprint signal)]             ;[date tic price i1 i2 ]
                                        [(= signal &quot;1&quot;) (= signal &quot;-1&quot;)]) :pnl-target-bps pnl-target
                  :uts 100
                  :last-entry-price (atom [])
                  :last-exit-price (atom [])
                  :last-entry-time (atom 0.0) ;;msecs
                  :pnl (atom 0.0)
                  :position (atom 0.0)
                  :mur 100.0
                  :total-pnl (atom 0.0)
                  :m2m-pnl-bps (atom 0.0)
                  :max-pnl-this-round (atom (- 99.0))
                  :min-pnl-this-round (atom 99.0)
                  :max-draw-bps dd ;; some sanity number not expect to trigger
                  :n-trades (atom 0.0)
                  :max-n-trades max-n-trades ;; limit number of trades per tic
                  :max-loss-per-tic nil      ;; need to think through this
                  :name (str (gensym (utils/random-word)))
                  :max-ttc-minutes 120 ;; again some sane number
                  :allowed-to-enter? (atom true)
                  :datagen #(let [indicator-state %1
                                  tic %2
                                  date %3
                                  i3 (indicators/stdev-ema indicator-state tic date)
                                  i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                                  i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                                  price @(:price @((indicator-state tic) date))
                                  time @(:seq-no @((indicator-state tic) date))]             ;[date tic price i1 i2 ]
                              {:header
                               [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i3) (:header i11) (:header i12)]
                               :data
                               [(name date) time (name tic) price (:data i3)  (:data i11) (:data i12)]})
                  :print-datagen false})))</pre></td></tr><tr><td class="docs"><p> follow trend</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-15-simple-momentum
  [sharpe r-o max-n-trades dd rq-duration]
  (atom {:exit nil
         :entry   #(let [indicator-state %1
                         tic %2
                         date %3
                         i1 (indicators/returns-from-open indicator-state tic date)
                         i2 (indicators/recent-returns indicator-state tic date)
                         i3 (indicators/stdev-ema indicator-state tic date)
                         i4 (indicators/volume-ema indicator-state tic date)
                         i5 (indicators/price-ema 5 indicator-state tic date)
                         i6 (indicators/price-ema 12 indicator-state tic date)
                         i7 (indicators/price-ema 26 indicator-state tic date)
                         i8 (indicators/pseudo-price-ema 5 indicator-state tic date)
                         i81 (indicators/pseudo-price-ema 12 indicator-state tic date)
                         i9 (indicators/pseudo-price-ema 26 indicator-state tic date)
                         i10 (indicators/returns-quality rq-duration indicator-state tic date)
                         i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                         i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                         dispersion @(:dispersion @((indicator-state tic) date))
                         price @(:price @((indicator-state tic) date))
                         time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                     [(and
                       (&gt;= (incanter/abs (:data i1)) r-o)
                       (&gt;= (:data i10) sharpe) ;; returns quality threshold
                       (pos? (- (:data i5) (:data i6)))
      ;; add moving average hierarchy otherwise enters when signal is very volatile)
                      (and
                       (&gt;= (incanter/abs (:data i1)) r-o)
                       (&lt;= (:data i10) (- sharpe)) ;; returns quality threshold
                       (neg? (- (:data i5) (:data i6))))])
         :pnl-target-bps nil
         :uts 100
         :last-entry-price (atom [])
         :last-exit-price (atom [])
         :last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :max-pnl-this-round (atom (- 99.0))
         :min-pnl-this-round (atom 99.0)
         :max-draw-bps dd ;; some sanity number not expect to trigger
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 390 ;; again some sane number
         :allowed-to-enter? (atom true)
         :live? (atom true) ;; have live will place orders
         ;:jutsu nil
         :jutsu #(let [indicator-state %1
                       tic %2
                       date %3
                       price @(:price @((indicator-state tic) date))
                       time @(:seq-no @((indicator-state tic) date))
                ;i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                ;i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                       i14 (indicators/returns-from-open indicator-state tic date)]                       ;[date tic price i1 i2 ]
                   [;; first is the starter for plot, second is the update map to be sent to jutsu
                    [{:x [time]
                      :y [(:data i14)]
                      :mode &quot;markers&quot;
                      :type &quot;scatter&quot;}
                                        ;{:x [time] :y [(:data i11)] :mode &quot;markers&quot; :type &quot;scatter&quot;}
]
                    [{:data {:y [[(:data i14)]] :x [[time]]}
                      :traces [(@jutsudata/trace-id-map tic)]}
                                        ;{:data {:y [[(:data i11)]] :x [[time]]} :traces [1]}
                     ]]):datagen #(let [indicator-state %1
                                        tic %2
                                        date %3
                                        i3 (indicators/stdev-ema indicator-state tic date)
                                        i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                                        i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                                        price @(:price @((indicator-state tic) date))
                                        time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                                    {:header
                                     [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i3) (:header i11) (:header i12)]
                                     :data
                                     [(name date) time (name tic) price (:data i3)  (:data i11) (:data i12)]})
         :print-datagen false}))</pre></td></tr><tr><td class="docs"><p>(pprint (@jutsudata/trace-id-map :AAPL))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p> fernholz mean reversion</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-16-fernholz
  [when-to-peg inventory-threshold max-n-trades agent-name]
  (atom {:target-position   #(let [indicator-state %1
                                   tic %2
                                   date %3
                                   i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                                   i14 (indicators/fernholz-target when-to-peg indicator-state tic date)
                                   dispersion @(:dispersion @((indicator-state tic) date))
                                   price @(:price @((indicator-state tic) date))
                                   time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                               (:data i14))
         :inventory-threshold inventory-threshold
         :pnl-target-bps nil
         ;:uts 100
         ;:last-entry-price (atom [])
         ;:last-exit-price (atom [])
         ;:last-entry-time (atom 0.0) ;;msecs
         :pnl (atom 0.0)
         :position (atom 0.0)
         ;:mur 100.0
         :total-pnl (atom 0.0)
         :max-pnl (atom 0.0)
         :min-pnl (atom 0.0)
         :max-position (atom 0.0)
         :min-position (atom 0.0)
         :eod-position (atom 0.0)
         :cash-account (atom 0.0)
         :m2m-pnl-bps (atom 0.0)
         :m2m-pnl (atom 0.0)
         ;:max-pnl-this-round (atom (- 99.0))
         ;:min-pnl-this-round (atom 99.0)
         :max-draw-bps 1000 ;; some sanity number not expect to trigger
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :max-loss-per-tic nil ;; need to think through this
         :name (str (gensym (utils/random-word)))
         :max-ttc-minutes 390 ;; again some sane number
         :allowed-to-enter? (atom true)
         :live? (atom false) ;; have live will place orders
         :jutsu false
         :jutsu2 #(let [indicator-state %1
                        tic %2
                        date %3
                        price @(:price @((indicator-state tic) date))
                        time @(:seq-no @((indicator-state tic) date))
                        i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                ;i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                        i14 (:data (indicators/returns-from-open indicator-state tic date))
                        i15 (:data (indicators/trade-time-lapse indicator-state tic date))
                        i16 (:data (indicators/cumulative-relative-volume indicator-state tic date))]                       ;[date tic price i1 i2 ]
                    [;; first is the starter for plot, second is the update map to be sent to jutsu
                     [{:x [time]
                       :y [price]
                       :mode &quot;markers&quot;
                       :type &quot;scatter&quot;
                       :name (name tic)}
                                        ;{:x [time] :y [(:data i11)] :mode &quot;markers&quot; :type &quot;scatter&quot;}
]
                     [{:plotly-data   {:data {:y [[i14]] :x [[time]]}
                                       :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                       :chart (str (tickers/ticker-&gt;sector (name tic)) &quot; prices&quot;)}
                      {:plotly-data   {:data {:y [[i16]] :x [[time]]}
                                       :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                       :chart (str (tickers/ticker-&gt;sector (name tic)) &quot; volumes&quot;)}
                      {:plotly-data   {:data {:y [[price]] :x [[time]]}
                                       :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                       :chart (str (tickers/ticker-&gt;sector (name tic)) &quot; realprices&quot;)}]]) :datagen #(let [indicator-state %1
                                                                                                          tic %2
                                                                                                          date %3
                                                                                                          i3 (indicators/stdev-ema indicator-state tic date)
                                                                                                          i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                                                                                                          i12 (indicators/linear-regression-slope-diff 15 15 indicator-state tic date)
                                                                                                          price @(:price @((indicator-state tic) date))
                                                                                                          time @(:seq-no @((indicator-state tic) date))]            ;[date tic price i1 i2 ]
                                                                                                      {:header
                                                                                                       [&quot;date&quot; &quot;time&quot; &quot;tic&quot; &quot;price&quot; (:header i3) (:header i11) (:header i12)]
                                                                                                       :data
                                                                                                       [(name date) time (name tic) price (:data i3)  (:data i11) (:data i12)]})
         :print-datagen false
         :agent-name agent-name}))</pre></td></tr><tr><td class="docs"><p>complex strat that enters here exits there, with parameters
zpp
returns quality
pnl bps target</p>
</td><td class="codes"><pre class="brush: clojure">(defn agent-17-base
  [max-n-trades agent-name]
  (atom {:signal
         #(let [indicator-state %1
                tic %2
                date %3
                i1 (incanter/abs (:data (indicators/returns-from-open indicator-state tic date)))
                i2 (:data (indicators/recent-returns indicator-state tic date))
                i3 (:data (indicators/stdev-ema indicator-state tic date))
                i4 (:data (indicators/volume-ema indicator-state tic date))
                i5 (:data (indicators/price-ema 5 indicator-state tic date))
                i6 (:data (indicators/price-ema 12 indicator-state tic date))
                i7 (:data (indicators/price-ema 26 indicator-state tic date))
                i8 (:data (indicators/pseudo-price-ema 5 indicator-state tic date))
                i9 (:data (indicators/pseudo-price-ema 26 indicator-state tic date))
                bidask (:data (indicators/bidask indicator-state tic date))
                lr (:data (indicators/last-return indicator-state tic date))
                emadiff (- i8 i9)
                 ;i10 (:data (indicators/returns-quality indicator-state tic date))
                dispersion @(:dispersion @((indicator-state tic) date))
;returns-from-open              bidask             emadiff
;-8e-06        0.45       -1e-04
]
            (cond (&gt;= lr 0.001) (- 1.00)  (&lt;= lr (- 0.001)) 1.00 :else 0.0))
         :uts 100
         :pnl (atom 0.0)
         :position (atom 0.0)
         :mur 100.0
         :total-pnl (atom 0.0)
         :n-trades (atom 0.0)
         :max-n-trades max-n-trades ;; limit number of trades per tic
         :agent-name agent-name
         :print-datagen? false
         :datagen nil
         :live? (atom false)
         :allowed-to-enter? (atom true)
         :max-pnl (atom 0.0)
         :min-pnl (atom 0.0)
         :max-position (atom 0.0)
         :min-position (atom 0.0)
         :eod-position (atom 0.0)
         :cash-account (atom 0.0) :m2m-pnl (atom 0.0)
         :jutsu #(let [indicator-state %1
                       tic %2
                       date %3
                       price @(:price @((indicator-state tic) date))
                       time @(:seq-no @((indicator-state tic) date))
                ;i11 (indicators/linear-regression-slope 15 15 indicator-state tic date)
                       i12 (:data (indicators/linear-regression-slope 15 15 indicator-state tic date))
                       i14 (:data (indicators/returns-from-open indicator-state tic date))
                       i15 (:data (indicators/trade-time-lapse indicator-state tic date))
                       i16 (:data (indicators/cumulative-relative-volume indicator-state tic date))]                       ;[date tic price i1 i2 ]
                   [;; first is the starter for plot, second is the update map to be sent to jutsu
                    [{:x [time]
                      :y [price]
                      :mode &quot;markers&quot;
                      :type &quot;scatter&quot;
                      :name (name tic)}
                                        ;{:x [time] :y [(:data i11)] :mode &quot;markers&quot; :type &quot;scatter&quot;}
]
                    [{:plotly-data   {:data {:y [[i14]] :x [[time]]}
                                      :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                      :chart (str (tickers/ticker-&gt;sector (name tic)) &quot; prices&quot;)}
                     {:plotly-data   {:data {:y [[i16]] :x [[time]]}
                                      :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                      :chart (str (tickers/ticker-&gt;sector (name tic)) &quot; volumes&quot;)}
                     {:plotly-data   {:data {:y [[i12]] :x [[time]]}
                                      :traces [(@(jutsudata/trace-id-map (keyword (tickers/ticker-&gt;sector (name tic)))) tic)]
               ;:chart &quot;prices&quot;
}
                      :chart (str (tickers/ticker-&gt;sector (name tic)) &quot; LM&quot;)}]])}));zpp rq pnl-target-bps</pre></td></tr><tr><td class="docs"><p>zpp rq pnl-target-bps
returns-from-open              bidask             emadiff
-8e-06        0.45       -1e-04</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def a-list-datagen
  [;     #(agent-11-market-make 0.03 100 200 3)
   #(agent-9-datagen)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def a-list [;#(agent-5-k-filter 30 0.20 20 )
             ;#(agent-5-k-filter 20 0.20 20 )
             ;#(agent-5-k-filter 10 0.20 20 )
             ;#(agent-5-k-filter 1 0.20 20 )
    ;         #(agent-5-k-filter 40 0.20 10 )
     ;        #(agent-5-k-filter 50 0.20 30 )
;#(map agent-4-profit-taker [30 40 50] [0.10 0.20 0.30] [40 50 60] )
             ;#(agent-4-profit-taker 30 0.20 20 )
             ;#(agent-4-profit-taker 40 0.20 30 )
             ;#(agent-4-profit-taker 50 0.20 40 )
             ;#(agent-4-profit-taker 30 0.20 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 20 0.20 50 1 ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 50 400 1 &quot;1&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 1.00 20 400 1 &quot;2&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.50 10 400 1 &quot;3&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 1.15 10 400 1 &quot;4&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 1 &quot;5&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 2 &quot;6&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 3 &quot;7&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 4 &quot;8&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 5 &quot;9&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 6 &quot;10&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 7 &quot;11&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.75 30 500 8 &quot;12&quot; ) ;; seems like a sweet spot
; #(agent-7-returns-quality-trend 0.75 10 500 1 &quot;5&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-trend 0.75 5 500 1 &quot;6&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-trend 0.75 20 500 1 &quot;7&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-trend 0.75 30 500 1 &quot;8&quot; ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.01 50 1 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.03 50 1 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.05 50 1 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.10 50 1 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.01 50 1 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.03 50 3 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.05 50 5 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.10 50 10 ) ;; seems like a sweet spot
             ;#(agent-10-market-make 0.01 50 1 ) ;; seems like a sweet spot
             ;#(agent-11-market-make 20 0.02 20 200 20 &quot;20&quot; )
             ;#(agent-11-market-make 20 0.02 200 200 20 &quot;200&quot; )
             ;#(agent-11-market-make 5 0.02 400 400 20 &quot;400&quot; )
             ;#(agent-11-cross-sectional 2.0 2.5 400 400 20 &quot;400&quot; true )
             #(agent-11-position-target 2.0 3.0 400 400 20 &quot;2.0-3.0-400-400-2&quot; true) ;; 5 round trips should be enough
             ;#(agent-11-market-make 30 0.02 20 200 20 &quot;30&quot; )
             ;#(agent-11-market-make 40 0.02 20 200 20 &quot;40&quot; )
             ;#(agent-11-market-make 15 0.02 20 200 20 &quot;15&quot; )
             ;#(agent-17-base 10 &quot;10&quot; )
             ;#(agent-11-market-make 0.05 50 1 ) ;; seems like a sweet spot
             ;#(agent-11-market-make 0.10 50 1 ) ;; seems like a sweet spot
             ;#(agent-11-market-make 0.01 50 1 ) ;; seems like a sweet spot
             ;#(agent-11-market-make 0.03 50 3 ) ;; seems like a sweet spot
             ;#(agent-11-market-make 0.05 50 5 ) ;; seems like a sweet spot
             ;#(agent-11-market-make 0.10 50 10 ) ;; seems like a sweet spot
             ;[price-band-cents pnl-target-bps dd max-n-trades]
             ;#(agent-11-market-make 0.03 100 50 3)
             ;#(agent-11-market-make 0.03 200 50 3)
             ;#(agent-11-market-make 0.03 300 50 3)
             ;#(agent-11-market-make 0.03 400 50 3)
             ;#(agent-11-market-make 0.03 100 150 3)
             ;#(agent-11-market-make 0.03 200 150 3)
             ;#(agent-11-market-make 0.03 300 150 3)
             ;#(agent-11-market-make 0.03 400 150 3)
             ;#(agent-11-market-make 0.05 100 500 3)
             ;#(agent-11-market-make 0.05 200 500 3)
             ;#(agent-11-market-make 0.05 300 500 3)
             ;#(agent-11-market-make 0.05 400 500 3)
;   #(agent-12-lowstdev-mr 3.0 1 100 20)
         ;    #(agent-12-lowstdev-mr 5.0 1 100 20)
        ;     #(agent-12-lowstdev-mr 7.0 1 100 20)
       ;      #(agent-12-lowstdev-mr 9.0 1 100 20)
      ;       #(agent-12-lowstdev-mr 3.0 1 200 10)
     ;        #(agent-12-lowstdev-mr 5.0 1 200 10)
    ;         #(agent-12-lowstdev-mr 7.0 1 200 10)
   ;          #(agent-12-lowstdev-mr 9.0 1 200 10)
  ;           #(agent-12-lowstdev-mr 3.0 1 300 30)
 ;            #(agent-12-lowstdev-mr 5.0 1 300 30)
             ;#(agent-12-lowstdev-mr 7.0 1 300 30 15 15)
             ;#(agent-12-lowstdev-mr 5.0 1 300 30 30 15)
             ;#(agent-12-lowstdev-mr 5.0 1 300 30 10 10)
             ;#(agent-12-lowstdev-mr 4.0 1 300 30 10 20)
             ;#(agent-12-lowstdev-mr 3.0 1 300 30 40 20)
             ;#(agent-12-lowstdev-mr 2.0 1 300 30 40 40)
             ;#(agent-12-lowstdev-mr 2.0 1 300 30 60 15)
             ;#(agent-12-lowstdev-mr 2.0 1 300 30 60 30)
;             #(agent-14-learned-tree 10.0 300 30)
;             #(agent-12-lowstdev-mr 9.0 1 300 30)
;#(agent-11-market-make 0.03 100 200 3)
            ; #(agent-7-returns-quality-mr 1.00 20 400 1 &quot;2&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 0.50 10 400 1 &quot;3&quot; ) ;; seems like a sweet spot
            ; #(agent-7-returns-quality-mr 1.15 10 400 1 &quot;4&quot; ) ;; seems like a sweet spot
;#(agent-8-lm 0.20 25 1 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.20 50 3 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.20 100 5 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.20 200 10 ) ;; seems like a sweet spot
                          ;#(agent-8-lm 0.10 25 1 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.10 50 3 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.10 100 5 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.10 200 10 ) ;; seems like a sweet spot
             ;             #(agent-8-lm 0.30 25 1 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.30 50 3 ) ;; seems like a sweet spot
             ;#(agent-8-lm 0.30 100 5 ) ;; seems like a sweet spot
;             #(agent-8-lm 0.30 200 10 ) ;; seems like a sweet spot
;#(agent-4-profit-taker 20 0.20 50 3 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 20 0.20 50 7 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 20 0.20 50 10 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 10 0.20 50 1 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 10 0.20 50 3 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 10 0.20 50 7 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 10 0.20 50 10 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 1 0.20 50 1 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 1 0.20 50 3 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 1 0.20 50 7 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 1 0.20 50 10 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 10 0.20 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 0 0.20 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 30 0.30 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 20 0.30 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 10 0.30 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 0 0.30 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 30 0.10 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 20 0.10 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 10 0.10 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 0 0.10 50 ) ;; seems like a sweet spot
             ;#(agent-4-profit-taker 40 0.20 60 )
             ;#(agent-4-profit-taker 50 0.20 70 )
             ;#(agent-4-profit-taker 30 0.20 20 )
             ;#(agent-4-profit-taker 40 0.20 30 )
             ;#(agent-4-profit-taker 50 0.20 40 )
              ;#(agent-4-profit-taker 30 0.20 20 )
             ;#(agent-4-profit-taker 40 0.20 30 )
             ;#(agent-4-profit-taker 50 0.20 40 )
;             #(agent-6-rare-trader 0  300 )
 ;            #(agent-6-rare-trader 10 200 )
  ;           #(agent-6-rare-trader 20 100 )
;agent-15-simple-momentum
;  &quot; follow trend&quot;
 ;            [zpp r-o max-n-trades dd pnl-target]
     ;        #(agent-15-simple-momentum 0.50 200 10 1000 5000 )
     ;        #(agent-15-simple-momentum 0.50 200 10 1000 5000 )
      ;       #(agent-15-simple-momentum 0.50 200 10 1000 5000 )
       ;      #(agent-15-simple-momentum 0.50 200 10 1000 5000 )
        ;     #(agent-15-simple-momentum 0.75 200 10 1000 5000 )
         ;    #(agent-15-simple-momentum 0.75 200 10 1000 5000 )
          ;   #(agent-15-simple-momentum 0.75 200 10 1000 5000 )
           ;  #(agent-15-simple-momentum 0.75 200 10 1000 5000 )
           ;  #(agent-15-simple-momentum 1.00 200 10 1000 5000 )
           ;  #(agent-15-simple-momentum 1.00 200 10 1000 5000 )
           ;  #(agent-15-simple-momentum 1.00 200 10 1000 5000 )
            ; #(agent-15-simple-momentum 1.00 200 10 1000 5000 )
;#(agent-15-simple-momentum 0.25 100 10 200 100 15 )
                                        ;#(agent-15-simple-momentum 0.25 100 10 200 100 25 )
             ;agent-15-simple-momentum
             ;[sharpe r-o max-n-trades dd rq-duration]
             ;#(agent-15-simple-momentum 0.25 100 10 100 35 )
             ;#(agent-15-simple-momentum 0.35 200 10 200 25 )
             ;#(agent-15-simple-momentum 0.45 300 10 300 45 )
             ;#(agent-15-simple-momentum 0.55 400 10 50 45 )
             ;#(agent-15-simple-momentum 0.55 300 10 50 45 )
             ;#(agent-15-simple-momentum 0.55 200 10 50 45 )
             ;#(agent-15-simple-momentum 0.10 100 10 200 10 )
             ;#(agent-15-simple-momentum 0.10 50 10 200 10 )
             ;#(agent-15-simple-momentum 0.10 20 10 200 10 )
             ;#(agent-15-simple-momentum 0.05 20 10 200 10 )
             ;#(agent-16-fernholz 0 200 10 &quot;0-200-10&quot; )
             ;#(agent-16-fernholz 3 200 10 &quot;3-200-10&quot; ) ;; 15 minutes
             ;#(agent-16-fernholz 6 200 10 &quot;6-200-10&quot; )
             ;#(agent-16-fernholz 8 200 10 &quot;8-200-10&quot; )
             ;#(agent-15-simple-momentum 0.25 100 10 200 100 45 )
           ;  #(agent-15-simple-momentum 0.25 100 10 1000 5000 )
           ;  #(agent-15-simple-momentum 0.25 100 10 1000 5000 )
           ;  #(agent-15-simple-momentum 0.25 100 10 1000 5000 )
           ;  #(agent-15-simple-momentum 0.75 100 10 1000 5000 )
            ; #(agent-15-simple-momentum 0.75 100 10 1000 5000 )
           ;  #(agent-15-simple-momentum 0.75 100 10 1000 5000 )
           ;  #(agent-15-simple-momentum 0.75 100 10 1000 5000 )
            ; #(agent-15-simple-momentum 1.00 100 10 1000 5000 )
            ; #(agent-15-simple-momentum 1.00 100 10 1000 5000 )
            ; #(agent-15-simple-momentum 1.00 100 10 1000 5000 )
            ; #(agent-15-simple-momentum 1.00 100 10 1000 5000 )
;#(agent-15-simple-momentum 0.20 300 10 200 50 )
])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.processdata" name="matrix.processdata"><h1 class="project-name">matrix.processdata</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.processdata
  (:require
   [matrix.utils :as utils]
   [net.cgrand.enlive-html :as enlive]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.data.json :as json]
   [incanter.zoo :as zoo]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [clj-time.predicates :as pr]
   [clj-time.local :as l]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clj-http.client :as client]
                                        ;  [structure.ring-buffer :as rb]
                                        ;  [postal.core :as postal]
   [clojure.core.async
    :as a
    :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
            alts! alts!! timeout]]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]]
   [me.raynes.conch :refer [programs with-programs let-programs] :as sh] [matrix.utils :as utils]) (:use clojure.pprint)
  ;(:use [clj-highcharts.core])
  (:gen-class))</pre></td></tr><tr><td class="docs"><p> use the above urls to retrieve ticker list for nyse and nasdaq, cutoff at certain points</p>

<p>initialize nasdaq and nyse ticker, our trading universe</p>
</td><td class="codes"><pre class="brush: clojure">(do (def HOME utils/HOME)
    (def mc-cutoff 800E6)
    (def price-cutoff 5)
    (def adv-cutoff-millions 10)
    (def urls [&quot;http://www.nasdaq.com/screening/companies-by-industry.aspx?exchange=NASDAQ&amp;render=download&quot; &quot;http://www.nasdaq.com/screening/companies-by-industry.aspx?exchange=NYSE&amp;render=download&quot;])
    (defn retrieve-symbols
      [mc-cutoff price-cutoff adv-cutoff-millions url] (let [data (io2/read-dataset url :header true)
                                                             nasdaq (incanter/to-dataset data)
                                                             symbols (incanter$/$ :Symbol nasdaq)
                                                             name_ (incanter$/$ :Name nasdaq)
                                                             lastsale (incanter$/$ :LastSale nasdaq)
                                                             market-cap (incanter$/$ :MarketCap nasdaq)
                                                             sector (incanter$/$ :Sector nasdaq)
                                                             industry (incanter$/$ :Industry nasdaq)
                                                             filter-data0 (map vector symbols name_ lastsale market-cap sector industry)
                                                             filter-data1 (filter #(number? (nth % 2)) filter-data0)
                                                             filter-data2-nasdaq (filter #(and (&gt;= (nth % 2) price-cutoff) (&gt;= (nth % 3) mc-cutoff)) filter-data1)]
                                                         filter-data2-nasdaq))
    (def nasdaq-data (retrieve-symbols mc-cutoff price-cutoff adv-cutoff-millions (first urls)))
    (def nyse-data (retrieve-symbols mc-cutoff price-cutoff adv-cutoff-millions (second urls)))
    (def tickers (set (concat (map first nyse-data)  (map first nasdaq-data))))
    (count tickers)
    (def stock-names-nyse (zipmap (map first nyse-data)  (map second nyse-data)))
    (def stock-names-nasdaq (zipmap (map first nasdaq-data)  (map second nasdaq-data)))
    (def stock-names (merge stock-names-nyse stock-names-nasdaq))
    (count stock-names))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def data (io2/read-dataset (str utils/HOME &quot;/data/datagen-grab.txt&quot;) :header true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(utils/lookahead 5 (incanter$/$ :price data))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fsg [k y]
  (let [s (/ (stats/sd (filter #(not (Double/isNaN %)) y)) k)
        out (map #(cond (&gt; (incanter/abs %) s) (utils/sign %) :else 0) y)]
    out))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fsg-number [s y]
  (let [out (map #(cond (&gt; (incanter/abs %) s) (utils/sign %) :else 0) y)]
    out))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def y (let [p (incanter$/$ :price data)
             fp (utils/lookahead 10 (incanter$/$ :price data))
             y (map - fp p)
             y-fsg (fsg-number 0.50 y)]
         y-fsg))</pre></td></tr><tr><td class="docs"><p>(pprint (filter #(not (Double/isNaN %)) y))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(stats/mean (map incanter/abs (filter #(not (Double/isNaN %)) y)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(incanter/save (incanter/conj-cols (incanter/sel data :except-cols :price) y) (str HOME &quot;/data/trading-fsg.tsv&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.tradinglogic" name="matrix.tradinglogic"><h1 class="project-name">matrix.tradinglogic</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.tradinglogic
  (:require
   [matrix.utils :as utils]
   [matrix.trackorders :as trackorders]
   [matrix.timekeeper :as timekeeper]
   [matrix.indicators :as indicators]
   [matrix.agents :as agents]
   [matrix.tickers :as tickers]
   [matrix.jutsudata :as jutsudata]
   [repltrader.execution :as execution]
   [repltrader.gateway :as gateway]
   [jutsu.core :as j]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clj-http.client :as client]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [clojure.tools.nrepl.server :as serv]
   [incanter.interpolation :refer :all]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]
                                        ;[interpolation :as interpolation]
]
   [clojure.core.async
    :as clojurecoreasync
    :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
            alts! alts!! timeout]]
   [clojure.tools.cli :refer [cli]] [matrix.utils :as u]
   [taoensso.timbre :as timbre]
   [clojure.term.colors :refer :all]
; white, cyan, magenta, blue, yellow, green, red, grey, on-white,
;on-cyan, on-magenta, on-blue, on-yellow, on-green, on-red, on-grey,
;concealed, reverse-color, blink, underline, dark, bold)(:use clojure.pprint)
  (:require [clojure.tools.cli :refer [parse-opts]])
  (:gen-class))</pre></td></tr><tr><td class="docs"><p>this is a different logic, cross sectional entry exit</p>
</td><td class="codes"><pre class="brush: clojure">(declare datagen-file)</pre></td></tr><tr><td class="docs"><p>add drawdown cooloff for five minutes, clearly your signal is false now, prices are falling(rising) and signal says buy(sell) ; allow opposite entry add allowed-to-enter-long and short
write recent peak indicator, shows direction of displacement from most recent peak or trough to replace returns from open -> lets call it neeyat (teri neeyat kya hai?)
maybe not take anti sentiment positions, ie ones that are opposite open(today)-yesterday(close) -> on second thought no, neeyat indicator will decide where it is going
keep track of max(total-pnl) - total-pnl -> when maxdd is hit, stop trading. you're done.
enter only when dispersion is moving? prevent nokia type of trading</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
strong signal -> target position is positive
weak signal -> exit
strong short signal -> target position is negative
weak signal -> exit</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-position-target
  [log-file-name datagen-file datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        price-bars @(@((indicator-state tic) date) :price-bars)
                                        ;sigma (incanter/sd price-bars)
        ;price-band [ (utils/round (- price sigma)) (utils/round (+ price sigma)) ]
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        spread (utils/round (- askprice bidprice))
        target-position-prior ((:target-position agent) indicator-state tic date)
        exit-position ((:exit-position agent) indicator-state tic date)
        ;reference-price ( (:reference-price agent) indicator-state tic date) ;; only units 0 -&gt; 5 -&gt; -5
        capital 10000.0
        max-uts (:data (indicators/position-to-take capital indicator-state tic date)) ;; the jump from 0 is this position
        calc-uts ((:target-size agent) indicator-state tic date) ;; can be NaN
        uts (apply min [max-uts calc-uts])
        ;market-uts (:data (indicators/position-to-take capital indicator-state :SPY date)) ;; the jump from 0 is this position
        current-position @(agent :position)
        current-position-abs (incanter/abs current-position)
        current-position-status @(agent :position-status)  ;; this is + 1 -1 or 0 ; long short or flat
        getflat? (and (not (zero? exit-position)) (not (zero? current-position-status)) (not= current-position-status exit-position))
        ;target-position (cond (neg? (* current-position target-position-prior)) 0.0 :else target-position-prior )
        ;; if we have position ignore signal and use drawdowns to exit (or ttc) - a hack
        target-position (cond (not (zero? current-position)) current-position-status :else target-position-prior)  ;;t-p is always a unit quantity
        position-diff (cond (Double/isNaN target-position) 0.0 :else (- target-position current-position-status))
        position-diff-abs (incanter/abs position-diff) unsigned-actual-trade-size (* uts position-diff-abs)  ;; typically 1 or 2 times uts, signed quantity ; causes residual positions for now fix later
        ;unsigned-market-trade-size (* market-uts position-diff-abs)
        current-n-trades @(agent :n-trades)
        current-n-otls @(agent :n-otls)
;;correct pnl accounting, if long i can get out on bid only
        ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
        agent-name (agent :agent-name) time-now @(@((indicator-state tic) date) :time)
        time-string @(@((indicator-state tic) date) :time-string)
        ;max-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        total-pnl @(:total-pnl agent) ;; this is in dollars now
        eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.5
        first-datapoint? (not (.exists (io/as-file datagen-file))) datagen-output (cond (nil? (:datagen agent)) nil
                                                                                        :else ((:datagen agent) indicator-state tic date))
        live? (cond (nil? @(:live? agent)) false :else @(:live? agent)) ;; place orders
        time @(:seq-no @((indicator-state tic) date))
        ib-tic (name tic)
        cash-account @(:cash-account agent) ;; this is in bps
        m2m-pnl @(:m2m-pnl agent)
        max-pnl @(:max-pnl agent)
        draw (- max-pnl m2m-pnl)
        allowed-drawdown (utils/drawdown-at-pnl (apply max [max-pnl total-pnl]))
        drawdown-breached? (&gt; draw allowed-drawdown)
        tentative-max-otl 100.0
        ;(apply max [ ( (:max-otl2 agent) indicator-state tic date) 100.0  ])
        allowed-to-enter-long? (and (not= tic :SPY) (not (Double/isNaN uts)) (not (Double/isNaN tentative-max-otl)) @(:allowed-to-enter-long? agent) (&lt; current-n-trades (agent :max-n-trades)) (&lt; @(agent :n-otls) (agent :max-otls))   (&lt;= spread (agent :max-spread)))
        allowed-to-enter-short? (and (not= tic :SPY) (not (Double/isNaN uts)) (not (Double/isNaN tentative-max-otl)) @(:allowed-to-enter-short? agent) (&lt; current-n-trades (agent :max-n-trades))  (&lt; @(agent :n-otls) (agent :max-otls))   (&lt;= spread (agent :max-spread)))
;;correct pnl accounting, if long i can get out on bid only
        ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
        reference-price ((:reference-price agent) indicator-state tic date) otl-breached? (&gt;= (- m2m-pnl) @(:max-otl agent))
        otl-sleep (* 60000 (:break-after-otl-minutes agent))
        time-since-last-otl-msecs (- time-now @(:otl-start-time agent));; now i take care of max-total-pnl, where a good thing is preserved
        max-total-pnl @(:max-total-pnl agent)
        ;m2m-pnl-relevant (cond (neg? m2m-pnl) (- m2m-pnl) :else 0) ;; only if negative i worry
        go-home-pnl (+ total-pnl m2m-pnl) ;; this is my total-pnl-draw
        total-pnl-draw (- max-total-pnl go-home-pnl)
        total-allowed-drawdown (utils/drawdown-at-pnl max-total-pnl)
        total-drawdown-breached? (&gt; total-pnl-draw total-allowed-drawdown)
        last-entry-time @(:last-entry-time agent)
        ttc-now-minutes (cond (zero? current-position) 0.0 :else (utils/round (/ (- time-now last-entry-time) 60000)))
        ttc-breached? (cond (nil? ttc-now-minutes) false :else (&gt;= ttc-now-minutes (:max-ttc-minutes agent)))]
    ;;remember eod positions and total-pnls are not correct in datagen bcos
    ;; after eod it does not print another point
    (if (and datagen? (:print-datagen? agent)) (if first-datapoint?
                                                 (spit datagen-file (utils/coll-&gt;string (:header datagen-output)) :append true)
                                                 (spit datagen-file (utils/coll-&gt;string (:data datagen-output)) :append true)))
    (if (and eod? (not eod-plus-one?))
      (do
        (when (not (zero? current-position))
          (reset! (:position-status agent) 0)
          (reset! (:position agent) 0)
          (reset! (:eod-position agent) current-position)
          (swap! (:n-trades agent) inc)
          (if (pos? current-position) (swap! (:cash-account agent) + (* current-position-abs bidprice)) (swap! (:cash-account agent) - (* current-position-abs askprice)))
          (reset! (:allowed-to-enter-long? agent) false)
          (reset! (:allowed-to-enter-short? agent) false)
          (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
          (if (pos? current-position)
            (do (if live? (execution/SELL ib-tic current-position-abs))
                (timbre/debug (red &quot;EODSELLCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl   &quot; total-pnl &quot; @(:total-pnl agent))))
            (do (if live? (execution/BUY ib-tic current-position-abs))
                (timbre/debug (green &quot;EODBUYCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl   &quot; total-pnl &quot; @(:total-pnl agent)))))
          (reset! (:m2m-pnl agent) @(:cash-account agent))
;; eod pnl can be max pnl or min
          (let [pnl @(:m2m-pnl agent)]
            (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
            (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl))))
        (reset! (@((indicator-state tic) date) :eod-plus-one?)  true) ;; marking eod process complete and end of trading
        (reset! (@((indicator-state tic) date) :pnl) @(:total-pnl agent)))   ;; end EOD stuff
;; if not EOD
      (when-not eod?   ;;;  this is because of eod-plus-one flag becomes true at last step
  ;; heres where the otl is reset when we can trade again
        (when (&gt;= time-since-last-otl-msecs otl-sleep)
          (reset! (:allowed-to-enter-long? agent) true)
          (reset! (:allowed-to-enter-short? agent) true)
          (reset! (:otl-start-time agent) Double/NaN))
    ;; if i hit $300 total pnl and have lost $50, go home with 250 stop trading!
        (when ;false
         total-drawdown-breached?   ;; disable for now
          (reset! (@((indicator-state tic) date) :eod?) true)
          (reset! (:allowed-to-enter-long? agent) false)
          (reset! (:allowed-to-enter-short? agent) false)
          (timbre/debug (red &quot;GO-HOME-ON-DRAW!!! &quot; &quot; tic &quot; ib-tic &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)  &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)    &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread))
;;raise eod flag and end trading)  ;;; when otl
        (when-not (zero? position-diff-abs)  ;;some positions to be taken/eliminated
;;can be removed
     ;; end when zero target
   ;; get long (from short or from flat)
   ;; else
          (when (and (pos? target-position) allowed-to-enter-long?
                ;; allowed to enter long
                     @(:allowed-to-enter-long? agent))
            (swap! (:position agent) + unsigned-actual-trade-size)
            (reset! (:position-status agent) target-position)
            (swap! (:last-entry-price agent) conj askprice)
            (reset! (:last-entry-time agent) time-now)
            (swap! (:cash-account agent) - (* unsigned-actual-trade-size askprice))
            (reset! (:max-otl agent) tentative-max-otl)
            (reset! (:last-entry-time agent) time-now)
                                        ;(execution/buy-hedge-new tic unsigned-actual-trade-size unsigned-market-trade-size  )
            (if live? (execution/BUY ib-tic unsigned-actual-trade-size))
            (timbre/debug (green &quot;BUY &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time  &quot; price &quot; askprice &quot; somany &quot; unsigned-actual-trade-size &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl &quot; total-pnl &quot; @(:total-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent) &quot; draw &quot; draw &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent)))
            (swap! (:n-trades agent) inc)
            (let [current-position @(agent :position)
                  current-position-abs (incanter/abs current-position)
                 ;;correct pnl accounting, if long i can get out on bid only
                 ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
                  value-of-positions (* reference-price current-position)
                  net-value (+ @(agent :cash-account)  value-of-positions)]
              (reset! (:m2m-pnl agent) net-value)
              (if (&gt;= net-value @(:max-pnl agent)) (reset! (:max-pnl agent) net-value))
              (if (&lt;= net-value @(:min-pnl agent)) (reset! (:min-pnl agent) net-value))
              (timbre/debug (yellow &quot;M2M &quot; &quot; tic &quot; ib-tic &quot; time &quot; time  &quot; price &quot; reference-price &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; total-pnl &quot; @(:total-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)  &quot; draw &quot; draw &quot; spread &quot; spread))))
         ;; get long (from short or from flat)
          (when (and (neg? target-position) allowed-to-enter-short?
                     @(:allowed-to-enter-short? agent))
            (swap! (:position agent) - unsigned-actual-trade-size)
            (reset! (:position-status agent) target-position)
            (swap! (:last-entry-price agent) conj askprice)
            (reset! (:last-entry-time agent) time-now)
            (swap! (:cash-account agent) + (* unsigned-actual-trade-size bidprice))
            (reset! (:max-otl agent) tentative-max-otl)
            (reset! (:last-entry-time agent) time-now)
                                        ;(execution/sell-hedge-new tic unsigned-actual-trade-size unsigned-market-trade-size  )
            (if live? (execution/SELL ib-tic unsigned-actual-trade-size))
            (timbre/debug (red &quot;SELL &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time  &quot; price &quot; bidprice &quot; somany &quot; unsigned-actual-trade-size &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl &quot; total-pnl &quot; @(:total-pnl agent)  &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent) &quot; draw &quot; draw &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent)))
            (swap! (:n-trades agent) inc)
            (let [current-position @(agent :position)
                  current-position-abs (incanter/abs current-position)
                 ;;correct pnl accounting, if long i can get out on bid only
                 ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
                  value-of-positions (* reference-price current-position)
                  net-value (+ @(agent :cash-account)  value-of-positions)]
              (reset! (:m2m-pnl agent) net-value)
              (if (&gt;= net-value @(:max-pnl agent)) (reset! (:max-pnl agent) net-value))
              (if (&lt;= net-value @(:min-pnl agent)) (reset! (:min-pnl agent) net-value))
              (timbre/debug (yellow &quot;M2M &quot; &quot; tic &quot; ib-tic &quot; time &quot; time  &quot; price &quot; reference-price &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; total-pnl &quot; @(:total-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)  &quot; draw &quot; draw &quot; spread &quot; spread)))))
  ;;; m2m pnl update when not doing anythin
        (when (zero? position-diff-abs) (let [current-position @(agent :position)
                                              current-position-abs (incanter/abs current-position)
                   ;;correct pnl accounting, if long i can get out on bid only
                   ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
                                              value-of-positions (* reference-price current-position)
                                              net-value (utils/round (+ @(agent :cash-account)  value-of-positions))]
                                          (reset! (:m2m-pnl agent) net-value)
                                          (if (&gt;= net-value @(:max-pnl agent)) (reset! (:max-pnl agent) net-value))
                                          (if (&lt;= net-value @(:min-pnl agent)) (reset! (:min-pnl agent) net-value))
;(timbre/debug (cyan &quot;M2M &quot; &quot; tic &quot; ib-tic &quot; time &quot; time  &quot; price &quot; reference-price &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; total-pnl &quot; @(:total-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent) &quot; draw &quot; draw  )))
;; only exit mechanism now is when not eod, if dd breached or otl breached
              (when (and (not @(@((indicator-state tic) date) :eod?))
                         (or
                                        ;getflat?
                          false
                     ;otl-breached?
                     ;drawdown-breached?
                     ;ttc-breached?))
                (cond
                  (pos? current-position)
                  (do
                    (swap! (:position agent) - current-position-abs)
                    (reset! (:position-status agent) 0.0)
                    (swap! (:last-exit-price agent) conj price)
                                        ;(reset! (:max-pnl-this-round agent) 0.0)
                    (reset! (:last-entry-time agent) nil)
                    (swap! (:n-trades agent) inc)
                    (swap! (:cash-account agent) + (* current-position-abs bidprice))
                                        ;(reset! (:m2m-pnl agent)  @(:cash-account agent)  ) ;;; this is round pnl (total pnl is sum of rounds)
                                        ;(swap! (:total-pnl agent) + (utils/round @(:cash-account agent)    )  )
                    (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
                    (if (&gt; @(:total-pnl agent) @(:max-total-pnl agent)) (reset! (:max-total-pnl agent)  @(:total-pnl agent)))
                    (if live? (execution/SELL ib-tic current-position-abs))
                    (timbre/debug (on-white (red &quot;SELL-CLOSE-ON-DRAW &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time &quot; price &quot; bidprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)   &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw  &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread)))
                    (when
                     otl-breached?
                      (swap! (agent :n-otls) inc)                                                                                                   (timbre/debug (magenta &quot;OTL-BREACH &quot; &quot; tic &quot; ib-tic &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)   &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent))))
                    (when
                     getflat?
                      (timbre/debug (on-yellow (blue &quot;GETFLAT &quot; &quot; tic &quot; ib-tic &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)   &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent)))))
                    (reset! (:allowed-to-enter-long? agent) false)
                    (reset! (:allowed-to-enter-short? agent) false)
                    (reset! (:otl-start-time agent) time-now))
                  (neg? current-position)
                  (do
                    (swap! (:position agent) + current-position-abs)
                    (reset! (:position-status agent) 0.0)
                    (swap! (:last-exit-price agent) conj price)
                                        ;(reset! (:m2m-pnl-bps agent) 0.0)
                                        ;(reset! (:max-pnl-this-round agent) 0.0)
                    (reset! (:last-entry-time agent) nil)
                    (swap! (:n-trades agent) inc)
                    (swap! (:cash-account agent) - (* current-position-abs askprice))
                                        ;(reset! (:m2m-pnl agent)  @(:cash-account agent)  )
                    (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
                    (if (&gt; @(:total-pnl agent) @(:max-total-pnl agent)) (reset! (:max-total-pnl agent)  @(:total-pnl agent)))
                    (if live? (execution/BUY ib-tic current-position-abs))
                    (timbre/debug (blue &quot;BUY-CLOSE-ON-DRAW &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)  &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)    &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread))
                    (when otl-breached?
                      (swap! (agent :n-otls) inc)                                                                         (timbre/debug (magenta &quot;OTL-BREACH &quot; &quot; tic &quot; ib-tic &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)   &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent))))
                    (when
                     getflat?
                      (timbre/debug (on-yellow (blue &quot;GETFLAT &quot; &quot; tic &quot; ib-tic &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)   &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent))))) (reset! (:allowed-to-enter-long? agent) false)
                    (reset! (:allowed-to-enter-short? agent) false)
                    (reset! (:otl-start-time agent) time-now)))
                (reset! (:cash-account agent) 0.0)  ;; finished one round of trading
                (reset! (:m2m-pnl agent) 0.0)  ;; finished one round of trading
                (reset! (:max-pnl agent) (- 99.0)) ;; finished one round of trading
                (reset! (:min-pnl agent) 99.0)  ;; finished one round of trading)  ;;; when otl)
        (reset! (@((indicator-state tic) date) :pnl) @(:total-pnl agent))))   ;; if eod))</pre></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
strong signal -> target position is positive
weak signal -> exit
strong short signal -> target position is negative
weak signal -> exit</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-position-target-limit
  [log-file-name datagen-file datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        price-bars @(@((indicator-state tic) date) :price-bars)
                                        ;sigma (incanter/sd price-bars)
        ;price-band [ (utils/round (- price sigma)) (utils/round (+ price sigma)) ]
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        spread (utils/round (- askprice bidprice)) target-position-prior-with-signal ((:target-position agent) indicator-state tic date)
        target-position-prior (first target-position-prior-with-signal)
        signal-state (second target-position-prior-with-signal) exit-position ((:exit-position agent) indicator-state tic date)
        ;reference-price ( (:reference-price agent) indicator-state tic date) ;; only units 0 -&gt; 5 -&gt; -5
        capital 10000.0
        max-uts (:data (indicators/position-to-take capital indicator-state tic date)) ;; the jump from 0 is this position
        calc-uts ((:target-size agent) indicator-state tic date) ;; can be NaN
        uts (apply min [max-uts calc-uts])
        ;market-uts (:data (indicators/position-to-take capital indicator-state :SPY date)) ;; the jump from 0 is this position
        current-position @(agent :position)
        current-position-abs (incanter/abs current-position)
        current-position-status @(agent :position-status)  ;; this is + 1 -1 or 0 ; long short or flat
        getflat? (and (not (zero? exit-position)) (not (zero? current-position-status)) (not= current-position-status exit-position))
        ;target-position (cond (neg? (* current-position target-position-prior)) 0.0 :else target-position-prior )
        ;; if we have position ignore signal and use drawdowns to exit (or ttc) - a hack
        target-position (cond (not (zero? current-position)) current-position-status :else target-position-prior)  ;;t-p is always a unit quantity
        position-diff (cond (Double/isNaN target-position) 0.0 :else (- target-position current-position-status))
        position-diff-abs (incanter/abs position-diff) unsigned-actual-trade-size (* uts position-diff-abs)  ;; typically 1 or 2 times uts, signed quantity ; causes residual positions for now fix later
        ;unsigned-market-trade-size (* market-uts position-diff-abs)
        current-n-trades @(agent :n-trades)
        current-n-otls @(agent :n-otls)
;;correct pnl accounting, if long i can get out on bid only
        ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
        agent-name (agent :agent-name) time-now @timekeeper/global-time-now
        time-string @(@((indicator-state tic) date) :time-string)
        ;max-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        total-pnl @(:total-pnl agent) ;; this is in dollars now
        eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.5
        first-datapoint? (not (.exists (io/as-file datagen-file))) datagen-output (cond (nil? (:datagen agent)) nil
                                                                                        :else ((:datagen agent) indicator-state tic date))
        live? (cond (nil? @(:live? agent)) false :else @(:live? agent)) ;; place orders
        time @(:seq-no @((indicator-state tic) date))
        ib-tic (name tic)
        cash-account @(:cash-account agent) ;; this is in bps
        m2m-pnl @(:m2m-pnl agent)
        max-pnl @(:max-pnl agent)
        draw (- max-pnl m2m-pnl)
        allowed-drawdown (utils/drawdown-at-pnl (apply max [max-pnl total-pnl]))
        drawdown-breached? (&gt; draw allowed-drawdown)
        tentative-max-otl 100.0
        ;(apply max [ ( (:max-otl2 agent) indicator-state tic date) 100.0  ])
        allowed-to-enter-long? (and (not= tic :SPY) (not (Double/isNaN uts)) (not (Double/isNaN tentative-max-otl)) @(:allowed-to-enter-long? agent) (&lt; current-n-trades (agent :max-n-trades)) (&lt; @(agent :n-otls) (agent :max-otls))   (&lt;= spread (agent :max-spread)))
        allowed-to-enter-short? (and (not= tic :SPY) (not (Double/isNaN uts)) (not (Double/isNaN tentative-max-otl)) @(:allowed-to-enter-short? agent) (&lt; current-n-trades (agent :max-n-trades))  (&lt; @(agent :n-otls) (agent :max-otls))   (&lt;= spread (agent :max-spread)))
;;correct pnl accounting, if long i can get out on bid only
        ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
        reference-price ((:reference-price agent) indicator-state tic date) otl-breached? (&gt;= (- m2m-pnl) @(:max-otl agent))
        otl-sleep (* 60000 (:break-after-otl-minutes agent))
        time-since-last-otl-msecs (- time-now @(:otl-start-time agent));; now i take care of max-total-pnl, where a good thing is preserved
        max-total-pnl @(:max-total-pnl agent)
        ;m2m-pnl-relevant (cond (neg? m2m-pnl) (- m2m-pnl) :else 0) ;; only if negative i worry
        go-home-pnl (+ total-pnl m2m-pnl) ;; this is my total-pnl-draw
        total-pnl-draw (- max-total-pnl go-home-pnl)
        total-allowed-drawdown (utils/drawdown-at-pnl max-total-pnl)
        total-drawdown-breached? (&gt; total-pnl-draw total-allowed-drawdown)
        last-entry-time  (cond (zero? @(tic trackorders/order-fill-time)) Double/NaN :else  @(tic trackorders/order-fill-time))
        ttc-now-minutes (cond (zero? current-position) 0.0 :else (utils/round (/ (- time-now last-entry-time) 60000)))
        ttc-breached? (cond (nil? ttc-now-minutes) false :else (&gt;= ttc-now-minutes (:max-ttc-minutes agent)))
        actual-position (incanter/abs  @(tic trackorders/order-inventory))
        actual-signed-position @(tic trackorders/order-inventory)]
    ;;remember eod positions and total-pnls are not correct in datagen bcos
    ;; after eod it does not print another point
    (if (and eod? (not eod-plus-one?))
      ;; if EOD close with market orders - fix size I have now, this is not current pos
      (do
        (when (not (zero? actual-position))
          (reset! (:position-status agent) 0)
          (reset! (:position agent) 0)
          (reset! (:eod-position agent) current-position)
          (swap! (:n-trades agent) inc)
          (if (pos? actual-signed-position) (swap! (:cash-account agent) + (* current-position-abs bidprice)) (swap! (:cash-account agent) - (* current-position-abs askprice)))
          (reset! (:allowed-to-enter-long? agent) false)
          (reset! (:allowed-to-enter-short? agent) false)
          (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
          (if (pos? actual-signed-position)
            (do (if live? (execution/SELL ib-tic actual-position))
                (timbre/debug (red &quot;EODSELLCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; askprice &quot; current-position &quot; actual-signed-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl   &quot; total-pnl &quot; @(:total-pnl agent))))
            (do (if live? (execution/BUY ib-tic actual-position))
                (timbre/debug (green &quot;EODBUYCLOSE &quot; &quot; tic &quot; ib-tic &quot; price &quot; askprice &quot; current-position &quot; actual-signed-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl   &quot; total-pnl &quot; @(:total-pnl agent)))))
          (reset! (:m2m-pnl agent) @(:cash-account agent))
;; eod pnl can be max pnl or min
          (let [pnl @(:m2m-pnl agent)]
            (if (&gt; pnl @(:max-pnl agent)) (reset! (:max-pnl agent) pnl))
            (if (&lt; pnl @(:min-pnl agent)) (reset! (:min-pnl agent) pnl))))
        (reset! (@((indicator-state tic) date) :eod-plus-one?)  true) ;; marking eod process complete and end of trading
        (reset! (@((indicator-state tic) date) :pnl) @(:total-pnl agent)))   ;; end EOD stuff
;; if not EOD
      (when-not eod?   ;;;  this is because of eod-plus-one flag becomes true at last step
        (when-not (zero? position-diff-abs)  ;;some positions to be taken/eliminated
;; this should be a limit order
          (when (and (pos? target-position) allowed-to-enter-long?
                ;; allowed to enter long
                     @(:allowed-to-enter-long? agent)
               ;; if high-imp true, i dont send orders! Just wait.
                     (not @((keyword ib-tic) trackorders/high-impedance)))
            (swap! (:position agent) + 100)
            (reset! (:position-status agent) target-position)
            (swap! (:last-entry-price agent) conj askprice)
            (reset! (:last-entry-time agent) time-now)
            (swap! (:cash-account agent) - (* 100 askprice))
            (reset! (:max-otl agent) tentative-max-otl)
            (reset! (:last-entry-time agent) time-now)
                                        ;(execution/buy-hedge-new tic unsigned-actual-trade-size unsigned-market-trade-size  )
            (if live? (execution/BUY-LIMIT ib-tic (utils/round2 2 bidprice)  100))
           ;; now you wait for order confirmation
            (reset! ((keyword ib-tic) trackorders/high-impedance) true)
           ;; set high impedance here, cant do anything when i wait
            (timbre/debug (green &quot;BUY-LIMIT &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time  &quot; price &quot; bidprice &quot; somany &quot; 100 &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl &quot; total-pnl &quot; @(:total-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent) &quot; draw &quot; draw &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent)  &quot; signal-state &quot; signal-state))
            (swap! (:n-trades agent) inc)
            (let [current-position @(agent :position)
                  current-position-abs (incanter/abs current-position)
                 ;;correct pnl accounting, if long i can get out on bid only
                 ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
                  value-of-positions (* reference-price current-position)
                  net-value (+ @(agent :cash-account)  value-of-positions)]
              (reset! (:m2m-pnl agent) net-value)
              (if (&gt;= net-value @(:max-pnl agent)) (reset! (:max-pnl agent) net-value))
              (if (&lt;= net-value @(:min-pnl agent)) (reset! (:min-pnl agent) net-value))
              (timbre/debug (yellow &quot;M2M &quot; &quot; tic &quot; ib-tic &quot; time &quot; time  &quot; price &quot; reference-price &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; total-pnl &quot; @(:total-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)  &quot; draw &quot; draw &quot; spread &quot; spread))))
         ;; again limit order here
          (when (and (neg? target-position) allowed-to-enter-short?
                     @(:allowed-to-enter-short? agent)
                     (not @((keyword ib-tic) trackorders/high-impedance)))
            (swap! (:position agent) - 100)
            (reset! (:position-status agent) target-position)
            (swap! (:last-entry-price agent) conj askprice)
            (reset! (:last-entry-time agent) time-now)
            (swap! (:cash-account agent) + (* 100 bidprice))
            (reset! (:max-otl agent) tentative-max-otl)
            (reset! (:last-entry-time agent) time-now)
                                        ;(execution/sell-hedge-new tic unsigned-actual-trade-size unsigned-market-trade-size  )
            (if live? (execution/SELL-LIMIT ib-tic (utils/round2 2 askprice) 100))
            (reset! ((keyword ib-tic) trackorders/high-impedance) true)
            (timbre/debug (red &quot;SELL-LIMIT &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time  &quot; price &quot; bidprice &quot; somany &quot; unsigned-actual-trade-size &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; m2m-pnl &quot; total-pnl &quot; @(:total-pnl agent)  &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent) &quot; draw &quot; draw &quot; spread &quot; spread  &quot; max-otl &quot; @(:max-otl agent)  &quot; signal-state &quot; signal-state))
            (swap! (:n-trades agent) inc)
            (let [current-position @(agent :position)
                  current-position-abs (incanter/abs current-position)
                 ;;correct pnl accounting, if long i can get out on bid only
                 ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
                  value-of-positions (* reference-price current-position)
                  net-value (+ @(agent :cash-account)  value-of-positions)]
              (reset! (:m2m-pnl agent) net-value)
              (if (&gt;= net-value @(:max-pnl agent)) (reset! (:max-pnl agent) net-value))
              (if (&lt;= net-value @(:min-pnl agent)) (reset! (:min-pnl agent) net-value))
              (timbre/debug (yellow &quot;M2M &quot; &quot; tic &quot; ib-tic &quot; time &quot; time  &quot; price &quot; reference-price &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; @(:cash-account agent) &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; total-pnl &quot; @(:total-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)  &quot; draw &quot; draw &quot; spread &quot; spread)))))
  ;;; m2m pnl update when not doing anythin
        (if (not ttc-breached?)
          (when (pos? (incanter/abs  @(tic trackorders/order-inventory)))
                        ;; only exit mechanism now is when not eod, try to exit at best price
            (cond
              (and (pos? @(tic trackorders/order-inventory))
                   (&gt; (*  @(tic trackorders/order-inventory) (- askprice @(tic trackorders/order-fills))) 3)
                   (not @((keyword ib-tic) trackorders/high-impedance)))
              (do
                (swap! (:position agent) - current-position-abs)
                (reset! (:position-status agent) 0.0)
                (swap! (:last-exit-price agent) conj price)
                                        ;(reset! (:max-pnl-this-round agent) 0.0)
                (reset! (:last-entry-time agent) nil)
                (swap! (:n-trades agent) inc)
                (swap! (:cash-account agent) + (* current-position-abs bidprice))
                                        ;(reset! (:m2m-pnl agent)  @(:cash-account agent)  ) ;;; this is round pnl (total pnl is sum of rounds)
                                        ;(swap! (:total-pnl agent) + (utils/round @(:cash-account agent)    )  )
                (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
                (if (&gt; @(:total-pnl agent) @(:max-total-pnl agent)) (reset! (:max-total-pnl agent)  @(:total-pnl agent)))
                (if live? (execution/SELL-LIMIT ib-tic (utils/round2 2 askprice) (incanter/abs @(tic trackorders/order-inventory))))
                (reset! ((keyword ib-tic) trackorders/high-impedance) true)
                (timbre/debug (on-white (red &quot;SELL-CLOSE-PASSIVE &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)   &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw  &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread))) (reset! (:allowed-to-enter-long? agent) false)
                (reset! (:allowed-to-enter-short? agent) false)
                (reset! (:otl-start-time agent) time-now))
              (and (neg?  @(tic trackorders/order-inventory))
                   (&gt;  @(tic trackorders/order-fills) bidprice)
                   (&gt; (*  @(tic trackorders/order-inventory) (- bidprice @(tic trackorders/order-fills))) 3)
                   (not @((keyword ib-tic) trackorders/high-impedance)))
              (do
                (swap! (:position agent) + current-position-abs)
                (reset! (:position-status agent) 0.0)
                (swap! (:last-exit-price agent) conj price)
                (reset! (:last-entry-time agent) nil)
                (swap! (:n-trades agent) inc)
                (swap! (:cash-account agent) - (* current-position-abs askprice))
                                        ;(reset! (:m2m-pnl agent)  @(:cash-account agent)  )
                (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
                (if (&gt; @(:total-pnl agent) @(:max-total-pnl agent)) (reset! (:max-total-pnl agent)  @(:total-pnl agent)))
                (if live? (execution/BUY-LIMIT ib-tic (utils/round2 2 bidprice) (incanter/abs @(tic trackorders/order-inventory))))
                (reset! ((keyword ib-tic) trackorders/high-impedance) true)
                (timbre/debug (blue &quot;BUY-CLOSE-PASSIVE &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time &quot; price &quot; bidprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)  &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)    &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread))
                (reset! (:allowed-to-enter-long? agent) false)
                (reset! (:allowed-to-enter-short? agent) false)
                (reset! (:otl-start-time agent) time-now)))
            (reset! (:cash-account agent) 0.0) ;; finished one round of trading
            (reset! (:m2m-pnl agent) 0.0) ;; finished one round of trading
            (reset! (:max-pnl agent) (- 99.0)) ;; finished one round of trading
            (reset! (:min-pnl agent) 99.0) ;; finished one round of trading
;;; when otl)
      ;;if ttc breached exit aggress
          (when (pos? (incanter/abs  @(tic trackorders/order-inventory)))
                        ;; only exit mechanism now is when not eod, try to exit at best price
            (cond
              (and (pos? @(tic trackorders/order-inventory)) (not @((keyword ib-tic) trackorders/high-impedance)))
              (do
                (swap! (:position agent) - current-position-abs)
                (reset! (:position-status agent) 0.0)
                (swap! (:last-exit-price agent) conj price)
                                        ;(reset! (:max-pnl-this-round agent) 0.0)
                (reset! (:last-entry-time agent) nil)
                (swap! (:n-trades agent) inc)
                (swap! (:cash-account agent) + (* current-position-abs bidprice))
                                        ;(reset! (:m2m-pnl agent)  @(:cash-account agent)  ) ;;; this is round pnl (total pnl is sum of rounds)
                                        ;(swap! (:total-pnl agent) + (utils/round @(:cash-account agent)    )  )
                (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
                (if (&gt; @(:total-pnl agent) @(:max-total-pnl agent)) (reset! (:max-total-pnl agent)  @(:total-pnl agent)))
                (if live? (execution/SELL ib-tic (incanter/abs @(tic trackorders/order-inventory))))
                (reset! ((keyword ib-tic) trackorders/high-impedance) true)
                (timbre/debug (on-white (red &quot;SELL-CLOSE-AGG &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time &quot; price &quot; askprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent) &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)   &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw  &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread))) (reset! (:allowed-to-enter-long? agent) false)
                (reset! (:allowed-to-enter-short? agent) false)
                (reset! (:otl-start-time agent) time-now))
              (and (neg?  @(tic trackorders/order-inventory))
                   (&gt;  @(tic trackorders/order-fills) bidprice) (not @((keyword ib-tic) trackorders/high-impedance)))
              (do
                (swap! (:position agent) + current-position-abs)
                (reset! (:position-status agent) 0.0)
                (swap! (:last-exit-price agent) conj price)
                (reset! (:last-entry-time agent) nil)
                (swap! (:n-trades agent) inc)
                (swap! (:cash-account agent) - (* current-position-abs askprice))
                                        ;(reset! (:m2m-pnl agent)  @(:cash-account agent)  )
                (swap! (:total-pnl agent) + (utils/round (- @(:cash-account agent) (* commission 2))))
                (if (&gt; @(:total-pnl agent) @(:max-total-pnl agent)) (reset! (:max-total-pnl agent)  @(:total-pnl agent)))
                (if live? (execution/BUY ib-tic (incanter/abs @(tic trackorders/order-inventory))))
                (reset! ((keyword ib-tic) trackorders/high-impedance) true)
                (timbre/debug (blue &quot;BUY-CLOSE-AGG &quot; &quot; tic &quot; ib-tic &quot; time-string &quot; time-string &quot; time &quot; time &quot; price &quot; bidprice &quot; current-position &quot; current-position &quot; n-trades &quot; current-n-trades &quot; cash-account &quot; cash-account &quot; m2m-pnl &quot; @(:m2m-pnl agent)  &quot; max-pnl &quot; @(:max-pnl agent) &quot; min-pnl &quot; @(:min-pnl agent)    &quot; total-pnl &quot; @(:total-pnl agent) &quot; draw &quot; draw &quot; allowed-drawdown &quot; allowed-drawdown &quot; spread &quot; spread))
                (reset! (:allowed-to-enter-long? agent) false)
                (reset! (:allowed-to-enter-short? agent) false)
                (reset! (:otl-start-time agent) time-now)))
            (reset! (:cash-account agent) 0.0) ;; finished one round of trading
            (reset! (:m2m-pnl agent) 0.0) ;; finished one round of trading
            (reset! (:max-pnl agent) (- 99.0)) ;; finished one round of trading
            (reset! (:min-pnl agent) 99.0) ;; finished one round of trading
;;; when otl))
        (reset! (@((indicator-state tic) date) :pnl) @(:total-pnl agent))))   ;; if eod));;; when otl</pre></td></tr><tr><td class="docs"><p>when otl</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
strong signal -> target position is positive
weak signal -> exit
strong short signal -> target position is negative
weak signal -> exit</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-debug
  [log-file-name datagen-file datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        price-bars @(@((indicator-state tic) date) :price-bars)
                                        ;sigma (incanter/sd price-bars)
        ;price-band [ (utils/round (- price sigma)) (utils/round (+ price sigma)) ]
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        spread (utils/round (- askprice bidprice))
        target-position-prior-with-signal ((:target-position agent) indicator-state tic date)
        target-position-prior (first target-position-prior-with-signal)
        signal-state (second target-position-prior-with-signal)
        exit-position ((:exit-position agent) indicator-state tic date)
        ;reference-price ( (:reference-price agent) indicator-state tic date) ;; only units 0 -&gt; 5 -&gt; -5
        capital 10000.0
        max-uts (:data (indicators/position-to-take capital indicator-state tic date)) ;; the jump from 0 is this position
        calc-uts ((:target-size agent) indicator-state tic date) ;; can be NaN
        uts (apply min [max-uts calc-uts])
        ;market-uts (:data (indicators/position-to-take capital indicator-state :SPY date)) ;; the jump from 0 is this position
        current-position @(agent :position)
        current-position-abs (incanter/abs current-position)
        current-position-status @(agent :position-status)  ;; this is + 1 -1 or 0 ; long short or flat
        getflat? (and (not (zero? exit-position)) (not (zero? current-position-status)) (not= current-position-status exit-position))
        ;target-position (cond (neg? (* current-position target-position-prior)) 0.0 :else target-position-prior )
        ;; if we have position ignore signal and use drawdowns to exit (or ttc) - a hack
        target-position (cond (not (zero? current-position)) current-position-status :else target-position-prior)  ;;t-p is always a unit quantity
        position-diff (cond (Double/isNaN target-position) 0.0 :else (- target-position current-position-status))
        position-diff-abs (incanter/abs position-diff) unsigned-actual-trade-size (* uts position-diff-abs)  ;; typically 1 or 2 times uts, signed quantity ; causes residual positions for now fix later
        ;unsigned-market-trade-size (* market-uts position-diff-abs)
        current-n-trades @(agent :n-trades)
;;correct pnl accounting, if long i can get out on bid only
        ;reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price )
        agent-name (agent :agent-name) time-now @(@((indicator-state tic) date) :time)
        time-string @(@((indicator-state tic) date) :time-string)
        ;max-pnl-this-round @(:max-pnl-this-round agent) ;; this is in bps
        total-pnl @(:total-pnl agent) ;; this is in dollars now
        eod? @(@((indicator-state tic) date) :eod?)
        eod-plus-one? @(@((indicator-state tic) date) :eod-plus-one?)
        commission 1.5
        first-datapoint? (not (.exists (io/as-file datagen-file))) datagen-output (cond (nil? (:datagen agent)) nil
                                                                                        :else ((:datagen agent) indicator-state tic date))
        live? (cond (nil? @(:live? agent)) false :else @(:live? agent)) ;; place orders
        time @(:seq-no @((indicator-state tic) date))
        ib-tic (name tic)
        cash-account @(:cash-account agent) ;; this is in bps
        m2m-pnl @(:m2m-pnl agent)
        max-pnl @(:max-pnl agent)
        draw (- max-pnl m2m-pnl)
        allowed-drawdown (utils/drawdown-at-pnl (apply max [max-pnl total-pnl]))
        drawdown-breached? (&gt; draw allowed-drawdown)
        tentative-max-otl 100.0
        ;(apply max [ ( (:max-otl2 agent) indicator-state tic date) 100.0  ])
        allowed-to-enter-long? (and (not (Double/isNaN uts)) (not (Double/isNaN tentative-max-otl)) @(:allowed-to-enter-long? agent) (&lt; current-n-trades (agent :max-n-trades)))
        allowed-to-enter-short? (and (not (Double/isNaN uts)) (not (Double/isNaN tentative-max-otl)) @(:allowed-to-enter-short? agent) (&lt; current-n-trades (agent :max-n-trades)))
;;correct pnl accounting, if long i can get out on bid only
        reference-price (cond (pos? current-position) askprice (neg? current-position) bidprice :else price) otl-breached? (&gt;= (- m2m-pnl) @(:max-otl agent))
        otl-sleep (* 60000 (:break-after-otl-minutes agent))
        time-since-last-otl-msecs (- time-now @(:otl-start-time agent));; now i take care of max-total-pnl, where a good thing is preserved
        max-total-pnl @(:max-total-pnl agent)
        ;m2m-pnl-relevant (cond (neg? m2m-pnl) (- m2m-pnl) :else 0) ;; only if negative i worry
        go-home-pnl (+ total-pnl m2m-pnl) ;; this is my total-pnl-draw
        total-pnl-draw (- max-total-pnl go-home-pnl)
        total-allowed-drawdown (utils/drawdown-at-pnl max-total-pnl)
        total-drawdown-breached? (&gt; total-pnl-draw total-allowed-drawdown)]
    ;;remember eod positions and total-pnls are not correct in datagen bcos
    ;; after eod it does not print another point
    (pprint &quot;Hi&quot;)
    (comment first-datapoint?
             (pprint (utils/coll-&gt;string (:header datagen-output)))
             (pprint (utils/coll-&gt;string (:data datagen-output))))
   ;; if eod))</pre></td></tr><tr><td class="docs"><p>core function, called only when bar data is updated.
to do: otl loss, global max loss ttc cuts larger position</p>

<p>trading logic</p>
</td><td class="codes"><pre class="brush: clojure">(defn trading-logic-datagen
  [datagen? agent indicator-state tic date]
  ;;evaluate long entry
  (let [price @(@((indicator-state tic) date) :price)
        bidprice @(@((indicator-state tic) date) :bidprice)
        askprice @(@((indicator-state tic) date) :askprice)
        ib-tic (name tic)
        datagen-output (cond (nil? (:datagen agent)) nil
                             :else ((:datagen agent) indicator-state tic date))
        datagen-file (str utils/HOME &quot;/data/&quot; (str/lower-case ib-tic) &quot;.&quot; (name date)  &quot;.us.txt&quot;)
        first-datapoint? (not (.exists (io/as-file datagen-file)))
        time @(:seq-no @((indicator-state tic) date))
        ;dummy (log/debug &quot;Trading logic called..&quot;)
        ib-tic (name tic)
        ;dummy (log/debug &quot;Trading logic called..&quot; live? ib-tic)
]
    (when datagen?
      (if (every? utils/notnan? (:data datagen-output))
        (timbre/debug (yellow (utils/coll-&gt;string (concat (:data datagen-output) ;agent-datagen-output)))))
      (if first-datapoint?
        (spit datagen-file (utils/coll-&gt;string (concat (:header datagen-output) ;agent-datagen-header)):append true)
        (if (every? utils/notnan? (:data datagen-output))
          (spit datagen-file (utils/coll-&gt;string (concat (:data datagen-output) ;agent-datagen-output)):append true))))))</pre></td></tr><tr><td class="docs"><p>new</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.trackorders" name="matrix.trackorders"><h1 class="project-name">matrix.trackorders</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.trackorders
  (:require [repltrader.gateway :as g]
            [matrix.tickers :as tickers]
            [matrix.timekeeper :as timekeeper]
            [matrix.indicators :as indicators]
            [matrix.pnl :as pnl]
            [incanter [core :refer [$]
                       :as incanter$]
             [core :as incanter]
             [stats :as stats]
             [io :as io2]
             [charts :as charts]
             [datasets :as dataset]] [clojure.term.colors :refer :all])
  (:use clojure.pprint)
  (:gen-class))</pre></td></tr><tr><td class="docs"><p>on tickers/ticlist-big as sometimes older positions have to be reset on clean</p>
</td><td class="codes"><pre class="brush: clojure">(def portfolio-state (zipmap (map keyword tickers/huge-tickers) (repeatedly (count tickers/huge-tickers) #(atom &quot;Disengaged&quot;))))</pre></td></tr><tr><td class="docs"><p>when this is true, we are waitning for order response</p>
</td><td class="codes"><pre class="brush: clojure">(def high-impedance (zipmap (map keyword tickers/huge-tickers) (repeatedly (count tickers/huge-tickers) #(atom false))))</pre></td></tr><tr><td class="docs"><p>(println high-impedance)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reset-portfolio-state [tic]
  (reset! ((keyword tic) portfolio-state) &quot;Disengaged&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reset-impedance-state-false [tic]
  (reset! ((keyword tic) high-impedance) false))</pre></td></tr><tr><td class="docs"><p>(comment</p>
</td><td class="codes"><pre class="brush: clojure">(def order-fills (zipmap (map keyword tickers/huge-tickers) (repeatedly (count tickers/huge-tickers) #(atom 0))))</pre></td></tr><tr><td class="docs"><p>plus or minus, actual size filled</p>
</td><td class="codes"><pre class="brush: clojure">(def order-inventory (zipmap (map keyword tickers/huge-tickers) (repeatedly (count tickers/huge-tickers) #(atom 0))))</pre></td></tr><tr><td class="docs"><p>the above the actual fill quantities</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def order-fill-time (zipmap (map keyword tickers/huge-tickers) (repeatedly (count tickers/huge-tickers) #(atom 0))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def order-ids (atom {}))
(def exec-ids (atom {}))</pre></td></tr><tr><td class="docs"><p>(swap! order-ids assoc (:permanent-id (:order msg)) [(:action (:order msg))] )
(swap! order-ids assoc 123 "sell")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(identity @order-ids)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment handle-exec-update [{:keys [type contract] :as msg}]
         (when  (and (= type :open-order) (= :filled (:status (:order-state msg))) (not (contains? (set (keys @order-ids))  (:order-id msg))))
           (println &quot;exec update&quot; msg)

           (cond (= :buy (:action (:order msg))) (swap! ((keyword (:local-symbol (:contract msg))) order-inventory) +  (:quantity (:order msg)))
                 :else (swap! ((keyword (:local-symbol (:contract msg))) order-inventory) - (:quantity (:order msg))))

           (swap! order-ids assoc (:order-id msg) (:local-symbol (:contract msg)))))</pre></td></tr><tr><td class="docs"><p>check how many times this updates for a trade</p>
</td><td class="codes"><pre class="brush: clojure">(comment handle-stat-update [{:keys [type contract] :as msg}]
         (when  (and (= type :order-status) (zero? (:remaining msg)))
           (println &quot;stat update&quot; msg)
           (let [tic (@order-ids  (:order-id msg))]
             (reset! ((keyword tic) order-fills)    (:last-fill-price msg)))))</pre></td></tr><tr><td class="docs"><p>exec details message contains all information tied to the order </p>
</td><td class="codes"><pre class="brush: clojure">(defn handle-exec-update
  [{:keys [type contract] :as msg}]
  (when
   (and
           ;; a type exec details message
    (= type :execution-details)
           ;; new order exec report, its not there in my order-ids
    (not (contains? (set (keys @order-ids))  (:order-id (:value msg)))))
   ;; inventory management
    (= :buy (:side (:value msg)))
    (cond (= :buy (:side (:value msg)))  (do
                                           (swap! ((keyword (:local-symbol (:contract msg))) order-inventory) +  (:shares (:value msg)))
                                        ;(if (zero? @((keyword (:local-symbol (:contract msg))) order-inventory) ) (reset-portfolio-state (:local-symbol (:contract msg))))
                                           (reset! ((keyword (:local-symbol (:contract msg))) order-fill-time) @timekeeper/global-time-now)
                                           (reset-impedance-state-false (:local-symbol (:contract msg)))
                                           (pprint (on-white (green (str &quot;increased inventory from IB, tic pnl  &quot; (:local-symbol (:contract msg)) &quot; &quot;  @pnl/pnl)))))
          (= :sell (:side (:value msg)))
          (do (swap! ((keyword (:local-symbol (:contract msg))) order-inventory) -  (:shares (:value msg)))
              (reset! ((keyword (:local-symbol (:contract msg))) order-fill-time) @timekeeper/global-time-now)
              (reset-impedance-state-false (:local-symbol (:contract msg)))
              (pprint (on-white (green (str &quot;decreased inventory from IB, tic pnl  &quot; (:local-symbol (:contract msg)) &quot; &quot; @pnl/pnl)))));(if (zero? @((keyword (:local-symbol (:contract msg))) order-inventory) ) (reset-portfolio-state (:local-symbol (:contract msg))) ));;update the order and exec id database, order is key and value is ticker
    (swap! order-ids assoc (:order-id (:value msg)) (:local-symbol (:contract msg)))
    (swap! exec-ids assoc (:execution-id (:value msg)) (:local-symbol (:contract msg)))
                                        ;if i got a fill that took inventory to a non zero level, update the price that fires an inventory neutralizer maybe
    ;; right now if pending cancel etc, it does nothing
    (let [tic (@order-ids  (:order-id (:value msg)))
          qty @((keyword (:local-symbol (:contract msg))) order-inventory)]
      (when-not (zero? qty)
        (reset! ((keyword tic) order-fills)    (:price (:value msg)))))))</pre></td></tr><tr><td class="docs"><p>(def orderidQueue (zipmap tickers/ticlist (repeatedly (count tickers/ticlist) #(atom 0) )))
(def targetpositionQueue (zipmap tickers/ticlist (repeatedly (count tickers/ticlist) #(atom 0) )))
(def targetsideQueue (zipmap tickers/ticlist (repeatedly (count tickers/ticlist) #(atom "flat") )))
(def realizedpositionQueue (zipmap tickers/ticlist (repeatedly (count tickers/ticlist) #(atom 0) )))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment update-latest-order-id [msg]
         &quot;otherwise I lose track of which order is latest, i keep only latest order&quot;
         (when (= (keyword &quot;open-order&quot;) (:type msg))
           (reset! (orderidQueue (:symbol (:contract msg)))  (:permanent-id (:order msg)))

           (if (= (keyword &quot;buy&quot;) (:action (:order msg)))

             (do
               (reset! (targetpositionQueue (:symbol (:contract msg))) (:quantity (:order msg)))
               (reset! (targetsideQueue (:symbol (:contract msg))) &quot;buy&quot;));(comment(reset! (targetpositionQueue (:symbol (:contract msg))) (- (:quantity (:order msg)))))
      ;(comment (reset! (targetsideQueue (:symbol (:contract msg))) &quot;sell&quot; ))
)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment (defn update-latest-fill [msg]
           (when (= (keyword &quot;order-status&quot;) (:type msg))
             (if (targetsideQueue tic))
             (reset! (realizedpositionQueue (:symbol (:contract msg))) (:filled msg)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do
  (g/subscribe handle-exec-update)
   ;(g/subscribe update-latest-order-id)
)</pre></td></tr><tr><td class="docs"><p>)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>this is order, first open order, then exec details
when order is cancelled you dont get exec report</p>
</td><td class="codes"><pre class="brush: clojure">(def msg {:type :open-order, :order-id 305, :contract {:contract-id 5911, :symbol &quot;BIG&quot;, :exchange &quot;SMART&quot;, :local-symbol &quot;BIG&quot;, :currency &quot;USD&quot;, :type :equity, :include-expired? false, :put-call-right :unknown}, :order {:time-in-force :immediate-or-cancel, :all-or-none? false, :outside-regular-trading-hours? false, :client-id 100, :block-order? false, :limit-price 0.0, :stop-price 0.0, :transmit? true, :type :market, :order-id 305, :hidden? false, :action :buy, :quantity 100, :discretionary-amount 0.0, :sweep-to-fill? false, :permanent-id 1148577392}, :order-state {:status :filled, :initial-margin &quot;1.7976931348623157E308&quot;, :maintenance-margin &quot;1.7976931348623157E308&quot;, :equity-with-loan &quot;1.7976931348623157E308&quot;, :commission 1.7976931348623157E308, :minimum-commission 1.7976931348623157E308, :maximum-commission 1.7976931348623157E308}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg {:type :execution-details, :request-id -1, :contract {:contract-id 5911, :symbol &quot;BIG&quot;, :exchange &quot;ISLAND&quot;, :local-symbol &quot;BIG&quot;, :currency &quot;USD&quot;, :type :equity, :include-expired? false}, :value {:client-id 100, :account-code &quot;DU242353&quot;, :cummulative-quantity 100, :time &quot;20170825  13:34:06&quot;, :average-price 48.73, :order-id 305, :execution-id &quot;00018037.59a04efc.01.01&quot;, :side :buy, :exchange &quot;ISLAND&quot;, :price 48.73, :shares 100, :permanent-id 1148577392, :liquidate-last 0}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg {:last-fill-price 48.73, :average-fill-price 48.73, :client-id 100, :remaining 0, :why-held nil, :type :order-status, :status :filled, :order-id 305, :parent-id 0, :filled 100, :permanent-id 1148577392})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg {:type :open-order, :order-id 305, :contract {:contract-id 5911, :symbol &quot;BIG&quot;, :exchange &quot;SMART&quot;, :local-symbol &quot;BIG&quot;, :currency &quot;USD&quot;, :type :equity, :include-expired? false, :put-call-right :unknown}, :order {:time-in-force :immediate-or-cancel, :all-or-none? false, :outside-regular-trading-hours? false, :client-id 100, :block-order? false, :limit-price 0.0, :stop-price 0.0, :transmit? true, :type :market, :order-id 305, :hidden? false, :action :buy, :quantity 100, :discretionary-amount 0.0, :sweep-to-fill? false, :permanent-id 1148577392}, :order-state {:status :filled, :initial-margin &quot;1.7976931348623157E308&quot;, :maintenance-margin &quot;1.7976931348623157E308&quot;, :equity-with-loan &quot;1.7976931348623157E308&quot;, :commission 1.0, :minimum-commission 1.7976931348623157E308, :maximum-commission 1.7976931348623157E308, :commission-currency &quot;USD&quot;}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg {:last-fill-price 48.73, :average-fill-price 48.73, :client-id 100, :remaining 0, :why-held nil, :type :order-status, :status :filled, :order-id 305, :parent-id 0, :filled 100, :permanent-id 1148577392})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg {:type :commission-report, :report {:commission 1.0, :currency &quot;USD&quot;, :execution-id &quot;00018037.59a04efc.01.01&quot;, :realized-profit-loss 1.7976931348623157E308, :yield 1.7976931348623157E308, :yield-redemption-date 0}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg {:type :open-order, :order-id 305, :contract {:contract-id 5911, :symbol &quot;BIG&quot;, :exchange &quot;SMART&quot;, :local-symbol &quot;BIG&quot;, :currency &quot;USD&quot;, :type :equity, :include-expired? false, :put-call-right :unknown}, :order {:time-in-force :immediate-or-cancel, :all-or-none? false, :outside-regular-trading-hours? false, :client-id 100, :block-order? false, :limit-price 0.0, :stop-price 0.0, :transmit? true, :type :market, :order-id 305, :hidden? false, :action :buy, :quantity 100, :discretionary-amount 0.0, :sweep-to-fill? false, :permanent-id 1148577392}, :order-state {:status :filled, :initial-margin &quot;1.7976931348623157E308&quot;, :maintenance-margin &quot;1.7976931348623157E308&quot;, :equity-with-loan &quot;1.7976931348623157E308&quot;, :commission 1.0, :minimum-commission 1.7976931348623157E308, :maximum-commission 1.7976931348623157E308, :commission-currency &quot;USD&quot;}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg {:last-fill-price 48.73, :average-fill-price 48.73, :client-id 100, :remaining 0, :why-held nil, :type :order-status, :status :filled, :order-id 305, :parent-id 0, :filled 100, :permanent-id 1148577392})
(:symbol (:contract msg))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def msg2
  {:type :execution-details, :request-id -1, :contract {:include-expired? false, :type :equity,
                                                        :currency &quot;USD&quot;, :local-symbol &quot;Y&quot;, :exchange &quot;NYSE&quot;, :symbol &quot;Y&quot;, :contract-id 13999}, :value {:client-id 100, :account-code &quot;DU242353&quot;,
                                                                                                                                                        :cummulative-quantity 100, :time &quot;20151109  10:53:40&quot;, :average-price 501.78, :order-id 463, :execution-id &quot;00018037.56494702.01.01&quot;,
                                                                                                                                                        :side :sell, :exchange &quot;NYSE&quot;, :price 501.78, :shares 100, :permanent-id 215958916, :liquidate-last 0}})</pre></td></tr><tr><td class="docs"><p>(reset! (orderidQueue (:symbol (:contract msg)))  (:permanent-id (:order msg)))
(reset! (orderidQueue (:symbol (:contract msg)))  (:permanent-id (:order msg)) )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(:action (:order msg))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.tickers_big" name="matrix.tickers_big"><h1 class="project-name">matrix.tickers_big</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.tickers_big
  (:require
   [matrix.utils :as u]
   [net.cgrand.enlive-html :as enlive]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clojure.data.json :as json]
   [incanter.zoo :as zoo]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [clj-time.predicates :as pr]
   [clj-time.local :as l]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clj-http.client :as client]
                                        ;  [structure.ring-buffer :as rb]
                                        ;  [postal.core :as postal]
   [clojure.core.async
    :as a
    :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
            alts! alts!! timeout]]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]]
   [me.raynes.conch :refer [programs with-programs let-programs] :as sh] [matrix.utils :as utils]) (:use clojure.pprint)
  ;(:use [clj-highcharts.core])
  (:gen-class))</pre></td></tr><tr><td class="docs"><p> use the above urls to retrieve ticker list for nyse and nasdaq, cutoff at certain points</p>

<p>initialize nasdaq and nyse ticker, our trading universe</p>
</td><td class="codes"><pre class="brush: clojure">(do (def HOME u/HOME)
    (def mc-cutoff 800E6)
    (def price-cutoff 5)
    (def adv-cutoff-millions 10)
    (def urls [&quot;http://www.nasdaq.com/screening/companies-by-industry.aspx?exchange=NASDAQ&amp;render=download&quot; &quot;http://www.nasdaq.com/screening/companies-by-industry.aspx?exchange=NYSE&amp;render=download&quot;])
    (defn retrieve-symbols
      [mc-cutoff price-cutoff adv-cutoff-millions url] (let [data (io2/read-dataset url :header true)
                                                             nasdaq (incanter/to-dataset data)
                                                             symbols (incanter$/$ :Symbol nasdaq)
                                                             name_ (incanter$/$ :Name nasdaq)
                                                             lastsale (incanter$/$ :LastSale nasdaq)
                                                             market-cap (incanter$/$ :MarketCap nasdaq)
                                                             sector (incanter$/$ :Sector nasdaq)
                                                             industry (incanter$/$ :Industry nasdaq)
                                                             filter-data0 (map vector symbols name_ lastsale market-cap sector industry)
                                                             filter-data1 (filter #(number? (nth % 2)) filter-data0)
                                                             filter-data2-nasdaq (filter #(and (&gt;= (nth % 2) price-cutoff) (&gt;= (nth % 3) mc-cutoff)) filter-data1)]
                                                         filter-data2-nasdaq))
    (def nasdaq-data (retrieve-symbols mc-cutoff price-cutoff adv-cutoff-millions (first urls)))
    (def nyse-data (retrieve-symbols mc-cutoff price-cutoff adv-cutoff-millions (second urls)))
    (def tickers (set (concat (map first nyse-data)  (map first nasdaq-data))))
    (count tickers)
    (def stock-names-nyse (zipmap (map first nyse-data)  (map second nyse-data)))
    (def stock-names-nasdaq (zipmap (map first nasdaq-data)  (map second nasdaq-data)))
    (def stock-names (merge stock-names-nyse stock-names-nasdaq))
    (count stock-names))</pre></td></tr><tr><td class="docs"><p>functions around date decision</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(do (defn formatlocal [n offset]
      (let [nlocal (tt/to-time-zone n (tt/time-zone-for-offset offset))]
        (tf/unparse (tf/formatter-local &quot;yyyy-MM-dd hh:mm:ss aa&quot;)
                    nlocal)))
    (defn currentTime []
      (formatlocal (tt/now) -5))
    (defn pad_ [x] (if (= 2 (count (str x))) (identity x) (str &quot;0&quot; x)))
    (defn convert_ [date]
      (str
       (tt/year date)
       (pad_ (tt/month date))
       (pad_ (tt/day date))))
    (defn convert-javatime-to-yyyymmdd [datetime]
      (tt/date-time (read-string (subs datetime
                                       0 4)) (. Integer parseInt (subs datetime 5 7)) (. Integer parseInt (subs datetime 8 10))))
    (def tt_date_  (tt/date-time (read-string (subs (currentTime) 0 4)) (. Integer parseInt (subs (currentTime) 5 7)) (. Integer parseInt (subs (currentTime) 8 10))))
;;asofdata logic
                                        ;(def tt_date_ (tt/date-time 2017 6 4 )  )
    (currentTime)
    (println &quot;today is..&quot;)
    (println tt_date_)
    (identity tt_date_)
    (def tt_date_1 (tt/minus tt_date_ (tt/days 1)))
    (def tt_date_2 (tt/minus tt_date_ (tt/days 2)))
    (def tt_date_3 (tt/minus tt_date_ (tt/days 3)))
    (def tt_date_4 (tt/minus tt_date_ (tt/days 4)))
    (def tt_date_5 (tt/minus tt_date_ (tt/days 5)))
    (def tt_date_14 (tt/minus tt_date_ (tt/days 14)))
    (def tt_date_30 (tt/minus tt_date_ (tt/days 30)))
    (def tt_date_96 (tt/minus tt_date_ (tt/days 96)))
    (def startDate (convert_ tt_date_96))
    (identity startDate)
;; does all logic of weekend adjusting
    (def today_
      (cond (pr/saturday? tt_date_) (identity  (str
                                                (tt/year tt_date_1)
                                                (pad_ (tt/month tt_date_1))
                                                (pad_ (tt/day tt_date_1))))
            (pr/sunday? tt_date_) (identity  (str
                                              (tt/year tt_date_2)
                                              (pad_ (tt/month tt_date_2))
                                              (pad_ (tt/day tt_date_2))))
            :else (convert_ tt_date_)))
    (identity today_)
    (def today_int (atom (read-string today_)))
;(def today_int 20170928)
                                        ;(identity yesterday_)
    (def yesterday_
  ;; if saturday this is t-2
  ;; if sunday this t-3
  ;; else t-1
      (cond (pr/saturday? tt_date_) (identity  (str
                                                (tt/year tt_date_2)
                                                (pad_ (tt/month tt_date_2))
                                                (pad_ (tt/day tt_date_2))))
            (pr/sunday? tt_date_) (identity  (str
                                              (tt/year tt_date_3)
                                              (pad_ (tt/month tt_date_3))
                                              (pad_ (tt/day tt_date_3))))
            (pr/monday? tt_date_) (identity  (str
                                              (tt/year tt_date_3)
                                              (pad_ (tt/month tt_date_3))
                                              (pad_ (tt/day tt_date_3))))
            :else (convert_ tt_date_1)))
;;;;;;; functions around date decision
;; find advs
    (defn dailyBars
      [date1 date2 tic]
      (let [tail (str &quot;&amp;historyType=1&amp;beginTime=&quot; date1 &quot;093000&quot; &quot;&amp;endTime=&quot; date2 &quot;160000&quot;)]
        (:body (client/get (str &quot;http://localhost:5000/barData?symbol=&quot; tic tail)))))
    (defn getBars2
      [tic date minutes]
      (let [tail (str &quot;&amp;historyType=0&amp;intradayMinutes=&quot; minutes &quot;&amp;beginTime=&quot; date &quot;093000&quot; &quot;&amp;endTime=&quot; date &quot;160000&quot;)]
        (:body (client/get (str &quot;http://localhost:5000/barData?symbol=&quot; tic tail)))))
    (defn getReturns2
      [date minutes tic]
      (let
       [data1 (getBars2 tic date minutes)
        data2 (map #(str/split % #&quot;,&quot;) (str/split data1  #&quot;\r\n&quot;))
        price (map read-string (map #(nth % 4) data2))
        logprice (map incanter/log price)
        returns  (map int (map #(* % 10000) (map - (rest logprice) (drop-last logprice))))] (identity returns)))
                                        ;(def startDate (convert_ tt_date_30 ))
                                        ;(identity startDate)
    (def apple-data (clojure.string/split (dailyBars startDate today_ &quot;AAPL&quot;) #&quot;\r\n&quot;))
    (def N (count apple-data))
    (identity N)
;;;find advs
    (defn ohlcv-dumb [tic]
      (let [apple-data (clojure.string/split (dailyBars startDate today_ tic) #&quot;\r\n&quot;)
            N-local (count apple-data)
            data (map #(clojure.string/split % #&quot;,&quot;) apple-data)
            close-price (map read-string (map  #(nth % 4) data))
            open-price  (map read-string (map #(nth % 1) data))
            high-price  (map read-string (map  #(nth % 2) data))
            low-price  (map read-string (map  #(nth % 3) data))
            volumes  (map read-string (map  #(nth % 5) data))
            avg-price (stats/mean close-price)
            stock-type (cond (&lt;= avg-price 15) &quot;small&quot;
                             (&gt;= avg-price 90) &quot;large&quot;
                             :else &quot;mid&quot;)
            adv-in-millions (u/round2 2 (/ (stats/mean (map * volumes close-price)) 1E6))
            d [0]  ;; dummy data
            good-data {:aprice avg-price :type stock-type :aticker tic :status &quot;Active&quot; :o open-price :c close-price :h high-price :l low-price :v volumes :adv adv-in-millions}
            bad-data {:aprice 100 :type stock-type :aticker tic :status &quot;Inactive&quot; :o d :c d :h d :l d :v d :adv 0}] (if (&lt; N-local N) (identity bad-data) (identity good-data))))
    (defn ohlcv-dumb2 [tic]
      (let [apple-data (clojure.string/split (dailyBars startDate today_ tic) #&quot;\r\n&quot;)
            N-local (count apple-data)
            data (map #(clojure.string/split % #&quot;,&quot;) apple-data)
            close-price (map read-string (map  #(nth % 4) data))
            dates-long (map read-string (map  #(nth % 0) data))
            dates (map #(/ % 1000000) dates-long)
            open-price  (map read-string (map #(nth % 1) data))
            high-price  (map read-string (map  #(nth % 2) data))
            low-price  (map read-string (map  #(nth % 3) data))
            volumes  (map read-string (map  #(nth % 5) data))
            avg-price (stats/mean close-price)
            stock-type (cond (&lt;= avg-price 15) &quot;small&quot;
                             (&gt;= avg-price 90) &quot;large&quot;
                             :else &quot;mid&quot;)
            adv-in-millions (u/round2 2 (/ (stats/mean (map * volumes close-price)) 1E6))
            d [0]  ;; dummy data
            good-data {:aprice avg-price :type stock-type :aticker tic :status &quot;Active&quot; :o open-price :c close-price :h high-price :l low-price :v volumes :adv adv-in-millions :dates dates}] (if (&lt; N-local N) (identity nil) (identity good-data))))
                                        ;(map #(take 10 (second %)) (ohlcv-dumb2 &quot;TSLA&quot;))
                                        ;(map class (map second (ohlcv-dumb2 &quot;TSLA&quot;)))
    (def ohlcv (clojure.core/memoize ohlcv-dumb2))
    (defn recent-dates []
      (:dates (ohlcv &quot;AAPL&quot;)))
    (defn ohlcv-date [date tic]
      (let [data  (ohlcv tic)
            out-data (cond (nil? data) (identity nil)
                           :else
                           (let [close-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:c data))))
                                 open-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:o data))))
                                 high-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:h data))))
                                 low-price (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:l data))))
                                 volumes (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:v data))))
                                 adv-in-millions (u/round2 2 (/ (stats/mean (map * volumes close-price)) 1E6))
                                 dates (map second (filter #(&lt; (first %) date)  (map vector (:dates data)  (:dates data))))
                                 avg-price (stats/mean close-price)]
                             {:aprice avg-price :type (:stock-type data) :aticker tic :status &quot;Active&quot; :o open-price :c close-price :h high-price :l low-price :v volumes :adv adv-in-millions :dates dates}))]
        (identity out-data))));;end do</pre></td></tr><tr><td class="docs"><p>end do</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>finished tracking all eligible tickers for trading, now see earnings page.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ema [HL values]
  (reductions (fn [running v]
                (let [f (/ 2 (+ 1 HL))
                      one-minus-F (- 1 f)] ;naming intermediate results can help with the readability of non-associative operators.
                  (+ (* f v)
                     (* one-minus-F running))))
              values))</pre></td></tr><tr><td class="docs"><p>(def ohlcv-data (map ohlcv (take 10 (concat (map first filter-data2-nyse)  (map first filter-data2-nasdaq)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>being rank indicators</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>simple trend using return series
indicators are maps with header and dates
data is always adapted, ie data with 20160729 is avl start of 20170729</p>
</td><td class="codes"><pre class="brush: clojure">(defn trend
  [fast slow aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [p (:c tech)
                                        dates (rest (:dates tech))
                                        rets  (map u/return_bps (rest p)  (drop-last p))
                                        adj-price (u/csum (u/winsorize 2 rets))
                                        trend (map - (ema fast adj-price) (ema slow adj-price))]
                ;(count dates)
                                    {:data (utils/lag 1  (map (partial u/round2 2)  trend))
                                     :dates dates
                                     :header &quot;trend&quot;}))))</pre></td></tr><tr><td class="docs"><p>simple trend using return series
indicators are maps with header and dates
live indicators are to be used for intraday ranking
ie what is the top price-open stock now?</p>
</td><td class="codes"><pre class="brush: clojure">(defn simple-trend-live
  [slow aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [p (:c tech)
                                        dates (rest (:dates tech))
                                        ema-p (ema slow p)
                                        rets  (map u/return_bps p  ema-p)]
                ;(count dates)
                                    {;:data (map (partial u/round2 2)  trend)
                                     :data ema-p
                                     :dates dates
                                     :header &quot;trend&quot;}))))</pre></td></tr><tr><td class="docs"><p>now minus yesterdays close
indicators are maps with header and dates
live indicators are to be used for intraday ranking
ie what is the top price-open stock now?</p>
</td><td class="codes"><pre class="brush: clojure">(defn movement-live
  [aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [p (:c tech)
                                        dates (:dates tech)
                                        lag-p (u/lag 1 p)
                                        rets  (map u/return_bps p  lag-p)]
                ;(count dates)
                                    {;:data (map (partial u/round2 2)  trend)
                                     :data rets
                                     :dates dates
                                     :header &quot;trend&quot;}))))</pre></td></tr><tr><td class="docs"><p>now minus yesterdays close
indicators are maps with header and dates
live indicators are to be used for intraday ranking
ie what is the top price-open stock now?</p>
</td><td class="codes"><pre class="brush: clojure">(defn intraday-movement-live
  [aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [c (:c tech)
                                        o (:o tech)
                                        dates (:dates tech) rets  (map u/return_bps c o)]
                ;(count dates)
                                    {;:data (map (partial u/round2 2)  trend)
                                     :data rets
                                     :dates dates
                                     :header &quot;intraday-movement-live&quot;}))))</pre></td></tr><tr><td class="docs"><p>(u/view-indicator (movement-live "MTW"))
(ohlcv "MTW")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>intraday trend - ignore moves across days</p>
</td><td class="codes"><pre class="brush: clojure">(defn trend2
  [fast slow aticker]
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [c (:c tech)
                                        o (:o tech)
                                        rets  (map u/return_bps c o)
                                        adj-price (u/csum (u/winsorize 2 rets))
                                        trend (map - (ema fast adj-price) (ema slow adj-price))] (map (partial u/round2 2)  trend)))))</pre></td></tr><tr><td class="docs"><p>(identity (trend 1 3 "EGBN"))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn getBars2
  [tic date minutes]
  (let [tail (str &quot;&amp;historyType=0&amp;intradayMinutes=&quot; minutes &quot;&amp;beginTime=&quot; date &quot;093000&quot; &quot;&amp;endTime=&quot; date &quot;160000&quot;)
        data (:body (client/get (str &quot;http://localhost:5000/barData?symbol=&quot; tic tail)))
        test (first (first (map #(str/split % #&quot;,&quot;) (str/split data  #&quot;\r\n&quot;))))
        answer (cond (= &quot;00000000000000&quot; test) (identity nil) :else (identity data))]
    (identity answer)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-close [aticker]
  &quot;which ones broke today?&quot;
  (let [tech (ohlcv aticker)] (if (nil? tech) (identity nil)
                                  (let [c (:c tech)]
                ;(last (drop-last c))
                                    (last c)))))</pre></td></tr><tr><td class="docs"><p>(last-close "AAPL")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn returns-from-yesterday [date yesterday_ minutes tic]
  (let
   [data1 (getBars2 tic date minutes)
    lc    (last-close tic)
    return-from-yesterday (cond (or (zero? lc) (nil? lc) (nil? data1)) (identity nil)
                                :else
                                (let [data2 (map #(str/split % #&quot;,&quot;) (str/split data1  #&quot;\r\n&quot;))
                                      price (map read-string (map #(nth % 4) data2))
                                      logprice (map incanter/log price)
   ;;; now see if last days close to now is actually significant
                                      return (- (last logprice) (incanter/log lc))] (u/round2 4 return)
;(identity data1)))]
    (identity return-from-yesterday)))</pre></td></tr><tr><td class="docs"><p>(returns-from-yesterday today_ yesterday_ 1 "DBD")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(last-close "AAPL")
(getBars2 "AAPL" today_ 1)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(trend 8 16 "JNJ")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(conj [1 2] '())</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(println (filter #(&lt; % (- 3)) (zscore rets)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>test for winsorize</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ATR-bps [aticker]
  &quot;coll of ATR numbers&quot;
  (let  [tech (ohlcv aticker)
         h (cond (nil? tech) nil :else
                 (:h tech))
         l (cond (nil? tech) nil :else
                 (:l tech))
         c (cond (nil? tech) nil :else
                 (:c tech))]
    (if (nil? h)
      (identity nil)
      (let [hl (rest (map incanter/abs (map u/return_bps h l)))
            first-day-atr (first (map incanter/abs (map u/return_bps h l)))
            hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
            lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))]
        (map u/winsorize-returns (conj (map #(apply max %) (map vector hl hc lc))  first-day-atr))
;(identity tech)))))</pre></td></tr><tr><td class="docs"><p>(conj (ATR-bps "AAPL") -99 )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn close-open-bps [aticker]
  &quot;coll of close minus open in bps&quot;
  (let  [tech (ohlcv aticker)
         o (cond (nil? tech) nil :else
                 (:o tech))
         c (cond (nil? tech) nil :else
                 (:c tech))]
    (if (nil? o)
      nil (map u/winsorize-returns (map incanter/abs (map u/return_bps c o))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn volume-change-bps [aticker]
  &quot;coll of&quot;
  (let  [tech (ohlcv aticker)
         v (cond (nil? tech) nil :else
                 (:v tech))
         lag-v (utils/lag 1 v)]
    (if (nil? v)
      nil (map u/winsorize-returns (map incanter/abs (map u/return_bps v lag-v))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ATR-bps-show [date aticker]
  &quot;coll of ATR numbers&quot;
  (let  [tech (ohlcv-date date aticker)
         h (cond (nil? tech) nil :else
                 (:h tech))
         l (cond (nil? tech) nil :else
                 (:l tech))
         c (cond (nil? tech) nil :else
                 (:c tech))]
    (if (nil? h)
      (identity nil)
      (let [hl (rest (map incanter/abs (map u/return_bps h l)))
            hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
            lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))]
        (map vector hl hc lc)
;(identity tech)))))</pre></td></tr><tr><td class="docs"><p>which atr dropped the most yesterday, lets assume that goes back up</p>
</td><td class="codes"><pre class="brush: clojure">(defn ATR-bps-T1
  ([date aticker]
   (let  [tech (ohlcv-date date  aticker)
          h (cond (nil? tech) nil :else
                  (:h tech))
          l (cond (nil? tech) nil :else
                  (:l tech))
          c (cond (nil? tech) nil :else
                  (:c tech))]
     (if (nil? h)
       (identity nil)
       (let [hl (rest (map incanter/abs (map u/return_bps h l)))
             hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
             lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))
             ATR (map #(apply max %) (map vector hl hc lc))]
         (u/round2 0 (- (last ATR) (last (drop-last ATR))))))))
  ([aticker]
   (let  [tech (ohlcv aticker)
          h (cond (nil? tech) nil :else
                  (:h tech))
          l (cond (nil? tech) nil :else
                  (:l tech))
          c (cond (nil? tech) nil :else
                  (:c tech))]
     (if (nil? h)
       (identity nil)
       (let [hl (rest (map incanter/abs (map u/return_bps h l)))
             hc (map incanter/abs (map u/return_bps (rest h) (drop-last c)))
             lc (map incanter/abs (map u/return_bps (rest l) (drop-last c)))
             ATR (map #(apply max %) (map vector hl hc lc))]
         (u/round2 0 (- (last ATR) (last (drop-last ATR))))
        ;; this should be negative for turbulent stocks that have stabilized)))))</pre></td></tr><tr><td class="docs"><p>(ATR-bps-oc 1 "ZGNX")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(u/lPlot2 (ATR-bps "IBTX")  (ATR-bps "IBTX")  )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stdev-adj-trend [fast slow aticker]
  (let  [tech (ohlcv aticker)
         s (cond (nil? tech) nil :else
                 (stats/sd (:c (ohlcv aticker))))] (if (or (nil? s) (zero? s)) (identity nil) (map #(/ % s) (trend fast slow aticker)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stdev-adj-trend2 [fast slow aticker]
  (let  [tech (ohlcv aticker)
         s (cond (nil? tech) nil :else
                 (stats/sd (:c (ohlcv aticker))))] (if (or (nil? s) (zero? s)) (identity nil) (map #(/ % s) (trend2 fast slow aticker)))))</pre></td></tr><tr><td class="docs"><p>(ATR-bps-oc "EDIT")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(normalize (stdev-adj-trend 8 24 "SYT"))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(reverse nil)</p>
</td><td class="codes"><pre class="brush: clojure">(defn consolidated-trend [aticker]
  (let [sum-of-trends (map + (reverse (u/normalize (stdev-adj-trend 8 24 aticker)))
                           (reverse (u/normalize (stdev-adj-trend 16 48 aticker)))
                           (reverse (u/normalize (stdev-adj-trend 32 96 aticker))))]
    (if (empty? sum-of-trends) (identity nil) (map (partial u/round2 0)  (reverse sum-of-trends)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn consolidated-trend2 [aticker]
  &quot;intraday&quot;
  (let [sum-of-trends (map + (reverse (u/normalize (stdev-adj-trend2 8 24 aticker)))
                           (reverse (u/normalize (stdev-adj-trend2 16 48 aticker)))
                           (reverse (u/normalize (stdev-adj-trend2 32 96 aticker))))]
    (if (empty? sum-of-trends) (identity nil) (map (partial u/round2 0)  (reverse sum-of-trends)))))</pre></td></tr><tr><td class="docs"><p>(consolidated-trend "BAOA")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prices-ema [days aticker]
  (let [tech (ohlcv aticker)]
    (ema days (:c tech))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prices [aticker]
  (let [tech (ohlcv aticker)]
    (:c tech)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ema-slope [days aticker]
  (let [tech (ohlcv aticker)
        EMA     (ema days (:c tech))]
    (u/sign (stats/median (map - (rest EMA) (drop-last EMA))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn view-prices [aticker]
  (u/lPlot3 (prices-ema 14 aticker)  (prices-ema 7 aticker)  (prices aticker)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn current-price [aticker]
  &quot;tell me close price tom based on recent n day slope&quot;
  (let [tech (ohlcv aticker)]
    (last (:c tech))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn forecast-slope [days aticker]
  &quot;tell me close price tom based on recent n day slope&quot;
  (let [tech (ohlcv aticker)
        EMA     (ema days (:c tech))]
    (+ (last EMA) (last (map - (rest EMA) (drop-last EMA))))))</pre></td></tr><tr><td class="docs"><p>(trend 14 "RH")
(ema-slope 14 "RH")</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(view-prices "TSLA")
(forecast-slope 14 "TSLA")
(current-price "TSLA")</p>
</td><td class="codes"><pre class="brush: clojure">(defn intraday [aticker] (let [data (ohlcv aticker)
                               returns (u/round2 2 (/ (last (map - (:c data) (:o data))) (:aprice data)))]
                           (identity returns)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ten-day-stdev [aticker] (let [data (ohlcv aticker)
                                    stdev (u/round2 2 (stats/sd (take-last 10 (:c data))))]
                                (identity stdev)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn intraday-movement [aticker] (let [data (ohlcv aticker)
                                        avg-move (u/round2 2 (stats/mean (map u/abs (map - (:c data) (:o data)))))]
                                    (identity avg-move)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-tails [k col]
  (clojure.pprint/pprint (take k col))
  (clojure.pprint/pprint (take-last k col)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn take-tails [k col]
  (concat (take k col)  (take-last k col)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def adv-map (map vector tickers (map :adv (map ohlcv tickers))))</pre></td></tr><tr><td class="docs"><p>(print-tails (sort-by second adv-map))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (def ticlist (map first (filter #(&gt; (second %) adv-cutoff-millions) adv-map)))
  (spit  (str  HOME &quot;/data/ticlist.pickle&quot;) (pr-str ticlist)))</pre></td></tr><tr><td class="docs"><p>(def ticlist (read-string (slurp  (str  HOME "/data/ticlist.pickle" ) )))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def intraday-returns (map vector ticlist        (map intraday ticlist       )))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(ohlcv "VWR")
(print-tails (sort-by second intraday-returns))
(def old-one (sort-by second intraday-returns))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(print-tails (sort-by second adv-map))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(filter #(contains? (set liquid-tickers) (first %) )   )</p>
</td><td class="codes"><pre class="brush: clojure">(def mid-tickers (map :aticker (filter #(= &quot;mid&quot; (:type %)) (map ohlcv tickers))))</pre></td></tr><tr><td class="docs"><p>(def small-tickers (map :aticker (filter #(= "small" (:type %)) (map ohlcv tickers))))</p>
</td><td class="codes"><pre class="brush: clojure">(def large-tickers (map :aticker (filter #(= &quot;large&quot; (:type %)) (map ohlcv tickers))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def small-tickers (map :aticker (filter #(= &quot;small&quot; (:type %)) (map ohlcv tickers))))</pre></td></tr><tr><td class="docs"><p>(take 10 large-tickers)
(def ten-day-stdev-map (map vector mid-tickers (map ten-day-stdev mid-tickers)))
(print-tails 20 (sort-by second ten-day-stdev-map))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>good ticker logic</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def mc-cutoff 1000E6)
(def price-cutoff 10.0)
(def price-cutoff-hi 120.0)
(def adv-cutoff-millions 20.0)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn good-ticker? [aticker]
  (let [this-data (ohlcv aticker)
        result (cond (nil? this-data) (identity false)
                     :else
                     (let [this-status (:status this-data)
                           this-adv (:adv this-data)
                           this-name (stock-names aticker)
                           this-close (last (:c this-data))]
                       (if (or  (zero? this-close)  (nil? this-name) (not= &quot;Active&quot; this-status) (or (zero? this-adv) (nil? this-adv))
                                (&lt; this-adv adv-cutoff-millions)
                                (&lt; this-close price-cutoff)
                                (&gt;= this-close price-cutoff-hi))
                         (identity false) (identity true))))]
    (identity result)))</pre></td></tr><tr><td class="docs"><p>(println (ohlcv "BR"))
(stock-names "AZPN")
(good-ticker? "BR")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames-mid (filter good-ticker? mid-tickers))</pre></td></tr><tr><td class="docs"><p>(count clean-ticnames-mid)</p>
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames-large (filter good-ticker? large-tickers))</pre></td></tr><tr><td class="docs"><p>(count clean-ticnames-large)</p>
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames-small (filter good-ticker? small-tickers))</pre></td></tr><tr><td class="docs"><p>(count clean-ticnames-small)
(println small-tickers)</p>
</td><td class="codes"><pre class="brush: clojure">(def clean-ticnames (concat clean-ticnames-small  clean-ticnames-mid  clean-ticnames-large))</pre></td></tr><tr><td class="docs"><p>(def trend-map (map vector mid-tickers (map consolidated-trend2 clean-ticnames ) ))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(println trend-map)</p>
</td><td class="codes"><pre class="brush: clojure">(count clean-ticnames)</pre></td></tr><tr><td class="docs"><p>define a ranking to take a function and return a list of 20 stock</p>
</td><td class="codes"><pre class="brush: clojure">(defn adapt-indicator-data [date indicator-data]
  (second (last (filter #(&lt;= (first %) date) (map vector (:dates indicator-data) (utils/lag 1 (:data indicator-data)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rank-simple-trend-live [ticnames date]
  (let [to-sort (map vector ticnames (map #(adapt-indicator-data date (simple-trend-live 10  %))  ticnames))
        out (take 20 (reverse (sort-by #(-&gt; % second incanter/abs) to-sort)))]
    out))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rank-intraday-movement-live [ticnames date]
  (let [to-sort (map vector ticnames (map #(adapt-indicator-data date (intraday-movement-live %))  ticnames))
        out (map first (take 5 (reverse (sort-by #(-&gt; % second incanter/abs) to-sort))))]
    out))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(rank-simple-trend-live clean-ticnames-mid 20171205)</pre></td></tr><tr><td class="docs"><p>this seems like a good one</p>
</td><td class="codes"><pre class="brush: clojure">(rank-intraday-movement-live clean-ticnames-mid 20171204)
(rank-intraday-movement-live clean-ticnames-small 20171204)
(rank-intraday-movement-live clean-ticnames-large 20171204)</pre></td></tr><tr><td class="docs"><p>clean up this file for quick analysis from cmdline</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def N 60)
(def dates (take-last N (recent-dates)))
(def above (map #(rank-intraday-movement-live clean-ticnames-small %)  (take-last N (recent-dates))))
(identity above)
(identity dates)
(def above (map #(vector (str/join &quot;,&quot; %)) above))
(def token (u/random-word))
(def above (map conj above (repeat (count dates) token)))</pre></td></tr><tr><td class="docs"><p>(map cons dates above)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def rank-data (map utils/coll-&gt;string2 (map cons dates above)))
(identity rank-data)
(maxp #(spit (str &quot;/home/puru/Dropbox/data/rank-&quot; token &quot;.txt&quot;) % :append true) rank-data)</pre></td></tr><tr><td class="docs"><p>wrong, dont use this...target format of data is [[] [] [] [] ] for each date target format of data is [[] [] [] [] ] for each date </p>
</td><td class="codes"><pre class="brush: clojure">(comment (def advs (map vector clean-ticnames-mid (map adv clean-ticnames-mid)))
         (def most-liquid (map first (take-last 20 (sort-by second advs))))
         (spit &quot;/home/puru/Dropbox/data/most-liquid-tickers.data&quot; (pr-str most-liquid))
         (spit &quot;/home/puru/Dropbox/data/recent-dates.data&quot; (pr-str (:dates (ohlcv (first most-liquid)))))
         (def small-ohlcv-data (zipmap (map keyword clean-ticnames-small) (map ohlcv clean-ticnames-small)))
;; goal is to predict close-open
;; assemble factors that can help
         (zipmap (map keyword clean-ticnames-mid) (map #(-&gt; % consolidated-trend2) clean-ticnames-mid))
         (take 10 (reverse (sort-by second (zipmap (map keyword clean-ticnames-mid) (map #(-&gt; % ATR-bps last) clean-ticnames-mid)))))
         (map #(-&gt; % consolidated-trend2) clean-ticnames-mid)
         (take 10 (reverse (sort-by second (zipmap (map keyword clean-ticnames-mid) (map #(-&gt; % ATR-bps last) clean-ticnames-mid)))))
         (map (juxt #(-&gt; % consolidated-trend2) #(-&gt; % ATR-bps)) clean-ticnames-mid)
         (incanter/to-dataset {:a [1 2 3] :b [1 2 3]})
         (def aticker &quot;EDIT&quot;)
         (defn factor-data [aticker] (incanter/to-dataset {:ctrend (drop-last (vec (consolidated-trend2 aticker)))
                                                           :atr (drop-last (vec (ATR-bps aticker)))
                                                           :close-open (rest (vec (close-open-bps aticker)))
                                                           :ticker
                                                           (vec (repeat (count (rest (close-open-bps aticker))) aticker))}))
         (defn factor-data2
           [aticker]
           {:data
            (map vector
                 (drop-last (vec (consolidated-trend2 aticker)))
                 (drop-last (vec (ATR-bps aticker)))
                 (utils/lag 1 (drop-last (vec (ATR-bps aticker))))
                 (utils/lag 2 (drop-last (vec (ATR-bps aticker))))
                 (utils/lag 3 (drop-last (vec (ATR-bps aticker))))
                 (utils/lag 4 (drop-last (vec (ATR-bps aticker))))
;;to predict, lookahead is one here
                 (rest (vec (close-open-bps aticker)))
;;
                 (utils/lag 1 (rest (vec (close-open-bps aticker))))
                 (drop-last (vec (volume-change-bps aticker)))
                 (vec (repeat (count (rest (close-open-bps aticker))) aticker))
                 (drop-last (:dates (ohlcv aticker))))
            :header
            [&quot;consolidated-trend2&quot; &quot;ATR-bps&quot; &quot;ATR-bps.1&quot; &quot;ATR-bps.2&quot; &quot;ATR-bps.3&quot; &quot;ATR-bps.4&quot;  &quot;close-open-bps&quot; &quot;close-open-bps.1&quot; &quot;volume-change-bps&quot; &quot;ticker&quot; &quot;date&quot;]})
         (defn factor-data
           [aticker]
           {:data
            (map vector
                 (vec (consolidated-trend2 aticker))
                 (vec (ATR-bps aticker))
;;to predict, lookahead is one here
                 (utils/lookahead 1 (vec (close-open-bps aticker)))
;;
                 (vec (volume-change-bps aticker))
                 (vec (repeat (count (close-open-bps aticker)) aticker))
                 (:dates (ohlcv aticker)))
            :header
            [&quot;consolidated-trend2&quot; &quot;ATR-bps&quot; &quot;close-open-bps&quot; &quot;volume-change-bps&quot; &quot;ticker&quot; &quot;date&quot;]})
         (def small-factor-data
           {:header
            (first (map :header (map factor-data clean-ticnames-small)))
            :data
            (apply concat (map :data (map factor-data clean-ticnames-small)))})
         (def mid-factor-data
           {:header
            (first (map :header (map factor-data clean-ticnames-mid)))
            :data
            (apply concat (map :data (map factor-data clean-ticnames-mid)))})
;;define datagen file
         (defn write-dataset [f_ this-factor-data]
           (let [;first-datapoint? (not (.exists (io/as-file f_)))
                 data (:data this-factor-data)
                 header (:header this-factor-data)]
             (spit f_ (u/coll-&gt;string header) :append true)
             (doseq [data-points (map u/coll-&gt;string data)]
               (spit f_ data-points :append true))))
         (do (def token (u/random-word))
             (def factor-file (str &quot;/home/puru/data/factors-small-&quot; (str (gensym token)) &quot;.txt&quot;))
             (write-dataset factor-file small-factor-data)
             (pprint factor-file))
         (do (def token (u/random-word))
             (def factor-file (str &quot;/home/puru/data/factors-mid-&quot; (str (gensym token)) &quot;.txt&quot;))
             (write-dataset factor-file mid-factor-data)
             (pprint factor-file))
         (first (:data mid-factor-data))
;; does c trend predict close-open?
;; appears atr -1 is the best single handed predictor
;; spose you use that
;; each date maps to what you will trade
         (def dates (:dates (ohlcv &quot;AAPL&quot;)))
         (defn asset-list [factor-data date] (let [tmp-data (filter #(= date (last %)) (:data factor-data))
                                                   trade-these (cond (empty? tmp-data) nil :else
                                                                     (map #(nth % 4) (take 10 (reverse (sort-by #(second %) tmp-data)))))]
                                               trade-these))
;; this the walkforward ticker set we need to test on
         (def trade-these-mid (map vector dates (u/lag 1 (map (partial asset-list mid-factor-data) dates))))
         (spit &quot;/home/puru/Dropbox/data/trade-these-mid.data&quot; (pr-str trade-these-mid))
         (def trade-these-small (map vector dates (u/lag 1 (map (partial asset-list mid-factor-data) dates))))
         (spit &quot;/home/puru/Dropbox/data/trade-these-small.data&quot; (pr-str trade-these-mid)))</pre></td></tr><tr><td class="docs"><p>test work</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(count (filter good-ticker? (map first (filter #(and (= "Major Pharmaceuticals"  (nth % 5) )     (= "Health Care" (nth % 4) )   ) nasdaq-data))))</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.portfolio" name="matrix.portfolio"><h1 class="project-name">matrix.portfolio</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.portfolio
  (:require
   [matrix.utils :as utils]
   [matrix.data :as data]
   [matrix.indicators :as indicators]
   [matrix.agents :as agents]
   [matrix.tickers :as tickers]
   [matrix.jutsudata :as jutsudata]
   [matrix.tradinglogic :as tradinglogic]
   [repltrader.execution :as execution]
   [repltrader.gateway :as gateway]
   [jutsu.core :as j]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [clj-http.client :as client]
   [clj-time.format :as tf]
   [clj-time.core :as tt]
   [clojure.tools.nrepl.server :as serv]
   [incanter.interpolation :refer :all]
   [incanter [core :refer [$]
              :as incanter$]
    [core :as incanter]
    [stats :as stats]
    [io :as io2]
    [charts :as charts]
    [datasets :as dataset]
                                        ;[interpolation :as interpolation]
]
   [clojure.core.async
    :as clojurecoreasync
    :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
            alts! alts!! timeout]]
   [clojure.tools.cli :refer [cli]] [matrix.utils :as u]
   [taoensso.timbre :as timbre]
   [clojure.term.colors :refer :all])  (:use clojure.pprint)
  (:require [clojure.tools.cli :refer [parse-opts]])
;  (:gen-class))</pre></td></tr><tr><td class="docs"><p>work for pre market stuff</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn getTrades-extended-new-premarket
  [portfolio date]
  (let [;p-folio [&quot;HOG&quot; &quot;TGT&quot;]
       ;date 20180125
        times [[&quot;063000&quot; &quot;070000&quot;]
               [&quot;070000&quot; &quot;073000&quot;]
               [&quot;073000&quot; &quot;080000&quot;]
               [&quot;080000&quot; &quot;083000&quot;]
               [&quot;083000&quot; &quot;090000&quot;]
               [&quot;090000&quot; &quot;093000&quot;]]
        dataset (atom '())]
    (doseq [tic portfolio] (doseq [time times]
                             (let [msgs-dirty (data/getTradesNew tic date (first time) (second time))
                                   bind? (cond (= 2 (count (str/split (first msgs-dirty) #&quot;,&quot;)))  false  :else true)]
                               (if bind? (swap! dataset concat
                                                (data/getTradesNew tic date (first time) (second time)))))))
    (sort-by #(read-string (second (str/split % #&quot;,&quot;))) @dataset)))</pre></td></tr><tr><td class="docs"><p>(take 10 (filter #(= \T (first %)) (getTradesQuotes-extended-new-premarket ["MDLZ"] 20180202 )) )</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pre-market-volume [ticker date]
  (reduce + (map #(read-string (nth (str/split % #&quot;,&quot;) 3)) (getTrades-extended-new-premarket [ticker] date))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pre-market-price [ticker date]
  (stats/mean (map #(read-string (nth (str/split % #&quot;,&quot;) 2)) (getTrades-extended-new-premarket [ticker] date))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pre-market-price-volume [ticker date]
  (let [tmp (getTrades-extended-new-premarket [ticker] date)
        volumes    (map #(read-string (nth (str/split % #&quot;,&quot;) 3)) tmp)
        prices    (map #(read-string (nth (str/split % #&quot;,&quot;) 2)) tmp)]
    [(stats/mean prices)  (reduce + volumes)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pre-volume-ratio [tic date] (let [;tic &quot;IIVI&quot;
                                ;date 20180202
                                        prev-day (nth (tickers/recent-dates) (- (.indexOf (tickers/recent-dates) date) 1))
                                        todays-volume (pre-market-volume tic date)
                                        yest-volume (pre-market-volume tic prev-day)
                                        ratio (cond (zero? yest-volume) 0 :else (int (/ todays-volume yest-volume)))]
                                    ratio))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pre-price-ratio [tic date] (let [;tic &quot;IIVI&quot;
                                ;date 20180202
                                ;prev-day (nth (tickers/recent-dates) (- (.indexOf (tickers/recent-dates) date) 1 ))
                                       todays-price (pre-market-price tic date)
                                       yest-price (last (:c (tickers/ohlcv-date date tic)))
                                       ratio (cond (zero? yest-price) 0 :else
                                                   (utils/round (apply max [(/ todays-price yest-price) (/ yest-price todays-price)])))]
                                   ratio))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def results-v
  (let [gt
        (filter tickers/good-ticker? tickers/tickers)] (map vector gt (map #(pre-volume-ratio % 20180202)
                                                                           gt))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn results-p [date]
  (let [gt
        (filter tickers/good-ticker? tickers/tickers)] (map vector gt (map #(pre-price-ratio % date)
                                                                           gt))))</pre></td></tr><tr><td class="docs"><p>(pre-price-ratio "AMBA" 20180209)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(pprint (reverse (sort-by second results-v)))
(pprint (take 20 (reverse (sort-by second (results-p 20180209)))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(def s-v (map vector (map first results-v) (utils/zscore (map second results-v) )))</p>
</td><td class="codes"><pre class="brush: clojure">(;def s-p (map vector (map first results-p) (utils/zscore (map second results-p) ))
)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(;def trade-these (map first (reverse (sort-by second (map vector (map first s-v) (map #(+ (second %2) (second %1 ))  s-v s-p  )))))
)</pre></td></tr><tr><td class="docs"><p>(pprint (take 20 (map first (reverse (sort-by second results)))))
(pprint (str/join "," trade-these))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def r (results-p 20180209))
(pprint r)
(pprint (str/join &quot;,&quot; (map first (take-last  20 (sort-by second r)))))</pre></td></tr><tr><td class="docs"><p>(def movers )
("DECK" "RGC" "EUFN" "ES" "DATA" "AWK" "GRUB" "ADP" "HPQ" "TEAM")</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pre-price-ratio-live [indicator-state tic date] (let [;tic &quot;IIVI&quot;
                                                            todays-price (:data (indicators/l1-price indicator-state (keyword tic) (keyword (str date))))
                                                            yest-price (last (:c (tickers/ohlcv-date date tic)))
                                                            ratio (cond (or (zero? todays-price) (zero? yest-price)) 0 :else
                                                                        (apply max  [(/ todays-price yest-price) (/ yest-price todays-price)]))]
                                                        ratio))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pre-volume-ratio-live [indicator-state tic date] (let [;tic &quot;IIVI&quot;
                                                             todays-volume (:data (indicators/l1-volume indicator-state (keyword tic) (keyword (str date))))
                                                             yest-volume (last (:v (tickers/ohlcv-date date tic)))
                                                             ratio (cond (or (zero? todays-volume) (zero? yest-volume)) 0 :else
                                                                         (apply max  [(/ todays-volume yest-volume) (/ yest-volume todays-volume)]))]
                                                         ratio))</pre></td></tr><tr><td class="docs"><p>FDC,BAH,BZUN,CTLT,GRUB,DKS,FSLR,GOLD,ES,AOS,EC,HCC,BG,CORT,ARNC,BMY,HES,FCAU,AMD,CZR</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def gt (filter tickers/good-ticker? tickers/tickers))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn hl [date aticker] (let [dates (tickers/recent-dates)
                              N (+ 1 (.indexOf dates date))
                              date-next (nth dates N)
                              d (tickers/ohlcv-date date aticker)
                              c (last (:c d))
                              o (last (:o d))
                              hl (incanter/abs (last (map utils/return-bps (:c d) (:o d))))]
;date-next
                          hl
                          [c o]))</pre></td></tr><tr><td class="docs"><p>debug this
(hl 20180201 "RH")</p>
</td><td class="codes"><pre class="brush: clojure">(def token (utils/random-word))
(io/delete-file &quot;/home/puru/data/tickers.data&quot; :quiet)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment [date (drop-last (tickers/recent-dates))]
  ;(def date (nth (tickers/recent-dates ) 21))
         (def hls (map (partial hl date) gt))
         (def movers (map first (take-last 5 (sort-by second (map vector gt hls)))))
;(spit &quot;/home/puru/data/tickers.data&quot; (str(str/join &quot;,&quot; movers) &quot; &quot; date &quot; &quot; date &quot; &quot; token &quot;\n&quot; )  :append true ))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#matrix.timekeeper" name="matrix.timekeeper"><h1 class="project-name">matrix.timekeeper</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns matrix.timekeeper (:require
  ;[matrix.tickers :as tickers]
                       [clojure.java.io :as io]
                       [clojure.string :as str]
                       [clj-http.client :as client]
                       [clj-time.format :as tf]
                       [clj-time.core :as tt]
                       [clojure.tools.nrepl.server :as serv]
                       [incanter.interpolation :refer :all]
                       [incanter [core :refer [$]
                                  :as incanter$]
                        [core :as incanter]
                        [stats :as stats]
                        [io :as io2]
                        [charts :as charts]
                        [datasets :as dataset]
                                        ;[interpolation :as interpolation]
]
                       [clojure.core.async
                        :as clojurecoreasync
                        :refer [&gt;! &lt;! &gt;!! &lt;!! go chan buffer close! thread
                                alts! alts!! timeout]]
                       [clojure.tools.cli :refer [cli]] [taoensso.timbre :as timbre]
                       [clojure.term.colors :refer :all])  (:use clojure.pprint)
    (:require [clojure.tools.cli :refer [parse-opts]])
    (:gen-class))</pre></td></tr><tr><td class="docs"><p>(def time-now (zipmap (map keyword tickers/huge-tickers) (repeatedly (count tickers/huge-tickers) #(atom 0)         )))</p>
</td><td class="codes"><pre class="brush: clojure">(def global-time-now (atom 0.0))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/gdeer81/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_matrix.summary">matrix.summary</li><li class="floating-toc-li" id="floating-toc_matrix.pnl">matrix.pnl</li><li class="floating-toc-li" id="floating-toc_matrix.failures">matrix.failures</li><li class="floating-toc-li" id="floating-toc_matrix.jutsudata">matrix.jutsudata</li><li class="floating-toc-li" id="floating-toc_matrix.utils">matrix.utils</li><li class="floating-toc-li" id="floating-toc_matrix.tickers">matrix.tickers</li><li class="floating-toc-li" id="floating-toc_matrix.data">matrix.data</li><li class="floating-toc-li" id="floating-toc_matrix.indicators">matrix.indicators</li><li class="floating-toc-li" id="floating-toc_matrix.neuralnet">matrix.neuralnet</li><li class="floating-toc-li" id="floating-toc_matrix.train">matrix.train</li><li class="floating-toc-li" id="floating-toc_matrix.core">matrix.core</li><li class="floating-toc-li" id="floating-toc_matrix.agents">matrix.agents</li><li class="floating-toc-li" id="floating-toc_matrix.processdata">matrix.processdata</li><li class="floating-toc-li" id="floating-toc_matrix.tradinglogic">matrix.tradinglogic</li><li class="floating-toc-li" id="floating-toc_matrix.trackorders">matrix.trackorders</li><li class="floating-toc-li" id="floating-toc_matrix.tickers_big">matrix.tickers_big</li><li class="floating-toc-li" id="floating-toc_matrix.portfolio">matrix.portfolio</li><li class="floating-toc-li" id="floating-toc_matrix.timekeeper">matrix.timekeeper</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.all();

// hackity hack
$(window).load(function() {
    var ft = $("#floating-toc");
    var ul = ft.find('ul');
    var lis = ft.find('li');
    var liHeight = $(lis.first()).height();

    ul.css('margin', '0px');
    ft.css('height', liHeight + 'px');

    showNs = function(ns) {
        var index = 0;

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i;
        }

        if(index != lastNsIndex) {
            lastNsIndex = index;
            ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300);
        }

    }

    var calcNsPositions = function() {
        var hheight = $('.docs-header').first().height();
        var nss = [];
        var anchors = [];
        var positions = [];
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1];
            nss.push(ns);
            var a = $("a[name='"+ns+"']");
            anchors.push(a);
            positions.push(a.offset().top - hheight);
            // console.log(a.offset().top)
        });

        return {nss: nss, positions: positions};
    }

    var nsPositions = calcNsPositions();
    // console.log(nsPositions)
    var lastNsIndex = -1;
    var $window = $(window);

    var currentSection = function(nsp) {
        var ps = nsp.positions;
        var scroll = $window.scrollTop();
        var nsIndex = -1;

        for(var i = 0, length = ps.length; i < length; i++) {
            if(ps[i] >= scroll) {
                nsIndex = i-1;
                break;
            }
        }

        if(nsIndex == -1) {
             if(scroll >= ps[0]) {
                 nsIndex = ps.length - 1;
             } else {
                 nsIndex = 0;
             }
        }

        return nsp.nss[nsIndex];
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions));
    });
});
</script></body></html>